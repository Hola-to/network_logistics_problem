// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             (unknown)
// source: logistics/simulation/v1/simulation.proto

package simulationv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	SimulationService_RunWhatIf_FullMethodName            = "/logistics.simulation.v1.SimulationService/RunWhatIf"
	SimulationService_CompareScenarios_FullMethodName     = "/logistics.simulation.v1.SimulationService/CompareScenarios"
	SimulationService_RunTimeSimulation_FullMethodName    = "/logistics.simulation.v1.SimulationService/RunTimeSimulation"
	SimulationService_SimulatePeakLoad_FullMethodName     = "/logistics.simulation.v1.SimulationService/SimulatePeakLoad"
	SimulationService_RunMonteCarlo_FullMethodName        = "/logistics.simulation.v1.SimulationService/RunMonteCarlo"
	SimulationService_RunMonteCarloStream_FullMethodName  = "/logistics.simulation.v1.SimulationService/RunMonteCarloStream"
	SimulationService_AnalyzeSensitivity_FullMethodName   = "/logistics.simulation.v1.SimulationService/AnalyzeSensitivity"
	SimulationService_FindCriticalElements_FullMethodName = "/logistics.simulation.v1.SimulationService/FindCriticalElements"
	SimulationService_SimulateFailures_FullMethodName     = "/logistics.simulation.v1.SimulationService/SimulateFailures"
	SimulationService_AnalyzeResilience_FullMethodName    = "/logistics.simulation.v1.SimulationService/AnalyzeResilience"
	SimulationService_SaveSimulation_FullMethodName       = "/logistics.simulation.v1.SimulationService/SaveSimulation"
	SimulationService_GetSimulation_FullMethodName        = "/logistics.simulation.v1.SimulationService/GetSimulation"
	SimulationService_ListSimulations_FullMethodName      = "/logistics.simulation.v1.SimulationService/ListSimulations"
	SimulationService_Health_FullMethodName               = "/logistics.simulation.v1.SimulationService/Health"
)

// SimulationServiceClient is the client API for SimulationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SimulationServiceClient interface {
	// Запуск what-if сценария
	RunWhatIf(ctx context.Context, in *RunWhatIfRequest, opts ...grpc.CallOption) (*RunWhatIfResponse, error)
	// Сравнение нескольких сценариев
	CompareScenarios(ctx context.Context, in *CompareScenariosRequest, opts ...grpc.CallOption) (*CompareScenariosResponse, error)
	// Симуляция с временными параметрами
	RunTimeSimulation(ctx context.Context, in *RunTimeSimulationRequest, opts ...grpc.CallOption) (*RunTimeSimulationResponse, error)
	// Симуляция пиковых нагрузок
	SimulatePeakLoad(ctx context.Context, in *SimulatePeakLoadRequest, opts ...grpc.CallOption) (*SimulatePeakLoadResponse, error)
	// Запуск Monte Carlo симуляции
	RunMonteCarlo(ctx context.Context, in *RunMonteCarloRequest, opts ...grpc.CallOption) (*RunMonteCarloResponse, error)
	// Streaming для долгих Monte Carlo симуляций
	RunMonteCarloStream(ctx context.Context, in *RunMonteCarloRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[MonteCarloProgress], error)
	// Анализ чувствительности
	AnalyzeSensitivity(ctx context.Context, in *AnalyzeSensitivityRequest, opts ...grpc.CallOption) (*AnalyzeSensitivityResponse, error)
	// Поиск критических элементов
	FindCriticalElements(ctx context.Context, in *FindCriticalElementsRequest, opts ...grpc.CallOption) (*FindCriticalElementsResponse, error)
	// Симуляция отказов
	SimulateFailures(ctx context.Context, in *SimulateFailuresRequest, opts ...grpc.CallOption) (*SimulateFailuresResponse, error)
	// Анализ устойчивости сети
	AnalyzeResilience(ctx context.Context, in *AnalyzeResilienceRequest, opts ...grpc.CallOption) (*AnalyzeResilienceResponse, error)
	// Сохранить симуляцию
	SaveSimulation(ctx context.Context, in *SaveSimulationRequest, opts ...grpc.CallOption) (*SaveSimulationResponse, error)
	// Получить симуляцию
	GetSimulation(ctx context.Context, in *GetSimulationRequest, opts ...grpc.CallOption) (*GetSimulationResponse, error)
	// Список симуляций
	ListSimulations(ctx context.Context, in *ListSimulationsRequest, opts ...grpc.CallOption) (*ListSimulationsResponse, error)
	// Health
	Health(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error)
}

type simulationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSimulationServiceClient(cc grpc.ClientConnInterface) SimulationServiceClient {
	return &simulationServiceClient{cc}
}

func (c *simulationServiceClient) RunWhatIf(ctx context.Context, in *RunWhatIfRequest, opts ...grpc.CallOption) (*RunWhatIfResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RunWhatIfResponse)
	err := c.cc.Invoke(ctx, SimulationService_RunWhatIf_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *simulationServiceClient) CompareScenarios(ctx context.Context, in *CompareScenariosRequest, opts ...grpc.CallOption) (*CompareScenariosResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CompareScenariosResponse)
	err := c.cc.Invoke(ctx, SimulationService_CompareScenarios_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *simulationServiceClient) RunTimeSimulation(ctx context.Context, in *RunTimeSimulationRequest, opts ...grpc.CallOption) (*RunTimeSimulationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RunTimeSimulationResponse)
	err := c.cc.Invoke(ctx, SimulationService_RunTimeSimulation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *simulationServiceClient) SimulatePeakLoad(ctx context.Context, in *SimulatePeakLoadRequest, opts ...grpc.CallOption) (*SimulatePeakLoadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SimulatePeakLoadResponse)
	err := c.cc.Invoke(ctx, SimulationService_SimulatePeakLoad_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *simulationServiceClient) RunMonteCarlo(ctx context.Context, in *RunMonteCarloRequest, opts ...grpc.CallOption) (*RunMonteCarloResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RunMonteCarloResponse)
	err := c.cc.Invoke(ctx, SimulationService_RunMonteCarlo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *simulationServiceClient) RunMonteCarloStream(ctx context.Context, in *RunMonteCarloRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[MonteCarloProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &SimulationService_ServiceDesc.Streams[0], SimulationService_RunMonteCarloStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[RunMonteCarloRequest, MonteCarloProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SimulationService_RunMonteCarloStreamClient = grpc.ServerStreamingClient[MonteCarloProgress]

func (c *simulationServiceClient) AnalyzeSensitivity(ctx context.Context, in *AnalyzeSensitivityRequest, opts ...grpc.CallOption) (*AnalyzeSensitivityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AnalyzeSensitivityResponse)
	err := c.cc.Invoke(ctx, SimulationService_AnalyzeSensitivity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *simulationServiceClient) FindCriticalElements(ctx context.Context, in *FindCriticalElementsRequest, opts ...grpc.CallOption) (*FindCriticalElementsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindCriticalElementsResponse)
	err := c.cc.Invoke(ctx, SimulationService_FindCriticalElements_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *simulationServiceClient) SimulateFailures(ctx context.Context, in *SimulateFailuresRequest, opts ...grpc.CallOption) (*SimulateFailuresResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SimulateFailuresResponse)
	err := c.cc.Invoke(ctx, SimulationService_SimulateFailures_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *simulationServiceClient) AnalyzeResilience(ctx context.Context, in *AnalyzeResilienceRequest, opts ...grpc.CallOption) (*AnalyzeResilienceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AnalyzeResilienceResponse)
	err := c.cc.Invoke(ctx, SimulationService_AnalyzeResilience_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *simulationServiceClient) SaveSimulation(ctx context.Context, in *SaveSimulationRequest, opts ...grpc.CallOption) (*SaveSimulationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SaveSimulationResponse)
	err := c.cc.Invoke(ctx, SimulationService_SaveSimulation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *simulationServiceClient) GetSimulation(ctx context.Context, in *GetSimulationRequest, opts ...grpc.CallOption) (*GetSimulationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSimulationResponse)
	err := c.cc.Invoke(ctx, SimulationService_GetSimulation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *simulationServiceClient) ListSimulations(ctx context.Context, in *ListSimulationsRequest, opts ...grpc.CallOption) (*ListSimulationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSimulationsResponse)
	err := c.cc.Invoke(ctx, SimulationService_ListSimulations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *simulationServiceClient) Health(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthResponse)
	err := c.cc.Invoke(ctx, SimulationService_Health_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SimulationServiceServer is the server API for SimulationService service.
// All implementations must embed UnimplementedSimulationServiceServer
// for forward compatibility.
type SimulationServiceServer interface {
	// Запуск what-if сценария
	RunWhatIf(context.Context, *RunWhatIfRequest) (*RunWhatIfResponse, error)
	// Сравнение нескольких сценариев
	CompareScenarios(context.Context, *CompareScenariosRequest) (*CompareScenariosResponse, error)
	// Симуляция с временными параметрами
	RunTimeSimulation(context.Context, *RunTimeSimulationRequest) (*RunTimeSimulationResponse, error)
	// Симуляция пиковых нагрузок
	SimulatePeakLoad(context.Context, *SimulatePeakLoadRequest) (*SimulatePeakLoadResponse, error)
	// Запуск Monte Carlo симуляции
	RunMonteCarlo(context.Context, *RunMonteCarloRequest) (*RunMonteCarloResponse, error)
	// Streaming для долгих Monte Carlo симуляций
	RunMonteCarloStream(*RunMonteCarloRequest, grpc.ServerStreamingServer[MonteCarloProgress]) error
	// Анализ чувствительности
	AnalyzeSensitivity(context.Context, *AnalyzeSensitivityRequest) (*AnalyzeSensitivityResponse, error)
	// Поиск критических элементов
	FindCriticalElements(context.Context, *FindCriticalElementsRequest) (*FindCriticalElementsResponse, error)
	// Симуляция отказов
	SimulateFailures(context.Context, *SimulateFailuresRequest) (*SimulateFailuresResponse, error)
	// Анализ устойчивости сети
	AnalyzeResilience(context.Context, *AnalyzeResilienceRequest) (*AnalyzeResilienceResponse, error)
	// Сохранить симуляцию
	SaveSimulation(context.Context, *SaveSimulationRequest) (*SaveSimulationResponse, error)
	// Получить симуляцию
	GetSimulation(context.Context, *GetSimulationRequest) (*GetSimulationResponse, error)
	// Список симуляций
	ListSimulations(context.Context, *ListSimulationsRequest) (*ListSimulationsResponse, error)
	// Health
	Health(context.Context, *HealthRequest) (*HealthResponse, error)
	mustEmbedUnimplementedSimulationServiceServer()
}

// UnimplementedSimulationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSimulationServiceServer struct{}

func (UnimplementedSimulationServiceServer) RunWhatIf(context.Context, *RunWhatIfRequest) (*RunWhatIfResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RunWhatIf not implemented")
}
func (UnimplementedSimulationServiceServer) CompareScenarios(context.Context, *CompareScenariosRequest) (*CompareScenariosResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CompareScenarios not implemented")
}
func (UnimplementedSimulationServiceServer) RunTimeSimulation(context.Context, *RunTimeSimulationRequest) (*RunTimeSimulationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RunTimeSimulation not implemented")
}
func (UnimplementedSimulationServiceServer) SimulatePeakLoad(context.Context, *SimulatePeakLoadRequest) (*SimulatePeakLoadResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SimulatePeakLoad not implemented")
}
func (UnimplementedSimulationServiceServer) RunMonteCarlo(context.Context, *RunMonteCarloRequest) (*RunMonteCarloResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RunMonteCarlo not implemented")
}
func (UnimplementedSimulationServiceServer) RunMonteCarloStream(*RunMonteCarloRequest, grpc.ServerStreamingServer[MonteCarloProgress]) error {
	return status.Error(codes.Unimplemented, "method RunMonteCarloStream not implemented")
}
func (UnimplementedSimulationServiceServer) AnalyzeSensitivity(context.Context, *AnalyzeSensitivityRequest) (*AnalyzeSensitivityResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AnalyzeSensitivity not implemented")
}
func (UnimplementedSimulationServiceServer) FindCriticalElements(context.Context, *FindCriticalElementsRequest) (*FindCriticalElementsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FindCriticalElements not implemented")
}
func (UnimplementedSimulationServiceServer) SimulateFailures(context.Context, *SimulateFailuresRequest) (*SimulateFailuresResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SimulateFailures not implemented")
}
func (UnimplementedSimulationServiceServer) AnalyzeResilience(context.Context, *AnalyzeResilienceRequest) (*AnalyzeResilienceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AnalyzeResilience not implemented")
}
func (UnimplementedSimulationServiceServer) SaveSimulation(context.Context, *SaveSimulationRequest) (*SaveSimulationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SaveSimulation not implemented")
}
func (UnimplementedSimulationServiceServer) GetSimulation(context.Context, *GetSimulationRequest) (*GetSimulationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSimulation not implemented")
}
func (UnimplementedSimulationServiceServer) ListSimulations(context.Context, *ListSimulationsRequest) (*ListSimulationsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListSimulations not implemented")
}
func (UnimplementedSimulationServiceServer) Health(context.Context, *HealthRequest) (*HealthResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Health not implemented")
}
func (UnimplementedSimulationServiceServer) mustEmbedUnimplementedSimulationServiceServer() {}
func (UnimplementedSimulationServiceServer) testEmbeddedByValue()                           {}

// UnsafeSimulationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SimulationServiceServer will
// result in compilation errors.
type UnsafeSimulationServiceServer interface {
	mustEmbedUnimplementedSimulationServiceServer()
}

func RegisterSimulationServiceServer(s grpc.ServiceRegistrar, srv SimulationServiceServer) {
	// If the following call panics, it indicates UnimplementedSimulationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SimulationService_ServiceDesc, srv)
}

func _SimulationService_RunWhatIf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunWhatIfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimulationServiceServer).RunWhatIf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SimulationService_RunWhatIf_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimulationServiceServer).RunWhatIf(ctx, req.(*RunWhatIfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SimulationService_CompareScenarios_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompareScenariosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimulationServiceServer).CompareScenarios(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SimulationService_CompareScenarios_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimulationServiceServer).CompareScenarios(ctx, req.(*CompareScenariosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SimulationService_RunTimeSimulation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunTimeSimulationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimulationServiceServer).RunTimeSimulation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SimulationService_RunTimeSimulation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimulationServiceServer).RunTimeSimulation(ctx, req.(*RunTimeSimulationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SimulationService_SimulatePeakLoad_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SimulatePeakLoadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimulationServiceServer).SimulatePeakLoad(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SimulationService_SimulatePeakLoad_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimulationServiceServer).SimulatePeakLoad(ctx, req.(*SimulatePeakLoadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SimulationService_RunMonteCarlo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunMonteCarloRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimulationServiceServer).RunMonteCarlo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SimulationService_RunMonteCarlo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimulationServiceServer).RunMonteCarlo(ctx, req.(*RunMonteCarloRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SimulationService_RunMonteCarloStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RunMonteCarloRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SimulationServiceServer).RunMonteCarloStream(m, &grpc.GenericServerStream[RunMonteCarloRequest, MonteCarloProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SimulationService_RunMonteCarloStreamServer = grpc.ServerStreamingServer[MonteCarloProgress]

func _SimulationService_AnalyzeSensitivity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnalyzeSensitivityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimulationServiceServer).AnalyzeSensitivity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SimulationService_AnalyzeSensitivity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimulationServiceServer).AnalyzeSensitivity(ctx, req.(*AnalyzeSensitivityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SimulationService_FindCriticalElements_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindCriticalElementsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimulationServiceServer).FindCriticalElements(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SimulationService_FindCriticalElements_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimulationServiceServer).FindCriticalElements(ctx, req.(*FindCriticalElementsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SimulationService_SimulateFailures_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SimulateFailuresRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimulationServiceServer).SimulateFailures(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SimulationService_SimulateFailures_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimulationServiceServer).SimulateFailures(ctx, req.(*SimulateFailuresRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SimulationService_AnalyzeResilience_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnalyzeResilienceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimulationServiceServer).AnalyzeResilience(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SimulationService_AnalyzeResilience_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimulationServiceServer).AnalyzeResilience(ctx, req.(*AnalyzeResilienceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SimulationService_SaveSimulation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveSimulationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimulationServiceServer).SaveSimulation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SimulationService_SaveSimulation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimulationServiceServer).SaveSimulation(ctx, req.(*SaveSimulationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SimulationService_GetSimulation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSimulationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimulationServiceServer).GetSimulation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SimulationService_GetSimulation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimulationServiceServer).GetSimulation(ctx, req.(*GetSimulationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SimulationService_ListSimulations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSimulationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimulationServiceServer).ListSimulations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SimulationService_ListSimulations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimulationServiceServer).ListSimulations(ctx, req.(*ListSimulationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SimulationService_Health_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SimulationServiceServer).Health(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SimulationService_Health_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SimulationServiceServer).Health(ctx, req.(*HealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SimulationService_ServiceDesc is the grpc.ServiceDesc for SimulationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SimulationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "logistics.simulation.v1.SimulationService",
	HandlerType: (*SimulationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RunWhatIf",
			Handler:    _SimulationService_RunWhatIf_Handler,
		},
		{
			MethodName: "CompareScenarios",
			Handler:    _SimulationService_CompareScenarios_Handler,
		},
		{
			MethodName: "RunTimeSimulation",
			Handler:    _SimulationService_RunTimeSimulation_Handler,
		},
		{
			MethodName: "SimulatePeakLoad",
			Handler:    _SimulationService_SimulatePeakLoad_Handler,
		},
		{
			MethodName: "RunMonteCarlo",
			Handler:    _SimulationService_RunMonteCarlo_Handler,
		},
		{
			MethodName: "AnalyzeSensitivity",
			Handler:    _SimulationService_AnalyzeSensitivity_Handler,
		},
		{
			MethodName: "FindCriticalElements",
			Handler:    _SimulationService_FindCriticalElements_Handler,
		},
		{
			MethodName: "SimulateFailures",
			Handler:    _SimulationService_SimulateFailures_Handler,
		},
		{
			MethodName: "AnalyzeResilience",
			Handler:    _SimulationService_AnalyzeResilience_Handler,
		},
		{
			MethodName: "SaveSimulation",
			Handler:    _SimulationService_SaveSimulation_Handler,
		},
		{
			MethodName: "GetSimulation",
			Handler:    _SimulationService_GetSimulation_Handler,
		},
		{
			MethodName: "ListSimulations",
			Handler:    _SimulationService_ListSimulations_Handler,
		},
		{
			MethodName: "Health",
			Handler:    _SimulationService_Health_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RunMonteCarloStream",
			Handler:       _SimulationService_RunMonteCarloStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "logistics/simulation/v1/simulation.proto",
}
