syntax = "proto3";

package logistics.simulation.v1;

import "google/protobuf/timestamp.proto";
import "logistics/common/v1/common.proto";

option go_package = "logistics/gen/go/simulation/v1;simulationv1";

service SimulationService {
  // ============ WHAT-IF ANALYSIS ============

  // Запуск what-if сценария
  rpc RunWhatIf(RunWhatIfRequest) returns (RunWhatIfResponse);

  // Сравнение нескольких сценариев
  rpc CompareScenarios(CompareScenariosRequest) returns (CompareScenariosResponse);

  // ============ TIME-DEPENDENT SIMULATION ============

  // Симуляция с временными параметрами
  rpc RunTimeSimulation(RunTimeSimulationRequest) returns (RunTimeSimulationResponse);

  // Симуляция пиковых нагрузок
  rpc SimulatePeakLoad(SimulatePeakLoadRequest) returns (SimulatePeakLoadResponse);

  // ============ MONTE CARLO ============

  // Запуск Monte Carlo симуляции
  rpc RunMonteCarlo(RunMonteCarloRequest) returns (RunMonteCarloResponse);

  // Streaming для долгих Monte Carlo симуляций
  rpc RunMonteCarloStream(RunMonteCarloRequest) returns (stream MonteCarloProgress);

  // ============ SENSITIVITY ANALYSIS ============

  // Анализ чувствительности
  rpc AnalyzeSensitivity(AnalyzeSensitivityRequest) returns (AnalyzeSensitivityResponse);

  // Поиск критических элементов
  rpc FindCriticalElements(FindCriticalElementsRequest) returns (FindCriticalElementsResponse);

  // ============ FAILURE SIMULATION ============

  // Симуляция отказов
  rpc SimulateFailures(SimulateFailuresRequest) returns (SimulateFailuresResponse);

  // Анализ устойчивости сети
  rpc AnalyzeResilience(AnalyzeResilienceRequest) returns (AnalyzeResilienceResponse);

  // ============ MANAGEMENT ============

  // Сохранить симуляцию
  rpc SaveSimulation(SaveSimulationRequest) returns (SaveSimulationResponse);

  // Получить симуляцию
  rpc GetSimulation(GetSimulationRequest) returns (GetSimulationResponse);

  // Список симуляций
  rpc ListSimulations(ListSimulationsRequest) returns (ListSimulationsResponse);

  // Health
  rpc Health(HealthRequest) returns (HealthResponse);
}

// ============================================================
// WHAT-IF ANALYSIS
// ============================================================

message RunWhatIfRequest {
  // Базовый граф
  logistics.common.v1.Graph baseline_graph = 1;

  // Модификации для применения
  repeated Modification modifications = 2;

  // Алгоритм для расчёта
  logistics.common.v1.Algorithm algorithm = 3;

  // Опции
  WhatIfOptions options = 4;
}

message Modification {
  ModificationType type = 1;

  // Для модификации рёбер
  logistics.common.v1.EdgeKey edge_key = 2;

  // Для модификации узлов
  int64 node_id = 3;

  // Параметры изменения
  oneof change {
    double absolute_value = 10; // Абсолютное значение
    double relative_change = 11; // Относительное изменение (1.2 = +20%)
    double delta = 12; // Добавить/вычесть значение
  }

  // Какой параметр меняем
  ModificationTarget target = 13;

  // Описание
  string description = 14;
}

enum ModificationType {
  MODIFICATION_TYPE_UNSPECIFIED = 0;
  MODIFICATION_TYPE_UPDATE_EDGE = 1; // Изменить ребро
  MODIFICATION_TYPE_REMOVE_EDGE = 2; // Удалить ребро
  MODIFICATION_TYPE_ADD_EDGE = 3; // Добавить ребро
  MODIFICATION_TYPE_UPDATE_NODE = 4; // Изменить узел
  MODIFICATION_TYPE_REMOVE_NODE = 5; // Удалить узел
  MODIFICATION_TYPE_DISABLE_NODE = 6; // Временно отключить узел
}

enum ModificationTarget {
  MODIFICATION_TARGET_UNSPECIFIED = 0;
  MODIFICATION_TARGET_CAPACITY = 1;
  MODIFICATION_TARGET_COST = 2;
  MODIFICATION_TARGET_LENGTH = 3;
  MODIFICATION_TARGET_SUPPLY = 4;
  MODIFICATION_TARGET_DEMAND = 5;
}

message WhatIfOptions {
  bool compare_with_baseline = 1;
  bool calculate_cost_impact = 2;
  bool find_new_bottlenecks = 3;
  bool return_modified_graph = 4;
}

message RunWhatIfResponse {
  bool success = 1;

  // Результаты baseline
  ScenarioResult baseline = 2;

  // Результаты после модификаций
  ScenarioResult modified = 3;

  // Сравнение
  ScenarioComparison comparison = 4;

  // Модифицированный граф
  logistics.common.v1.Graph modified_graph = 5;

  // Новые bottlenecks
  repeated BottleneckChange bottleneck_changes = 6;

  // Метаданные
  SimulationMetadata metadata = 7;
}

message ScenarioResult {
  string name = 1;
  double max_flow = 2;
  double total_cost = 3;
  double average_utilization = 4;
  int32 saturated_edges = 5;
  int32 active_paths = 6;
  logistics.common.v1.FlowStatus status = 7;
}

message ScenarioComparison {
  double flow_change = 1; // Абсолютное изменение
  double flow_change_percent = 2; // В процентах
  double cost_change = 3;
  double cost_change_percent = 4;
  double utilization_change = 5;
  string impact_summary = 6; // Текстовое описание
  ImpactLevel impact_level = 7;
}

enum ImpactLevel {
  IMPACT_LEVEL_UNSPECIFIED = 0;
  IMPACT_LEVEL_NONE = 1; // Нет влияния
  IMPACT_LEVEL_LOW = 2; // < 5%
  IMPACT_LEVEL_MEDIUM = 3; // 5-15%
  IMPACT_LEVEL_HIGH = 4; // 15-30%
  IMPACT_LEVEL_CRITICAL = 5; // > 30%
}

message BottleneckChange {
  logistics.common.v1.EdgeKey edge = 1;
  BottleneckChangeType change_type = 2;
  double old_utilization = 3;
  double new_utilization = 4;
}

enum BottleneckChangeType {
  BOTTLENECK_CHANGE_TYPE_UNSPECIFIED = 0;
  BOTTLENECK_CHANGE_TYPE_NEW = 1; // Новый bottleneck
  BOTTLENECK_CHANGE_TYPE_RESOLVED = 2; // Bottleneck устранён
  BOTTLENECK_CHANGE_TYPE_WORSENED = 3; // Ухудшился
  BOTTLENECK_CHANGE_TYPE_IMPROVED = 4; // Улучшился
}

// ============================================================
// SCENARIO COMPARISON
// ============================================================

message CompareScenariosRequest {
  logistics.common.v1.Graph baseline_graph = 1;
  repeated Scenario scenarios = 2;
  logistics.common.v1.Algorithm algorithm = 3;
  CompareOptions options = 4;
}

message Scenario {
  string name = 1;
  string description = 2;
  repeated Modification modifications = 3;
}

message CompareOptions {
  bool rank_by_flow = 1;
  bool rank_by_cost = 2;
  bool calculate_roi = 3; // Return on Investment для изменений
  double modification_cost_per_unit = 4; // Стоимость увеличения capacity на 1
}

message CompareScenariosResponse {
  ScenarioResult baseline = 1;
  repeated ScenarioResultWithRank ranked_scenarios = 2;
  string best_scenario = 3;
  string recommendation = 4;
  SimulationMetadata metadata = 5;
}

message ScenarioResultWithRank {
  ScenarioResult result = 1;
  int32 rank = 2;
  double score = 3; // Комбинированный score
  double roi = 4; // ROI если запрошено
  ScenarioComparison vs_baseline = 5;
}

// ============================================================
// TIME-DEPENDENT SIMULATION
// ============================================================

message RunTimeSimulationRequest {
  logistics.common.v1.Graph graph = 1;

  // Временные параметры
  TimeSimulationConfig time_config = 2;

  // Временные паттерны для рёбер
  repeated EdgeTimePattern edge_patterns = 3;

  // Временные паттерны для узлов (demand)
  repeated NodeTimePattern node_patterns = 4;

  logistics.common.v1.Algorithm algorithm = 5;
}

message TimeSimulationConfig {
  // Период симуляции
  google.protobuf.Timestamp start_time = 1;
  google.protobuf.Timestamp end_time = 2;

  // Шаг симуляции
  TimeStep time_step = 3;

  // Количество шагов (альтернатива end_time)
  int32 num_steps = 4;
}

enum TimeStep {
  TIME_STEP_UNSPECIFIED = 0;
  TIME_STEP_MINUTE = 1;
  TIME_STEP_HOUR = 2;
  TIME_STEP_DAY = 3;
  TIME_STEP_WEEK = 4;
}

message EdgeTimePattern {
  logistics.common.v1.EdgeKey edge = 1;
  TimePattern pattern = 2;
}

message NodeTimePattern {
  int64 node_id = 1;
  TimePattern pattern = 2;
  PatternTarget target = 3; // supply или demand
}

enum PatternTarget {
  PATTERN_TARGET_UNSPECIFIED = 0;
  PATTERN_TARGET_CAPACITY = 1;
  PATTERN_TARGET_COST = 2;
  PATTERN_TARGET_SUPPLY = 3;
  PATTERN_TARGET_DEMAND = 4;
}

message TimePattern {
  PatternType type = 1;

  // Для периодических паттернов
  repeated double hourly_multipliers = 2; // 24 значения для часов
  repeated double daily_multipliers = 3; // 7 значений для дней недели

  // Для кастомных паттернов
  repeated TimePoint custom_points = 4;

  // Для стохастических паттернов
  double mean = 5;
  double std_dev = 6;
  double min_value = 7;
  double max_value = 8;
}

enum PatternType {
  PATTERN_TYPE_UNSPECIFIED = 0;
  PATTERN_TYPE_CONSTANT = 1; // Постоянное значение
  PATTERN_TYPE_HOURLY = 2; // Почасовой паттерн
  PATTERN_TYPE_DAILY = 3; // Дневной паттерн (по дням недели)
  PATTERN_TYPE_CUSTOM = 4; // Кастомные точки
  PATTERN_TYPE_RANDOM_NORMAL = 5; // Нормальное распределение
  PATTERN_TYPE_RANDOM_UNIFORM = 6; // Равномерное распределение
}

message TimePoint {
  int32 step = 1; // Номер шага
  double multiplier = 2; // Множитель к базовому значению
}

message RunTimeSimulationResponse {
  bool success = 1;

  // Результаты по временным шагам
  repeated TimeStepResult step_results = 2;

  // Агрегированная статистика
  TimeSimulationStats stats = 3;

  // Критические периоды
  repeated CriticalPeriod critical_periods = 4;

  SimulationMetadata metadata = 5;
}

message TimeStepResult {
  int32 step = 1;
  google.protobuf.Timestamp timestamp = 2;
  double max_flow = 3;
  double total_cost = 4;
  double average_utilization = 5;
  int32 saturated_edges = 6;
  repeated logistics.common.v1.EdgeKey bottlenecks = 7;
}

message TimeSimulationStats {
  double min_flow = 1;
  double max_flow = 2;
  double avg_flow = 3;
  double std_dev_flow = 4;
  double min_cost = 5;
  double max_cost = 6;
  double avg_cost = 7;
  int32 total_steps = 8;
  int32 steps_with_bottlenecks = 9;
}

message CriticalPeriod {
  int32 start_step = 1;
  int32 end_step = 2;
  google.protobuf.Timestamp start_time = 3;
  google.protobuf.Timestamp end_time = 4;
  CriticalPeriodType type = 5;
  double severity = 6;
  string description = 7;
}

enum CriticalPeriodType {
  CRITICAL_PERIOD_TYPE_UNSPECIFIED = 0;
  CRITICAL_PERIOD_TYPE_LOW_CAPACITY = 1;
  CRITICAL_PERIOD_TYPE_HIGH_DEMAND = 2;
  CRITICAL_PERIOD_TYPE_CONGESTION = 3;
  CRITICAL_PERIOD_TYPE_FAILURE = 4;
}

// ============================================================
// PEAK LOAD SIMULATION
// ============================================================

message SimulatePeakLoadRequest {
  logistics.common.v1.Graph graph = 1;

  // Множители для пиковой нагрузки
  double demand_multiplier = 2; // 1.5 = +50% demand
  double capacity_reduction = 3; // 0.8 = -20% capacity

  // Какие узлы затрагивает пик
  repeated int64 affected_nodes = 4; // Пустой = все

  // Какие рёбра затрагивает
  repeated logistics.common.v1.EdgeKey affected_edges = 5;

  logistics.common.v1.Algorithm algorithm = 6;
}

message SimulatePeakLoadResponse {
  bool success = 1;

  ScenarioResult normal_result = 2;
  ScenarioResult peak_result = 3;
  ScenarioComparison comparison = 4;

  // Рёбра, которые не справились
  repeated OverloadedEdge overloaded_edges = 5;

  // Рекомендации
  repeated string recommendations = 6;

  SimulationMetadata metadata = 7;
}

message OverloadedEdge {
  logistics.common.v1.EdgeKey edge = 1;
  double required_capacity = 2;
  double available_capacity = 3;
  double shortage = 4;
  double shortage_percent = 5;
}

// ============================================================
// MONTE CARLO SIMULATION
// ============================================================

message RunMonteCarloRequest {
  logistics.common.v1.Graph graph = 1;

  // Конфигурация Monte Carlo
  MonteCarloConfig config = 2;

  // Неопределённости
  repeated UncertaintySpec uncertainties = 3;

  logistics.common.v1.Algorithm algorithm = 4;
}

message MonteCarloConfig {
  int32 num_iterations = 1; // Количество итераций
  int64 random_seed = 2; // Seed для воспроизводимости (0 = random)
  double confidence_level = 3; // 0.95 для 95% CI
  bool parallel = 4; // Параллельное выполнение
  int32 max_workers = 5; // Макс. воркеров
}

message UncertaintySpec {
  UncertaintyType type = 1;

  // Для edge uncertainties
  logistics.common.v1.EdgeKey edge = 2;

  // Для node uncertainties
  int64 node_id = 3;

  // Какой параметр
  ModificationTarget target = 4;

  // Распределение
  Distribution distribution = 5;
}

enum UncertaintyType {
  UNCERTAINTY_TYPE_UNSPECIFIED = 0;
  UNCERTAINTY_TYPE_EDGE = 1;
  UNCERTAINTY_TYPE_NODE = 2;
  UNCERTAINTY_TYPE_GLOBAL = 3; // Применяется ко всем
}

message Distribution {
  DistributionType type = 1;

  // Параметры распределения
  double param1 = 2; // mean для Normal, min для Uniform
  double param2 = 3; // std_dev для Normal, max для Uniform
  double param3 = 4; // Дополнительный параметр
}

enum DistributionType {
  DISTRIBUTION_TYPE_UNSPECIFIED = 0;
  DISTRIBUTION_TYPE_NORMAL = 1;
  DISTRIBUTION_TYPE_UNIFORM = 2;
  DISTRIBUTION_TYPE_TRIANGULAR = 3;
  DISTRIBUTION_TYPE_LOGNORMAL = 4;
  DISTRIBUTION_TYPE_EXPONENTIAL = 5;
}

message RunMonteCarloResponse {
  bool success = 1;

  // Статистика результатов
  MonteCarloStats flow_stats = 2;
  MonteCarloStats cost_stats = 3;

  // Распределение результатов
  repeated HistogramBucket flow_histogram = 4;
  repeated HistogramBucket cost_histogram = 5;

  // Percentiles
  map<string, double> flow_percentiles = 6; // "p5", "p25", "p50", "p75", "p95"
  map<string, double> cost_percentiles = 7;

  // Анализ рисков
  RiskAnalysis risk_analysis = 8;

  // Корреляции
  repeated ParameterCorrelation correlations = 9;

  SimulationMetadata metadata = 10;
}

message MonteCarloStats {
  double mean = 1;
  double std_dev = 2;
  double min = 3;
  double max = 4;
  double median = 5;
  double variance = 6;
  double skewness = 7;
  double kurtosis = 8;
  double confidence_interval_low = 9;
  double confidence_interval_high = 10;
}

message HistogramBucket {
  double lower_bound = 1;
  double upper_bound = 2;
  int32 count = 3;
  double frequency = 4;
}

message RiskAnalysis {
  double probability_below_threshold = 1; // P(flow < threshold)
  double value_at_risk = 2; // VaR
  double expected_shortfall = 3; // CVaR
  double worst_case_flow = 4;
  double best_case_flow = 5;
  repeated RiskScenario risk_scenarios = 6;
}

message RiskScenario {
  string description = 1;
  double probability = 2;
  double flow_impact = 3;
  double cost_impact = 4;
}

message ParameterCorrelation {
  string parameter_name = 1;
  double correlation_with_flow = 2;
  double correlation_with_cost = 3;
  double importance_score = 4;
}

message MonteCarloProgress {
  int32 iteration = 1;
  int32 total_iterations = 2;
  double progress_percent = 3;
  double current_mean_flow = 4;
  double current_std_dev = 5;
  string status = 6;
}

// ============================================================
// SENSITIVITY ANALYSIS
// ============================================================

message AnalyzeSensitivityRequest {
  logistics.common.v1.Graph graph = 1;

  // Параметры для анализа
  repeated SensitivityParameter parameters = 2;

  // Конфигурация
  SensitivityConfig config = 3;

  logistics.common.v1.Algorithm algorithm = 4;
}

message SensitivityParameter {
  // Идентификация параметра
  logistics.common.v1.EdgeKey edge = 1;
  int64 node_id = 2;
  ModificationTarget target = 3;

  // Диапазон изменения
  double min_multiplier = 4; // 0.5 = -50%
  double max_multiplier = 5; // 1.5 = +50%
  int32 num_steps = 6; // Количество точек
}

message SensitivityConfig {
  SensitivityMethod method = 1;
  bool calculate_elasticity = 2; // Эластичность
  bool find_thresholds = 3; // Пороговые значения
}

enum SensitivityMethod {
  SENSITIVITY_METHOD_UNSPECIFIED = 0;
  SENSITIVITY_METHOD_ONE_AT_A_TIME = 1; // OAT
  SENSITIVITY_METHOD_MORRIS = 2; // Morris screening
  SENSITIVITY_METHOD_SOBOL = 3; // Sobol indices (требует много итераций)
}

message AnalyzeSensitivityResponse {
  bool success = 1;

  // Результаты по параметрам
  repeated SensitivityResult parameter_results = 2;

  // Рейтинг влияния
  repeated ParameterRanking rankings = 3;

  // Найденные пороги
  repeated ThresholdPoint thresholds = 4;

  SimulationMetadata metadata = 5;
}

message SensitivityResult {
  string parameter_id = 1;

  // Кривая чувствительности
  repeated SensitivityPoint curve = 2;

  // Метрики
  double elasticity = 3; // % изменения output / % изменения input
  double sensitivity_index = 4; // Нормализованный индекс 0-1
  double impact_range = 5; // max_flow - min_flow

  SensitivityLevel level = 6;
}

message SensitivityPoint {
  double parameter_value = 1; // Множитель
  double flow_value = 2;
  double cost_value = 3;
}

enum SensitivityLevel {
  SENSITIVITY_LEVEL_UNSPECIFIED = 0;
  SENSITIVITY_LEVEL_NEGLIGIBLE = 1;
  SENSITIVITY_LEVEL_LOW = 2;
  SENSITIVITY_LEVEL_MEDIUM = 3;
  SENSITIVITY_LEVEL_HIGH = 4;
  SENSITIVITY_LEVEL_CRITICAL = 5;
}

message ParameterRanking {
  string parameter_id = 1;
  int32 rank = 2;
  double sensitivity_index = 3;
  string description = 4;
}

message ThresholdPoint {
  string parameter_id = 1;
  double threshold_value = 2;
  ThresholdType type = 3;
  string description = 4;
}

enum ThresholdType {
  THRESHOLD_TYPE_UNSPECIFIED = 0;
  THRESHOLD_TYPE_FLOW_DROPS = 1; // Поток резко падает
  THRESHOLD_TYPE_COST_SPIKES = 2; // Стоимость резко растёт
  THRESHOLD_TYPE_BOTTLENECK_APPEARS = 3;
  THRESHOLD_TYPE_INFEASIBLE = 4; // Задача становится неразрешимой
}

// ============================================================
// CRITICAL ELEMENTS
// ============================================================

message FindCriticalElementsRequest {
  logistics.common.v1.Graph graph = 1;

  CriticalElementsConfig config = 2;

  logistics.common.v1.Algorithm algorithm = 3;
}

message CriticalElementsConfig {
  bool analyze_edges = 1;
  bool analyze_nodes = 2;
  int32 top_n = 3; // Топ N критических
  double failure_threshold = 4; // Порог снижения потока для "критичности"
}

message FindCriticalElementsResponse {
  bool success = 1;

  repeated CriticalEdge critical_edges = 2;
  repeated CriticalNode critical_nodes = 3;

  // Single Point of Failure
  repeated logistics.common.v1.EdgeKey single_points_of_failure = 4;

  // Общая оценка устойчивости
  double resilience_score = 5; // 0-1

  SimulationMetadata metadata = 6;
}

message CriticalEdge {
  logistics.common.v1.EdgeKey edge = 1;
  double criticality_score = 2; // 0-1
  double flow_impact_if_removed = 3; // Снижение потока
  double cost_impact_if_removed = 4; // Увеличение стоимости
  int32 rank = 5;
  bool is_single_point_of_failure = 6;
}

message CriticalNode {
  int64 node_id = 1;
  double criticality_score = 2;
  double flow_impact_if_removed = 3;
  int32 affected_edges = 4;
  int32 rank = 5;
  bool is_single_point_of_failure = 6;
}

// ============================================================
// FAILURE SIMULATION
// ============================================================

message SimulateFailuresRequest {
  logistics.common.v1.Graph graph = 1;

  // Сценарии отказов
  repeated FailureScenario failure_scenarios = 2;

  // Или случайные отказы
  RandomFailureConfig random_config = 3;

  logistics.common.v1.Algorithm algorithm = 4;
}

message FailureScenario {
  string name = 1;
  repeated logistics.common.v1.EdgeKey failed_edges = 2;
  repeated int64 failed_nodes = 3;
  double probability = 4; // Вероятность сценария
}

message RandomFailureConfig {
  int32 num_scenarios = 1;
  double edge_failure_probability = 2; // P(edge fails)
  double node_failure_probability = 3;
  int32 max_simultaneous_failures = 4;
  bool correlated_failures = 5; // Связанные отказы
}

message SimulateFailuresResponse {
  bool success = 1;

  ScenarioResult baseline = 2;
  repeated FailureScenarioResult scenario_results = 3;

  // Агрегированная статистика
  FailureStats stats = 4;

  // Рекомендации по повышению устойчивости
  repeated ResilienceRecommendation recommendations = 5;

  SimulationMetadata metadata = 6;
}

message FailureScenarioResult {
  string scenario_name = 1;
  double probability = 2;
  ScenarioResult result = 3;
  ScenarioComparison vs_baseline = 4;
  bool network_disconnected = 5;
}

message FailureStats {
  double expected_flow_loss = 1; // E[baseline_flow - scenario_flow]
  double max_flow_loss = 2;
  double probability_of_disconnection = 3;
  double average_recovery_potential = 4;
}

message ResilienceRecommendation {
  RecommendationType type = 1;
  string description = 2;
  logistics.common.v1.EdgeKey affected_edge = 3;
  int64 affected_node = 4;
  double estimated_improvement = 5;
  double estimated_cost = 6;
}

enum RecommendationType {
  RECOMMENDATION_TYPE_UNSPECIFIED = 0;
  RECOMMENDATION_TYPE_ADD_REDUNDANCY = 1;
  RECOMMENDATION_TYPE_INCREASE_CAPACITY = 2;
  RECOMMENDATION_TYPE_ADD_BACKUP_ROUTE = 3;
  RECOMMENDATION_TYPE_RELOCATE_WAREHOUSE = 4;
}

// ============================================================
// RESILIENCE ANALYSIS
// ============================================================

message AnalyzeResilienceRequest {
  logistics.common.v1.Graph graph = 1;
  ResilienceConfig config = 2;
  logistics.common.v1.Algorithm algorithm = 3;
}

message ResilienceConfig {
  int32 max_failures_to_test = 1; // Тестировать до N отказов
  bool test_cascading_failures = 2; // Каскадные отказы
  double load_factor = 3; // Коэффициент загрузки
}

message AnalyzeResilienceResponse {
  bool success = 1;

  // Общие метрики
  ResilienceMetrics metrics = 2;

  // N-1 анализ (устойчивость к одиночным отказам)
  NMinusOneAnalysis n_minus_one = 3;

  // N-2 анализ (опционально)
  NMinusTwoAnalysis n_minus_two = 4;

  // Узкие места устойчивости
  repeated ResilienceWeakness weaknesses = 5;

  SimulationMetadata metadata = 6;
}

message ResilienceMetrics {
  double overall_score = 1; // 0-1
  double connectivity_robustness = 2; // Устойчивость связности
  double flow_robustness = 3; // Устойчивость потока
  double redundancy_level = 4; // Уровень резервирования
  int32 min_cut_size = 5; // Минимальный разрез
}

message NMinusOneAnalysis {
  bool all_scenarios_feasible = 1;
  double worst_case_flow_reduction = 2;
  logistics.common.v1.EdgeKey most_critical_edge = 3;
  int64 most_critical_node = 4;
  int32 scenarios_tested = 5;
  int32 scenarios_failed = 6;
}

message NMinusTwoAnalysis {
  bool enabled = 1;
  double probability_of_failure = 2;
  int32 critical_pairs = 3;
  repeated EdgePair critical_edge_pairs = 4;
}

message EdgePair {
  logistics.common.v1.EdgeKey edge1 = 1;
  logistics.common.v1.EdgeKey edge2 = 2;
  double combined_impact = 3;
}

message ResilienceWeakness {
  string description = 1;
  WeaknessType type = 2;
  double severity = 3;
  repeated logistics.common.v1.EdgeKey affected_edges = 4;
  repeated int64 affected_nodes = 5;
  string mitigation_suggestion = 6;
}

enum WeaknessType {
  WEAKNESS_TYPE_UNSPECIFIED = 0;
  WEAKNESS_TYPE_SINGLE_POINT_OF_FAILURE = 1;
  WEAKNESS_TYPE_CAPACITY_BOTTLENECK = 2;
  WEAKNESS_TYPE_NO_REDUNDANCY = 3;
  WEAKNESS_TYPE_GEOGRAPHIC_CONCENTRATION = 4;
}

// ============================================================
// SIMULATION MANAGEMENT
// ============================================================

message SaveSimulationRequest {
  string user_id = 1;
  string name = 2;
  string description = 3;
  SimulationType type = 4;

  // Входные данные
  logistics.common.v1.Graph graph = 5;
  bytes request_data = 6; // JSON сериализованный запрос

  // Результаты
  bytes response_data = 7; // JSON сериализованный ответ

  map<string, string> tags = 8;
}

enum SimulationType {
  SIMULATION_TYPE_UNSPECIFIED = 0;
  SIMULATION_TYPE_WHAT_IF = 1;
  SIMULATION_TYPE_TIME = 2;
  SIMULATION_TYPE_MONTE_CARLO = 3;
  SIMULATION_TYPE_SENSITIVITY = 4;
  SIMULATION_TYPE_FAILURE = 5;
  SIMULATION_TYPE_RESILIENCE = 6;
}

message SaveSimulationResponse {
  string simulation_id = 1;
  google.protobuf.Timestamp created_at = 2;
}

message GetSimulationRequest {
  string simulation_id = 1;
  string user_id = 2;
}

message GetSimulationResponse {
  SimulationRecord record = 1;
}

message ListSimulationsRequest {
  string user_id = 1;
  SimulationType type = 2;
  logistics.common.v1.PaginationRequest pagination = 3;
}

message ListSimulationsResponse {
  repeated SimulationSummary simulations = 1;
  logistics.common.v1.PaginationResponse pagination = 2;
}

message SimulationRecord {
  string id = 1;
  string user_id = 2;
  string name = 3;
  string description = 4;
  SimulationType type = 5;
  google.protobuf.Timestamp created_at = 6;
  bytes request_data = 7;
  bytes response_data = 8;
  map<string, string> tags = 9;
}

message SimulationSummary {
  string id = 1;
  string name = 2;
  SimulationType type = 3;
  google.protobuf.Timestamp created_at = 4;
  map<string, string> tags = 5;
}

// ============================================================
// COMMON
// ============================================================

message SimulationMetadata {
  string simulation_id = 1;
  double computation_time_ms = 2;
  int32 iterations = 3;
  int64 memory_used_bytes = 4;
  string algorithm_used = 5;
  google.protobuf.Timestamp completed_at = 6;
}

message HealthRequest {}

message HealthResponse {
  string status = 1;
  string version = 2;
  int64 uptime_seconds = 3;
}
