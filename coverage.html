
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">logistics/services/solver-svc/cmd/main.go (0.0%)</option>
				
				<option value="file1">logistics/services/solver-svc/factory.go (0.0%)</option>
				
				<option value="file2">logistics/services/solver-svc/internal/algorithms/bellman_ford.go (95.9%)</option>
				
				<option value="file3">logistics/services/solver-svc/internal/algorithms/capacity_scaling.go (93.4%)</option>
				
				<option value="file4">logistics/services/solver-svc/internal/algorithms/dijkstra.go (99.2%)</option>
				
				<option value="file5">logistics/services/solver-svc/internal/algorithms/dinic.go (99.3%)</option>
				
				<option value="file6">logistics/services/solver-svc/internal/algorithms/edmonds_karp.go (92.9%)</option>
				
				<option value="file7">logistics/services/solver-svc/internal/algorithms/ford_fulkenson.go (95.7%)</option>
				
				<option value="file8">logistics/services/solver-svc/internal/algorithms/min_cost_flow.go (85.0%)</option>
				
				<option value="file9">logistics/services/solver-svc/internal/algorithms/push_relabel.go (84.3%)</option>
				
				<option value="file10">logistics/services/solver-svc/internal/algorithms/solver.go (93.1%)</option>
				
				<option value="file11">logistics/services/solver-svc/internal/converter/graph.go (97.6%)</option>
				
				<option value="file12">logistics/services/solver-svc/internal/graph/bfs.go (98.9%)</option>
				
				<option value="file13">logistics/services/solver-svc/internal/graph/path.go (100.0%)</option>
				
				<option value="file14">logistics/services/solver-svc/internal/graph/pool.go (100.0%)</option>
				
				<option value="file15">logistics/services/solver-svc/internal/graph/residual.go (98.8%)</option>
				
				<option value="file16">logistics/services/solver-svc/internal/service/solver.go (80.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package main is the entry point for the solver-svc microservice.
//
// solver-svc provides network flow optimization algorithms as a gRPC service.
// It implements various max-flow and min-cost flow algorithms for logistics
// network optimization problems.
//
// # Service Overview
//
// The solver service exposes the following capabilities via gRPC:
//   - Maximum flow computation (Ford-Fulkerson, Edmonds-Karp, Dinic, Push-Relabel)
//   - Minimum cost maximum flow (Successive Shortest Path, Capacity Scaling)
//   - Algorithm recommendation based on graph characteristics
//   - Batch processing for multiple flow problems
//   - Result caching for repeated queries
//
// # Architecture
//
// The service follows a clean architecture pattern with clear separation of concerns:
//
//        ┌─────────────────────────────────────────────────────────────┐
//        │                     gRPC Transport Layer                    │
//        │  Interceptors: logging, metrics, tracing, rate-limit, audit│
//        ├─────────────────────────────────────────────────────────────┤
//        │                      Service Layer                          │
//        │  (internal/service/solver.go - SolverService)               │
//        │  - Request validation                                       │
//        │  - Caching logic                                            │
//        │  - Algorithm dispatch                                       │
//        ├─────────────────────────────────────────────────────────────┤
//        │                      Algorithm Layer                        │
//        │  (internal/algorithms/*.go)                                 │
//        │  - Ford-Fulkerson, Edmonds-Karp, Dinic                     │
//        │  - Push-Relabel (FIFO, Highest Label, Lowest Label)        │
//        │  - Min-Cost Flow (SSP, Capacity Scaling)                   │
//        │  - Bellman-Ford, Dijkstra (shortest paths)                 │
//        ├─────────────────────────────────────────────────────────────┤
//        │                       Graph Layer                           │
//        │  (internal/graph/*.go)                                      │
//        │  - ResidualGraph: core data structure                       │
//        │  - GraphPool: memory pooling                                │
//        │  - BFS, path reconstruction utilities                       │
//        ├─────────────────────────────────────────────────────────────┤
//        │                      Converter Layer                        │
//        │  (internal/converter/*.go)                                  │
//        │  - Proto ↔ internal type conversion                         │
//        │  - Result formatting                                        │
//        └─────────────────────────────────────────────────────────────┘
//
// # Configuration
//
// Configuration is loaded with the following priority (highest to lowest):
//  1. Environment variables (prefix: LOGISTICS_)
//  2. Config files (config.yaml, config/config.yaml, /etc/logistics/config.yaml)
//  3. Default values
//
// Key configuration options (environment variable format):
//
//        # Application
//        LOGISTICS_APP_NAME           - Service name (default: solver-svc)
//        LOGISTICS_APP_VERSION        - Service version (default: 1.0.0)
//        LOGISTICS_APP_ENVIRONMENT    - Environment: development, staging, production
//
//        # gRPC Server
//        LOGISTICS_GRPC_PORT              - gRPC server port (default: 50054)
//        LOGISTICS_GRPC_MAX_RECV_MSG_SIZE - Max receive message size in bytes (default: 16MB)
//        LOGISTICS_GRPC_MAX_SEND_MSG_SIZE - Max send message size in bytes (default: 16MB)
//        LOGISTICS_GRPC_MAX_CONCURRENT_CONN - Max concurrent connections (default: 1000)
//
//        # Logging
//        LOGISTICS_LOG_LEVEL    - Log level: debug, info, warn, error (default: info)
//        LOGISTICS_LOG_FORMAT   - Log format: json, text (default: json)
//        LOGISTICS_LOG_OUTPUT   - Output: stdout, stderr, file (default: stdout)
//        LOGISTICS_LOG_FILE_PATH - Log file path when output=file
//
//        # Caching
//        LOGISTICS_CACHE_ENABLED     - Enable result caching (default: false)
//        LOGISTICS_CACHE_DRIVER      - Cache backend: memory, redis (default: memory)
//        LOGISTICS_CACHE_HOST        - Redis host (default: localhost)
//        LOGISTICS_CACHE_PORT        - Redis port (default: 6379)
//        LOGISTICS_CACHE_DEFAULT_TTL - Cache TTL duration (default: 5m)
//
//        # Tracing (OpenTelemetry)
//        LOGISTICS_TRACING_ENABLED     - Enable distributed tracing (default: false)
//        LOGISTICS_TRACING_ENDPOINT    - OTLP endpoint (default: localhost:4317)
//        LOGISTICS_TRACING_SAMPLE_RATE - Sampling rate 0.0-1.0 (default: 0.1)
//
//        # Metrics (Prometheus)
//        LOGISTICS_METRICS_ENABLED   - Enable Prometheus metrics (default: true)
//        LOGISTICS_METRICS_PORT      - Metrics HTTP port (default: 9090)
//        LOGISTICS_METRICS_PATH      - Metrics endpoint path (default: /metrics)
//        LOGISTICS_METRICS_NAMESPACE - Metrics namespace (default: logistics)
//
//        # Rate Limiting
//        LOGISTICS_RATE_LIMIT_ENABLED  - Enable rate limiting (default: true)
//        LOGISTICS_RATE_LIMIT_REQUESTS - Requests per window (default: 100)
//        LOGISTICS_RATE_LIMIT_WINDOW   - Time window (default: 1m)
//        LOGISTICS_RATE_LIMIT_STRATEGY - Strategy: sliding_window, token_bucket
//
//        # Audit Logging
//        LOGISTICS_AUDIT_ENABLED      - Enable audit logging (default: true)
//        LOGISTICS_AUDIT_BACKEND      - Backend: stdout, file, grpc (default: stdout)
//        LOGISTICS_AUDIT_FILE_PATH    - Audit log file path
//        LOGISTICS_AUDIT_BUFFER_SIZE  - Buffer size for async logging (default: 1000)
//
// # Interceptor Chain
//
// The gRPC server uses a chain of interceptors (applied in order):
//  1. Recovery - Catches panics and returns proper gRPC errors
//  2. Logging - Structured request/response logging
//  3. Metrics - Prometheus metrics collection (latency, counts, errors)
//  4. Tracing - OpenTelemetry distributed tracing (if enabled)
//  5. RateLimit - Per-client rate limiting (if enabled)
//  6. Audit - Audit logging for compliance (if enabled)
//
// # Health Checks
//
// The service implements the standard gRPC health check protocol:
//
//        grpc.health.v1.Health/Check  - Returns SERVING when ready
//        grpc.health.v1.Health/Watch  - Streams health status changes
//
// Health check endpoints are automatically excluded from:
//   - Rate limiting
//   - Audit logging
//   - Request/response logging (at info level)
//
// # Graceful Shutdown
//
// The service handles SIGINT and SIGTERM signals for graceful shutdown:
//  1. Sets health status to NOT_SERVING (stops receiving new requests)
//  2. Waits for in-flight requests to complete (up to 30 seconds)
//  3. Flushes telemetry, metrics, and audit buffers
//  4. Closes rate limiter and cache connections
//  5. Stops the gRPC server
//
// # Performance Considerations
//
// The service is designed for high throughput:
//
//        Memory Management:
//          - Graph pooling via sync.Pool reduces GC pressure
//          - Pooled resources for algorithm temporary data
//          - Efficient slice and map reuse
//
//        Concurrency:
//          - Configurable max concurrent connections
//          - Non-blocking context cancellation in algorithms
//          - Batch processing support for multiple graphs
//
//        Caching:
//          - Optional result caching (memory or Redis)
//          - Cache key based on graph hash + algorithm + options
//          - Configurable TTL per result type
//
//        Algorithm Selection:
//          - Automatic algorithm recommendation based on graph characteristics
//          - Capacity Scaling for large capacity values (&gt;1e6)
//          - Push-Relabel for dense graphs
//          - Dinic for sparse graphs and bipartite matching
//
// # Observability
//
// Metrics (Prometheus):
//
//        logistics_solver_requests_total          - Total requests by method and status
//        logistics_solver_request_duration_seconds - Request latency histogram
//        logistics_solver_graph_nodes_total       - Nodes processed histogram
//        logistics_solver_graph_edges_total       - Edges processed histogram
//        logistics_solver_algorithm_usage_total   - Algorithm usage counter
//        logistics_solver_cache_hits_total        - Cache hit counter
//        logistics_solver_cache_misses_total      - Cache miss counter
//
// Tracing (OpenTelemetry):
//
//        Spans are created for:
//          - Each gRPC method invocation
//          - Graph conversion operations
//          - Algorithm execution
//          - Cache operations
//
// Logging (Structured JSON):
//
//        Each request logs:
//          - request_id: Unique identifier for correlation
//          - method: gRPC method name
//          - duration_ms: Request duration in milliseconds
//          - status: gRPC status code
//          - graph_nodes: Number of nodes (if applicable)
//          - graph_edges: Number of edges (if applicable)
//          - algorithm: Algorithm used
//          - max_flow: Result max flow value
//
// # Development Mode
//
// When LOGISTICS_APP_ENVIRONMENT=development:
//   - gRPC reflection is enabled (for grpcurl/grpcui)
//   - Debug logging is available
//   - Swagger UI is served (if enabled)
//   - More verbose error messages
//
// # Docker Deployment
//
// Build:
//
//        docker build -f Dockerfile -t solver-svc:latest .
//
// Run:
//
//        docker run -p 50054:50054 -p 9090:9090 \
//          -e LOGISTICS_LOG_LEVEL=info \
//          -e LOGISTICS_CACHE_ENABLED=true \
//          solver-svc:latest
//
// Docker Compose:
//
//        docker-compose up solver-svc
//
// # Kubernetes Deployment
//
// The service is designed for Kubernetes deployment with:
//   - Liveness probe: gRPC health check
//   - Readiness probe: gRPC health check
//   - Resource limits: Configurable via helm values
//   - Horizontal Pod Autoscaler: Based on CPU/memory or custom metrics
//
// Example probe configuration:
//
//        livenessProbe:
//          grpc:
//            port: 50054
//          initialDelaySeconds: 5
//          periodSeconds: 10
//
//        readinessProbe:
//          grpc:
//            port: 50054
//          initialDelaySeconds: 5
//          periodSeconds: 5
//
// # Local Development
//
// With hot reload using Air:
//
//        air  # Uses .air.toml configuration
//
// Manual run:
//
//        go run cmd/main.go
//
// With custom config:
//
//        CONFIG_PATH=./config/local.yaml go run cmd/main.go
//
// # API Usage Examples
//
// Using grpcurl to solve a max-flow problem:
//
//        grpcurl -plaintext -d '{
//          "graph": {
//            "nodes": [
//              {"id": 1, "type": "NODE_TYPE_WAREHOUSE"},
//              {"id": 2, "type": "NODE_TYPE_HUB"},
//              {"id": 3, "type": "NODE_TYPE_DELIVERY_POINT"}
//            ],
//            "edges": [
//              {"from": 1, "to": 2, "capacity": 10, "cost": 1.5},
//              {"from": 2, "to": 3, "capacity": 5, "cost": 2.0}
//            ],
//            "source_id": 1,
//            "sink_id": 3
//          },
//          "algorithm": "ALGORITHM_DINIC",
//          "options": {
//            "return_paths": true,
//            "timeout_ms": 5000
//          }
//        }' localhost:50054 logistics.optimization.v1.SolverService/SolveFlow
//
// Response:
//
//        {
//          "result": {
//            "max_flow": 5.0,
//            "total_cost": 17.5,
//            "status": "FLOW_STATUS_OPTIMAL",
//            "paths": [
//              {"node_ids": [1, 2, 3], "flow": 5.0, "cost": 17.5}
//            ]
//          },
//          "metadata": {
//            "algorithm_used": "ALGORITHM_DINIC",
//            "iterations": 1,
//            "duration_ms": 0.5
//          }
//        }
//
// # Dependencies
//
// External services (optional):
//
//        Redis:
//          - For distributed caching (LOGISTICS_CACHE_DRIVER=redis)
//          - For distributed rate limiting (LOGISTICS_RATE_LIMIT_BACKEND=redis)
//
//        Jaeger/OTLP Collector:
//          - For distributed tracing (LOGISTICS_TRACING_ENABLED=true)
//
// Internal dependencies (via gRPC):
//
//        None - solver-svc is a leaf service with no downstream dependencies.
//
// # Error Handling
//
// The service returns standard gRPC status codes:
//
//        OK (0)                 - Success
//        INVALID_ARGUMENT (3)   - Invalid graph structure or parameters
//        DEADLINE_EXCEEDED (4)  - Algorithm timeout
//        NOT_FOUND (5)          - Source or sink node not in graph
//        RESOURCE_EXHAUSTED (8) - Rate limit exceeded
//        INTERNAL (13)          - Internal algorithm error
//        UNAVAILABLE (14)       - Service shutting down
//
// Error details include:
//   - Error code and message
//   - Request ID for correlation
//   - Partial results (if available)
//
// # Security Considerations
//
// The service supports:
//   - TLS encryption (LOGISTICS_GRPC_TLS_ENABLED=true)
//   - Per-client rate limiting
//   - Audit logging for compliance
//   - Input validation (graph size limits, parameter bounds)
//
// Recommended production settings:
//
//        LOGISTICS_GRPC_TLS_ENABLED=true
//        LOGISTICS_RATE_LIMIT_ENABLED=true
//        LOGISTICS_AUDIT_ENABLED=true
//        LOGISTICS_LOG_LEVEL=info
package main

import (
        "context"
        "log"
        "time"

        optimizationv1 "logistics/gen/go/logistics/optimization/v1"
        "logistics/pkg/cache"
        "logistics/pkg/config"
        "logistics/pkg/logger"
        "logistics/pkg/metrics"
        "logistics/pkg/server"
        "logistics/pkg/telemetry"
        "logistics/services/solver-svc/internal/service"
)

func main() <span class="cov0" title="0">{
        // =========================================================================
        // Configuration Loading
        // =========================================================================
        //
        // LoadWithServiceDefaults loads configuration with the following priority:
        //   1. Environment variables (LOGISTICS_* prefix)
        //   2. Config files (config.yaml in standard locations)
        //   3. Default values from pkg/config/loader.go
        //
        // The service name and default port are applied if not explicitly configured.
        // This allows sharing a common config.yaml while overriding per-service.
        cfg, err := config.LoadWithServiceDefaults("solver-svc", 50054)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to load config: %v", err)
        }</span>

        // =========================================================================
        // Logger Initialization
        // =========================================================================
        //
        // The logger is configured based on the loaded configuration.
        // Supported outputs:
        //   - stdout/stderr: Direct console output
        //   - file: File output with automatic rotation (via lumberjack)
        //
        // Log rotation settings (when output=file):
        //   - MaxSize: Maximum size in MB before rotation
        //   - MaxBackups: Number of old files to retain
        //   - MaxAge: Maximum days to retain old files
        //   - Compress: Whether to gzip rotated files
        <span class="cov0" title="0">logger.InitWithConfig(logger.Config{
                Level:      cfg.Log.Level,
                Format:     cfg.Log.Format,
                Output:     cfg.Log.Output,
                FilePath:   cfg.Log.FilePath,
                MaxSize:    cfg.Log.MaxSize,
                MaxBackups: cfg.Log.MaxBackups,
                MaxAge:     cfg.Log.MaxAge,
                Compress:   cfg.Log.Compress,
        })

        ctx := context.Background()

        // =========================================================================
        // Telemetry Initialization (OpenTelemetry)
        // =========================================================================
        //
        // When enabled, initializes the OpenTelemetry trace provider.
        // Traces are exported to the configured OTLP endpoint (e.g., Jaeger).
        //
        // The trace provider is stored in the server for proper shutdown.
        // Shutdown flushes pending spans before the process exits.
        //
        // Note: The server.Run() also initializes telemetry if not already done.
        // This early initialization allows tracing of cache and other setup.
        if cfg.Tracing.Enabled </span><span class="cov0" title="0">{
                tp, err := telemetry.Init(ctx, telemetry.Config{
                        Enabled:     cfg.Tracing.Enabled,
                        Endpoint:    cfg.Tracing.Endpoint,
                        ServiceName: cfg.App.Name,
                        Version:     cfg.App.Version,
                        Environment: cfg.App.Environment,
                        SampleRate:  cfg.Tracing.SampleRate,
                })
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Warn("Failed to init telemetry", "error", err)
                }</span> else<span class="cov0" title="0"> {
                        defer func() </span><span class="cov0" title="0">{
                                shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
                                defer cancel()
                                if err := tp.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                                        logger.Log.Warn("Failed to shutdown telemetry", "error", err)
                                }</span>
                        }()
                        <span class="cov0" title="0">logger.Log.Info("Telemetry initialized", "endpoint", cfg.Tracing.Endpoint)</span>
                }
        }

        // =========================================================================
        // Metrics Initialization (Prometheus)
        // =========================================================================
        //
        // Initializes Prometheus metrics with the configured namespace.
        // The metrics server is started separately by server.Run() on the metrics port.
        //
        // Available metrics:
        //   - grpc_server_started_total: Total gRPC requests started
        //   - grpc_server_handled_total: Total gRPC requests completed
        //   - grpc_server_handling_seconds: Request duration histogram
        //   - Custom solver metrics (defined in internal/service)
        <span class="cov0" title="0">metrics.InitMetrics(cfg.Metrics.Namespace, cfg.App.Name)

        // =========================================================================
        // Cache Initialization
        // =========================================================================
        //
        // The solver cache stores computation results to avoid redundant calculations.
        // Cache key is computed from:
        //   - Graph structure hash (nodes, edges, capacities, costs)
        //   - Algorithm type
        //   - Solver options
        //
        // Supported backends:
        //   - memory: In-process LRU cache (fast, not shared between instances)
        //   - redis: Distributed cache (shared, requires Redis server)
        //
        // Cache entries expire after DefaultTTL. The cache is optional and the
        // service continues to function if cache initialization fails.
        var solverCache *cache.SolverCache
        if cfg.Cache.Enabled </span><span class="cov0" title="0">{
                // Create cache options from configuration
                // This maps config fields to cache.Options struct
                cacheOpts := cache.FromConfig(&amp;cfg.Cache)

                // Create the base cache (memory or Redis)
                baseCache, err := cache.New(cacheOpts)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Warn("Failed to create cache, continuing without cache", "error", err)
                }</span> else<span class="cov0" title="0"> {
                        // Wrap with solver-specific cache that handles serialization
                        solverCache = cache.NewSolverCache(baseCache, cfg.Cache.DefaultTTL)
                        logger.Log.Info("Solver cache initialized",
                                "driver", cfg.Cache.Driver,
                                "ttl", cfg.Cache.DefaultTTL,
                        )
                }</span>
        }

        // =========================================================================
        // gRPC Server Creation
        // =========================================================================
        //
        // server.New creates a gRPC server with:
        //   - Keep-alive settings for long-running connections
        //   - Message size limits (default 16MB)
        //   - Concurrent stream limits
        //   - Interceptor chain (logging, metrics, tracing, rate-limit, audit)
        //   - Health check service (grpc.health.v1.Health)
        //   - Reflection service (development mode only)
        //
        // The server handles graceful shutdown on SIGINT/SIGTERM.
        <span class="cov0" title="0">srv := server.New(cfg)

        // =========================================================================
        // Service Registration
        // =========================================================================
        //
        // Create the solver service with:
        //   - Version string for metadata responses
        //   - Optional cache for result caching
        //
        // The service implements the SolverService gRPC interface defined in:
        //   proto/logistics/optimization/v1/solver.proto
        //
        // Available RPC methods:
        //   - SolveFlow: Compute max-flow or min-cost flow
        //   - GetAlgorithmInfo: Get algorithm metadata
        //   - RecommendAlgorithm: Get algorithm recommendation for a graph
        //   - BatchSolve: Solve multiple flow problems
        solverService := service.NewSolverService(cfg.App.Version, solverCache)
        optimizationv1.RegisterSolverServiceServer(srv.GetEngine(), solverService)

        // =========================================================================
        // Server Startup
        // =========================================================================
        //
        // Logs startup information for operational visibility.
        // This log entry is useful for:
        //   - Confirming successful startup
        //   - Verifying configuration
        //   - Correlating with deployment events
        logger.Info("Starting solver service",
                "port", cfg.GRPC.Port,
                "environment", cfg.App.Environment,
                "version", cfg.App.Version,
                "cache_enabled", solverCache != nil,
        )

        // =========================================================================
        // Run Server (Blocking)
        // =========================================================================
        //
        // srv.Run() performs the following:
        //   1. Starts the metrics HTTP server (if enabled)
        //   2. Starts the Swagger UI server (if enabled, development mode)
        //   3. Binds to the gRPC port
        //   4. Sets health status to SERVING
        //   5. Logs an audit event for service start
        //   6. Blocks until shutdown signal received
        //   7. Performs graceful shutdown (see waitForShutdown in server.go)
        //
        // Returns nil on clean shutdown, error if server fails to start.
        if err := srv.Run(); err != nil </span><span class="cov0" title="0">{
                logger.Fatal("server failed", "error", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// services/solver-svc/factory.go
package solversvc

import (
        optimizationv1 "logistics/gen/go/logistics/optimization/v1"
        "logistics/services/solver-svc/internal/service"
)

// NewBenchmarkServer создаёт экземпляр сервиса для внешних бенчмарков.
// Он возвращает интерфейс, скрывая внутреннюю структуру реализации.
func NewBenchmarkServer() optimizationv1.SolverServiceServer <span class="cov0" title="0">{
        // Здесь мы вызываем внутренний конструктор
        return service.NewSolverService("benchmark", nil)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package algorithms provides implementations of various network flow algorithms
// including max-flow and min-cost flow algorithms with support for context cancellation,
// deterministic execution, and performance optimizations.
package algorithms

import (
        "context"

        "logistics/services/solver-svc/internal/graph"
)

// =============================================================================
// Bellman-Ford Algorithm
// =============================================================================
//
// The Bellman-Ford algorithm computes shortest paths from a single source vertex
// to all other vertices in a weighted graph. Unlike Dijkstra's algorithm, it can
// handle graphs with negative edge weights and detect negative cycles.
//
// Time Complexity: O(V * E)
// Space Complexity: O(V)
//
// Use Cases:
//   - Finding shortest paths in graphs with negative weights
//   - Detecting negative cycles (arbitrage detection, etc.)
//   - Initializing potentials for successive shortest path algorithms
//
// Algorithm:
//   1. Initialize distances: dist[source] = 0, dist[v] = ∞ for all v ≠ source
//   2. Repeat V-1 times: relax all edges
//   3. Check for negative cycles by attempting one more relaxation
//
// References:
//   - Bellman, R. (1958). "On a routing problem"
//   - Ford, L.R. (1956). "Network Flow Theory"
// =============================================================================

// BellmanFordResult contains the result of the Bellman-Ford algorithm.
// It provides shortest path distances, parent pointers for path reconstruction,
// and information about negative cycles and cancellation status.
type BellmanFordResult struct {
        // Distances maps each node to its shortest distance from the source.
        // Unreachable nodes have distance equal to graph.Infinity.
        Distances map[int64]float64

        // Parent maps each node to its predecessor on the shortest path.
        // The source node and unreachable nodes have parent = -1.
        Parent map[int64]int64

        // HasNegativeCycle indicates whether a negative-weight cycle was detected.
        // If true, the distances may not be valid.
        HasNegativeCycle bool

        // Canceled indicates whether the operation was canceled via context.
        Canceled bool
}

// GetDistances implements the ShortestPathResult interface.
// Returns the map of shortest distances from the source to all nodes.
func (r *BellmanFordResult) GetDistances() map[int64]float64 <span class="cov8" title="1">{
        return r.Distances
}</span>

// GetParent implements the ShortestPathResult interface.
// Returns the map of parent pointers for path reconstruction.
func (r *BellmanFordResult) GetParent() map[int64]int64 <span class="cov8" title="1">{
        return r.Parent
}</span>

// BellmanFord executes the Bellman-Ford algorithm without context cancellation support.
// This is a convenience wrapper around BellmanFordWithContext using context.Background().
//
// Parameters:
//   - g: The residual graph to search
//   - source: The source node ID
//
// Returns:
//   - *BellmanFordResult containing distances, parents, and cycle detection result
func BellmanFord(g *graph.ResidualGraph, source int64) *BellmanFordResult <span class="cov8" title="1">{
        return BellmanFordWithContext(context.Background(), g, source)
}</span>

// BellmanFordWithContext executes the Bellman-Ford algorithm with context cancellation.
// The algorithm processes nodes and edges in a deterministic order to ensure
// reproducible results across multiple runs.
//
// Parameters:
//   - ctx: Context for cancellation support
//   - g: The residual graph to search
//   - source: The source node ID
//
// Returns:
//   - *BellmanFordResult containing distances, parents, cycle info, and cancellation status
//
// Context Cancellation:
//
//        The algorithm checks for cancellation every 100 iterations.
//        If canceled, returns partial results with Canceled = true.
func BellmanFordWithContext(ctx context.Context, g *graph.ResidualGraph, source int64) *BellmanFordResult <span class="cov8" title="1">{
        // Get sorted nodes for deterministic iteration order
        nodes := g.GetSortedNodes()
        n := len(nodes)

        // Initialize distance and parent maps
        dist := make(map[int64]float64, n)
        parent := make(map[int64]int64, n)

        for _, node := range nodes </span><span class="cov8" title="1">{
                dist[node] = graph.Infinity
                parent[node] = -1
        }</span>
        <span class="cov8" title="1">dist[source] = 0

        // Context check interval - balance between responsiveness and performance
        const checkInterval = 100

        // Main loop: relax all edges V-1 times
        for i := 0; i &lt; n-1; i++ </span><span class="cov8" title="1">{
                // Periodic context check
                if i%checkInterval == 0 </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov8" title="1">
                                return &amp;BellmanFordResult{
                                        Distances:        dist,
                                        Parent:           parent,
                                        HasNegativeCycle: false,
                                        Canceled:         true,
                                }</span>
                        default:<span class="cov8" title="1"></span>
                        }
                }

                // Early termination if no updates occurred
                <span class="cov8" title="1">updated := relaxAllEdgesDeterministic(g, nodes, dist, parent)
                if !updated </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        // Check for negative cycles by attempting one more relaxation
        <span class="cov8" title="1">hasNegativeCycle := checkNegativeCycleDeterministic(g, nodes, dist)

        return &amp;BellmanFordResult{
                Distances:        dist,
                Parent:           parent,
                HasNegativeCycle: hasNegativeCycle,
                Canceled:         false,
        }</span>
}

// BellmanFordWithPotentials executes Bellman-Ford using reduced costs based on potentials.
// This is used in successive shortest path algorithms where potentials are maintained
// to ensure non-negative reduced costs for Dijkstra's algorithm.
//
// The reduced cost of an edge (u, v) is: cost(u,v) + potential[u] - potential[v]
//
// Parameters:
//   - g: The residual graph
//   - source: The source node ID
//   - potentials: Map of node potentials (typically from previous shortest path computation)
//
// Returns:
//   - *BellmanFordResult with distances based on reduced costs
func BellmanFordWithPotentials(g *graph.ResidualGraph, source int64, potentials map[int64]float64) *BellmanFordResult <span class="cov8" title="1">{
        return BellmanFordWithPotentialsContext(context.Background(), g, source, potentials)
}</span>

// BellmanFordWithPotentialsContext is the context-aware version of BellmanFordWithPotentials.
func BellmanFordWithPotentialsContext(ctx context.Context, g *graph.ResidualGraph, source int64, potentials map[int64]float64) *BellmanFordResult <span class="cov8" title="1">{
        nodes := g.GetSortedNodes()
        n := len(nodes)

        dist := make(map[int64]float64, n)
        parent := make(map[int64]int64, n)

        for _, node := range nodes </span><span class="cov8" title="1">{
                dist[node] = graph.Infinity
                parent[node] = -1
        }</span>
        <span class="cov8" title="1">dist[source] = 0

        const checkInterval = 100

        for i := 0; i &lt; n-1; i++ </span><span class="cov8" title="1">{
                if i%checkInterval == 0 </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov8" title="1">
                                return &amp;BellmanFordResult{
                                        Distances:        dist,
                                        Parent:           parent,
                                        HasNegativeCycle: false,
                                        Canceled:         true,
                                }</span>
                        default:<span class="cov8" title="1"></span>
                        }
                }

                <span class="cov8" title="1">updated := false

                // Iterate over nodes in deterministic order
                for _, u := range nodes </span><span class="cov8" title="1">{
                        if dist[u] &gt;= graph.Infinity-graph.Epsilon </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Use EdgesList for deterministic edge order
                        <span class="cov8" title="1">edges := g.GetNeighborsList(u)
                        for _, edge := range edges </span><span class="cov8" title="1">{
                                if edge.Capacity &gt; graph.Epsilon </span><span class="cov8" title="1">{
                                        v := edge.To

                                        // Compute reduced cost using potentials
                                        reducedCost := edge.Cost + potentials[u] - potentials[v]
                                        newDist := dist[u] + reducedCost

                                        if newDist &lt; dist[v]-graph.Epsilon </span><span class="cov8" title="1">{
                                                dist[v] = newDist
                                                parent[v] = u
                                                updated = true
                                        }</span>
                                }
                        }
                }

                <span class="cov8" title="1">if !updated </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">hasNegativeCycle := checkNegativeCycleWithPotentialsDeterministic(g, nodes, dist, potentials)

        return &amp;BellmanFordResult{
                Distances:        dist,
                Parent:           parent,
                HasNegativeCycle: hasNegativeCycle,
                Canceled:         false,
        }</span>
}

// BellmanFordToSink is an optimized version that terminates early when the sink
// distance becomes stable. This is useful when only the source-to-sink shortest
// path is needed and we want to avoid unnecessary iterations.
//
// Early Termination Conditions:
//  1. No updates occurred in an iteration (standard early exit)
//  2. Sink distance hasn't improved for several consecutive iterations
//
// The stability check helps avoid running all V-1 iterations when the sink
// is reached early and its distance won't change further.
//
// Parameters:
//   - ctx: Context for cancellation
//   - g: The residual graph
//   - source: The source node ID
//   - sink: The target node ID
//
// Returns:
//   - *BellmanFordResult with early termination optimization
func BellmanFordToSink(ctx context.Context, g *graph.ResidualGraph, source, sink int64) *BellmanFordResult <span class="cov8" title="1">{
        nodes := g.GetSortedNodes()
        n := len(nodes)

        dist := make(map[int64]float64, n)
        parent := make(map[int64]int64, n)

        for _, node := range nodes </span><span class="cov8" title="1">{
                dist[node] = graph.Infinity
                parent[node] = -1
        }</span>
        <span class="cov8" title="1">dist[source] = 0

        const checkInterval = 100
        sinkStableIterations := 0    // Count of iterations where sink distance didn't improve
        const stabilityThreshold = 2 // Exit after this many stable iterations

        for i := 0; i &lt; n-1; i++ </span><span class="cov8" title="1">{
                if i%checkInterval == 0 </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov8" title="1">
                                return &amp;BellmanFordResult{
                                        Distances:        dist,
                                        Parent:           parent,
                                        HasNegativeCycle: false,
                                        Canceled:         true,
                                }</span>
                        default:<span class="cov8" title="1"></span>
                        }
                }

                <span class="cov8" title="1">prevSinkDist := dist[sink]
                updated := relaxAllEdgesDeterministic(g, nodes, dist, parent)

                // Standard early termination: no updates means we're done
                if !updated </span><span class="cov8" title="1">{
                        break</span>
                }

                // Check sink distance stability for early exit
                <span class="cov8" title="1">if dist[sink] &lt; graph.Infinity-graph.Epsilon </span><span class="cov8" title="1">{
                        // Sink is reachable, check if distance improved
                        if dist[sink] &gt;= prevSinkDist-graph.Epsilon </span><span class="cov0" title="0">{
                                // Distance didn't improve
                                sinkStableIterations++
                                if sinkStableIterations &gt;= stabilityThreshold </span><span class="cov0" title="0">{
                                        // Sink distance is stable, no need to continue
                                        // (but we still need to check for negative cycles)
                                        break</span>
                                }
                        } else<span class="cov8" title="1"> {
                                // Distance improved, reset counter
                                sinkStableIterations = 0
                        }</span>
                }
        }

        <span class="cov8" title="1">hasNegativeCycle := checkNegativeCycleDeterministic(g, nodes, dist)

        return &amp;BellmanFordResult{
                Distances:        dist,
                Parent:           parent,
                HasNegativeCycle: hasNegativeCycle,
                Canceled:         false,
        }</span>
}

// relaxAllEdgesDeterministic performs one iteration of edge relaxation in deterministic order.
// Returns true if any distance was updated, false otherwise.
func relaxAllEdgesDeterministic(g *graph.ResidualGraph, nodes []int64, dist map[int64]float64, parent map[int64]int64) bool <span class="cov8" title="1">{
        updated := false

        for _, u := range nodes </span><span class="cov8" title="1">{
                // Skip unreachable nodes
                if dist[u] &gt;= graph.Infinity-graph.Epsilon </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Use EdgesList for deterministic edge ordering
                <span class="cov8" title="1">edges := g.GetNeighborsList(u)
                for _, edge := range edges </span><span class="cov8" title="1">{
                        // Only consider edges with positive residual capacity
                        if edge.Capacity &gt; graph.Epsilon </span><span class="cov8" title="1">{
                                v := edge.To
                                newDist := dist[u] + edge.Cost

                                // Relaxation: update if we found a shorter path
                                if newDist &lt; dist[v]-graph.Epsilon </span><span class="cov8" title="1">{
                                        dist[v] = newDist
                                        parent[v] = u
                                        updated = true
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return updated</span>
}

// checkNegativeCycleDeterministic checks for negative-weight cycles.
// A negative cycle exists if we can still relax any edge after V-1 iterations.
func checkNegativeCycleDeterministic(g *graph.ResidualGraph, nodes []int64, dist map[int64]float64) bool <span class="cov8" title="1">{
        for _, u := range nodes </span><span class="cov8" title="1">{
                if dist[u] &gt;= graph.Infinity-graph.Epsilon </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">edges := g.GetNeighborsList(u)
                for _, edge := range edges </span><span class="cov8" title="1">{
                        if edge.Capacity &gt; graph.Epsilon </span><span class="cov8" title="1">{
                                v := edge.To
                                if dist[u]+edge.Cost &lt; dist[v]-graph.Epsilon </span><span class="cov8" title="1">{
                                        return true
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return false</span>
}

// checkNegativeCycleWithPotentialsDeterministic checks for negative cycles using reduced costs.
func checkNegativeCycleWithPotentialsDeterministic(g *graph.ResidualGraph, nodes []int64, dist map[int64]float64, potentials map[int64]float64) bool <span class="cov8" title="1">{
        for _, u := range nodes </span><span class="cov8" title="1">{
                if dist[u] &gt;= graph.Infinity-graph.Epsilon </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">edges := g.GetNeighborsList(u)
                for _, edge := range edges </span><span class="cov8" title="1">{
                        if edge.Capacity &gt; graph.Epsilon </span><span class="cov8" title="1">{
                                v := edge.To
                                reducedCost := edge.Cost + potentials[u] - potentials[v]
                                if dist[u]+reducedCost &lt; dist[v]-graph.Epsilon </span><span class="cov8" title="1">{
                                        return true
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return false</span>
}

// FindShortestPath finds the shortest path from source to sink using Bellman-Ford.
// Returns the path as a slice of node IDs, the total cost, and a success flag.
//
// Parameters:
//   - g: The residual graph
//   - source: The source node ID
//   - sink: The target node ID
//
// Returns:
//   - path: Slice of node IDs from source to sink (empty if no path exists)
//   - cost: Total cost of the path
//   - found: True if a path was found without negative cycles
func FindShortestPath(g *graph.ResidualGraph, source, sink int64) ([]int64, float64, bool) <span class="cov8" title="1">{
        result := BellmanFord(g, source)

        if result.HasNegativeCycle </span><span class="cov8" title="1">{
                return nil, 0, false
        }</span>

        <span class="cov8" title="1">if result.Distances[sink] &gt;= graph.Infinity-graph.Epsilon </span><span class="cov8" title="1">{
                return nil, 0, false
        }</span>

        <span class="cov8" title="1">path := graph.ReconstructPath(result.Parent, source, sink)
        return path, result.Distances[sink], len(path) &gt; 0</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package algorithms provides implementations of various network flow algorithms.
//
// This file implements the Capacity Scaling algorithm for Min-Cost Max-Flow problems.
// Capacity Scaling is particularly efficient for graphs with large capacity values,
// achieving O(E² log U) complexity where U is the maximum edge capacity.
//
// The algorithm works in phases, starting with a large scaling factor (delta) and
// progressively halving it. In each phase, only edges with capacity &gt;= delta are
// considered, which significantly reduces the number of augmenting paths needed.
//
// Reference: Ahuja, R.K., Magnanti, T.L., and Orlin, J.B. "Network Flows: Theory,
// Algorithms, and Applications" (1993), Chapter 10.
package algorithms

import (
        "container/heap"
        "context"
        "math"

        "logistics/services/solver-svc/internal/converter"
        "logistics/services/solver-svc/internal/graph"
)

// CapacityScalingThreshold defines the minimum max-capacity value for which
// Capacity Scaling algorithm should be preferred over Successive Shortest Path.
// For graphs with max capacity below this threshold, SSP is typically faster.
const CapacityScalingThreshold = 1e6

// =============================================================================
// Capacity Scaling Min-Cost Flow Algorithm
// =============================================================================

// CapacityScalingMinCostFlow implements the Capacity Scaling algorithm for
// finding minimum cost maximum flow.
//
// Algorithm Overview:
//  1. Find the maximum capacity U in the graph
//  2. Initialize delta = largest power of 2 &lt;= U
//  3. Initialize node potentials using Bellman-Ford from source
//  4. For each scaling phase (while delta &gt;= 1):
//     a. Find shortest paths only considering edges with capacity &gt;= delta
//     b. Augment flow along these paths
//     c. Halve delta and repeat
//  5. Finish with standard SSP for remaining fractional flow
//
// Time Complexity: O(E² log U) where U = max capacity
// Space Complexity: O(V + E)
//
// Parameters:
//   - g: The residual graph to find flow in
//   - source: Source node ID
//   - sink: Sink node ID
//   - requiredFlow: Maximum amount of flow to push (use math.MaxFloat64 for max flow)
//   - options: Solver configuration options
//
// Returns:
//   - MinCostFlowResult containing flow value, cost, paths, and status
//
// Example:
//
//        g := graph.NewResidualGraph()
//        g.AddEdgeWithReverse(1, 2, 1000000, 1.0)  // Large capacity
//        g.AddEdgeWithReverse(2, 3, 1000000, 2.0)
//        result := CapacityScalingMinCostFlow(g, 1, 3, math.MaxFloat64, nil)
//        fmt.Printf("Flow: %f, Cost: %f\n", result.Flow, result.Cost)
func CapacityScalingMinCostFlow(g *graph.ResidualGraph, source, sink int64, requiredFlow float64, options *SolverOptions) *MinCostFlowResult <span class="cov8" title="1">{
        return CapacityScalingMinCostFlowWithContext(context.Background(), g, source, sink, requiredFlow, options)
}</span>

// CapacityScalingMinCostFlowWithContext is the context-aware version of
// CapacityScalingMinCostFlow that supports cancellation and timeouts.
//
// The context is checked periodically during execution. If cancelled,
// the function returns immediately with partial results and Canceled=true.
//
// Parameters:
//   - ctx: Context for cancellation/timeout control
//   - g: The residual graph
//   - source: Source node ID
//   - sink: Sink node ID
//   - requiredFlow: Maximum flow to push
//   - options: Solver options (nil uses defaults)
//
// Returns:
//   - MinCostFlowResult with partial results if cancelled
func CapacityScalingMinCostFlowWithContext(ctx context.Context, g *graph.ResidualGraph, source, sink int64, requiredFlow float64, options *SolverOptions) *MinCostFlowResult <span class="cov8" title="1">{
        if options == nil </span><span class="cov8" title="1">{
                options = DefaultSolverOptions()
        }</span>

        // Find maximum capacity in the graph to determine initial delta
        <span class="cov8" title="1">maxCap := findMaxCapacity(g)
        if maxCap &lt;= options.Epsilon </span><span class="cov8" title="1">{
                return &amp;MinCostFlowResult{}
        }</span>

        // Initialize delta as the largest power of 2 not exceeding maxCap
        // This ensures we start with the coarsest granularity
        <span class="cov8" title="1">delta := computeInitialDelta(maxCap)

        // Initialize node potentials using Bellman-Ford
        // Potentials are used to transform edge costs to non-negative reduced costs,
        // enabling the use of Dijkstra's algorithm in subsequent iterations
        potentials := initializePotentials(ctx, g, source)
        if potentials == nil </span><span class="cov8" title="1">{
                return &amp;MinCostFlowResult{
                        Canceled: ctx.Err() != nil,
                }
        }</span>

        <span class="cov8" title="1">totalFlow := 0.0
        totalCost := 0.0
        iterations := 0
        var paths []converter.PathWithFlow

        // Frequency of context cancellation checks
        checkInterval := 20

        // Main scaling loop: process phases with decreasing delta
        for delta &gt;= 1.0 &amp;&amp; totalFlow &lt; requiredFlow-options.Epsilon </span><span class="cov8" title="1">{
                // Check for context cancellation between phases
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return &amp;MinCostFlowResult{
                                Flow:       totalFlow,
                                Cost:       totalCost,
                                Iterations: iterations,
                                Paths:      paths,
                                Canceled:   true,
                        }</span>
                default:<span class="cov8" title="1"></span>
                }

                // Process current delta phase
                <span class="cov8" title="1">phaseResult := processScalingPhase(ctx, g, source, sink, requiredFlow-totalFlow,
                        delta, potentials, options, iterations, checkInterval)

                totalFlow += phaseResult.flow
                totalCost += phaseResult.cost
                iterations += phaseResult.iterations
                paths = append(paths, phaseResult.paths...)

                if phaseResult.canceled </span><span class="cov8" title="1">{
                        return &amp;MinCostFlowResult{
                                Flow:       totalFlow,
                                Cost:       totalCost,
                                Iterations: iterations,
                                Paths:      paths,
                                Canceled:   true,
                        }
                }</span>

                // Halve delta for the next phase
                <span class="cov8" title="1">delta /= 2</span>
        }

        // Final pass: use standard SSP for any remaining flow (handles delta &lt; 1)
        <span class="cov8" title="1">if totalFlow &lt; requiredFlow-options.Epsilon </span><span class="cov8" title="1">{
                finalResult := finishWithSSP(ctx, g, source, sink, requiredFlow-totalFlow, potentials, options)
                if finalResult.Canceled </span><span class="cov0" title="0">{
                        return &amp;MinCostFlowResult{
                                Flow:       totalFlow,
                                Cost:       totalCost,
                                Iterations: iterations,
                                Paths:      paths,
                                Canceled:   true,
                        }
                }</span>

                <span class="cov8" title="1">totalFlow += finalResult.Flow
                totalCost += finalResult.Cost
                iterations += finalResult.Iterations
                paths = append(paths, finalResult.Paths...)</span>
        }

        <span class="cov8" title="1">return &amp;MinCostFlowResult{
                Flow:       totalFlow,
                Cost:       totalCost,
                Iterations: iterations,
                Paths:      paths,
                Canceled:   false,
        }</span>
}

// =============================================================================
// Phase Processing
// =============================================================================

// phaseResult holds the results from processing a single scaling phase.
type phaseResult struct {
        flow       float64
        cost       float64
        iterations int
        paths      []converter.PathWithFlow
        canceled   bool
}

// processScalingPhase processes a single delta-phase of the capacity scaling algorithm.
// It repeatedly finds shortest paths in the delta-network and augments flow until
// no more augmenting paths exist in the current delta-network.
//
// Parameters:
//   - ctx: Context for cancellation
//   - g: Residual graph
//   - source, sink: Source and sink node IDs
//   - remainingFlow: Maximum additional flow to push in this phase
//   - delta: Current scaling factor
//   - potentials: Node potentials for reduced cost computation
//   - options: Solver options
//   - startIterations: Initial iteration count (for MaxIterations check)
//   - checkInterval: How often to check context cancellation
//
// Returns:
//   - phaseResult containing flow pushed, cost incurred, and paths found
func processScalingPhase(
        ctx context.Context,
        g *graph.ResidualGraph,
        source, sink int64,
        remainingFlow, delta float64,
        potentials map[int64]float64,
        options *SolverOptions,
        startIterations, checkInterval int,
) phaseResult <span class="cov8" title="1">{
        result := phaseResult{}
        iterations := 0

        // Safety limit to prevent infinite loops in case of numerical issues
        maxPhaseIterations := len(g.Nodes) * len(g.Nodes)

        for result.flow &lt; remainingFlow-options.Epsilon &amp;&amp; iterations &lt; maxPhaseIterations </span><span class="cov8" title="1">{
                // Check iteration limit
                if options.MaxIterations &gt; 0 &amp;&amp; startIterations+iterations &gt;= options.MaxIterations </span><span class="cov8" title="1">{
                        break</span>
                }

                // Periodically check for context cancellation
                <span class="cov8" title="1">if iterations%checkInterval == 0 </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                result.canceled = true
                                result.iterations = iterations
                                return result</span>
                        default:<span class="cov8" title="1"></span>
                        }
                }

                // Find shortest path considering only edges with capacity &gt;= delta
                <span class="cov8" title="1">spResult := dijkstraWithDeltaNetwork(ctx, g, source, sink, potentials, delta, options.Epsilon)
                if spResult.Canceled </span><span class="cov8" title="1">{
                        result.canceled = true
                        result.iterations = iterations
                        return result
                }</span>

                // No path found in delta-network - phase complete
                <span class="cov8" title="1">if spResult.Distances[sink] &gt;= graph.Infinity-options.Epsilon </span><span class="cov8" title="1">{
                        break</span>
                }

                // Update potentials based on shortest path distances
                <span class="cov8" title="1">updatePotentials(g, potentials, spResult.Distances)

                // Reconstruct the shortest path
                path := graph.ReconstructPath(spResult.Parent, source, sink)
                if len(path) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                // Find the bottleneck capacity along the path
                <span class="cov8" title="1">pathFlow := findPathFlowWithDelta(g, path, remainingFlow-result.flow, delta, options.Epsilon)
                if pathFlow &lt;= options.Epsilon </span><span class="cov0" title="0">{
                        break</span>
                }

                // Augment flow along the path and compute cost
                <span class="cov8" title="1">pathCost := augmentPathWithCost(g, path, pathFlow)

                result.flow += pathFlow
                result.cost += pathCost
                iterations++

                // Record path if requested
                if options.ReturnPaths </span><span class="cov8" title="1">{
                        result.paths = append(result.paths, converter.PathWithFlow{
                                NodeIDs: copyPath(path),
                                Flow:    pathFlow,
                        })
                }</span>
        }

        <span class="cov8" title="1">result.iterations = iterations
        return result</span>
}

// =============================================================================
// Helper Functions for Capacity Scaling
// =============================================================================

// computeInitialDelta computes the initial delta value as the largest power of 2
// that does not exceed maxCap. This provides optimal scaling behavior.
//
// Example: maxCap = 1000 -&gt; delta = 512 (2^9)
func computeInitialDelta(maxCap float64) float64 <span class="cov8" title="1">{
        if maxCap &lt;= 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">delta := 1.0
        for delta*2 &lt;= maxCap </span><span class="cov8" title="1">{
                delta *= 2
        }</span>
        <span class="cov8" title="1">return delta</span>
}

// initializePotentials computes initial node potentials using the Bellman-Ford
// algorithm. Potentials represent shortest path distances from source and are
// used to compute reduced costs: reducedCost(u,v) = cost(u,v) + π(u) - π(v).
//
// With proper potentials, all reduced costs are non-negative on shortest paths,
// enabling the use of Dijkstra's algorithm instead of Bellman-Ford in subsequent
// iterations.
//
// Returns nil if the context is cancelled during computation.
func initializePotentials(ctx context.Context, g *graph.ResidualGraph, source int64) map[int64]float64 <span class="cov8" title="1">{
        initResult := BellmanFordWithContext(ctx, g, source)
        if initResult.Canceled </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if initResult.HasNegativeCycle </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">potentials := make(map[int64]float64, len(g.Nodes))
        for node := range g.Nodes </span><span class="cov8" title="1">{
                potentials[node] = 0
        }</span>

        <span class="cov8" title="1">for node, dist := range initResult.Distances </span><span class="cov8" title="1">{
                if dist &lt; graph.Infinity-graph.Epsilon </span><span class="cov8" title="1">{
                        potentials[node] = dist
                }</span>
        }

        <span class="cov8" title="1">return potentials</span>
}

// updatePotentials updates the potential function after finding shortest paths.
// This maintains the property that reduced costs remain non-negative.
//
// The update rule is: π'(v) = π(v) + d(v) for all reachable vertices v,
// where d(v) is the shortest path distance computed with reduced costs.
func updatePotentials(g *graph.ResidualGraph, potentials map[int64]float64, distances map[int64]float64) <span class="cov8" title="1">{
        for node := range g.Nodes </span><span class="cov8" title="1">{
                if distances[node] &lt; graph.Infinity-graph.Epsilon </span><span class="cov8" title="1">{
                        potentials[node] += distances[node]
                }</span>
        }
}

// dijkstraWithDeltaNetwork runs Dijkstra's algorithm on the delta-restricted network.
// Only edges with residual capacity &gt;= delta are considered during the search.
//
// The algorithm uses reduced costs: reducedCost(u,v) = cost(u,v) + π(u) - π(v).
// With proper potentials, reduced costs are non-negative, making Dijkstra valid.
//
// Parameters:
//   - ctx: Context for cancellation
//   - g: Residual graph
//   - source, sink: Source and sink node IDs
//   - potentials: Node potential function
//   - delta: Minimum edge capacity to consider
//   - epsilon: Numerical tolerance
//
// Returns:
//   - DijkstraResult with distances and parent pointers
func dijkstraWithDeltaNetwork(
        ctx context.Context,
        g *graph.ResidualGraph,
        source, sink int64,
        potentials map[int64]float64,
        delta, epsilon float64,
) *DijkstraResult <span class="cov8" title="1">{
        // Use sorted nodes for deterministic behavior
        nodes := g.GetSortedNodes()

        dist := make(map[int64]float64, len(nodes))
        parent := make(map[int64]int64, len(nodes))

        // Initialize distances to infinity
        for _, node := range nodes </span><span class="cov8" title="1">{
                dist[node] = graph.Infinity
                parent[node] = -1
        }</span>
        <span class="cov8" title="1">dist[source] = 0

        // Priority queue for Dijkstra
        pq := make(dijkstraPQ, 0, len(nodes))
        heap.Init(&amp;pq)
        heap.Push(&amp;pq, &amp;dijkstraPQItem{node: source, distance: 0})

        checkInterval := 100
        iterations := 0

        for pq.Len() &gt; 0 </span><span class="cov8" title="1">{
                // Periodic cancellation check
                if iterations%checkInterval == 0 </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov8" title="1">
                                return &amp;DijkstraResult{Distances: dist, Parent: parent, Canceled: true}</span>
                        default:<span class="cov8" title="1"></span>
                        }
                }
                <span class="cov8" title="1">iterations++

                // Extract minimum distance node
                current := heap.Pop(&amp;pq).(*dijkstraPQItem)
                u := current.node

                // Skip stale entries
                if current.distance &gt; dist[u]+epsilon </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Early termination if sink is reached
                <span class="cov8" title="1">if u == sink </span><span class="cov8" title="1">{
                        break</span>
                }

                // Explore neighbors in deterministic order via EdgesList
                <span class="cov8" title="1">neighbors := g.GetNeighborsList(u)
                for _, edge := range neighbors </span><span class="cov8" title="1">{
                        // Skip edges with capacity below delta threshold
                        if edge.Capacity &lt; delta-epsilon </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">v := edge.To

                        // Compute reduced cost using potentials
                        reducedCost := edge.Cost + potentials[u] - potentials[v]

                        // Clamp small negative values caused by numerical errors
                        if reducedCost &lt; 0 </span><span class="cov8" title="1">{
                                reducedCost = 0
                        }</span>

                        <span class="cov8" title="1">newDist := dist[u] + reducedCost
                        if newDist &lt; dist[v]-epsilon </span><span class="cov8" title="1">{
                                dist[v] = newDist
                                parent[v] = u
                                heap.Push(&amp;pq, &amp;dijkstraPQItem{node: v, distance: newDist})
                        }</span>
                }
        }

        <span class="cov8" title="1">return &amp;DijkstraResult{Distances: dist, Parent: parent, Canceled: false}</span>
}

// findPathFlowWithDelta computes the flow amount to push along a path.
// The flow is the minimum of:
//   - The remaining required flow
//   - The minimum edge capacity along the path
//   - Optionally rounded down to a multiple of delta (for integer scaling)
//
// Parameters:
//   - g: Residual graph
//   - path: Sequence of node IDs from source to sink
//   - remainingFlow: Maximum additional flow allowed
//   - delta: Current scaling factor (for rounding)
//   - epsilon: Numerical tolerance
//
// Returns:
//   - Flow amount to push (may be 0 if path is invalid)
func findPathFlowWithDelta(g *graph.ResidualGraph, path []int64, remainingFlow, delta, epsilon float64) float64 <span class="cov8" title="1">{
        pathFlow := remainingFlow

        // Find bottleneck capacity
        for i := 0; i &lt; len(path)-1; i++ </span><span class="cov8" title="1">{
                edge := g.GetEdge(path[i], path[i+1])
                if edge == nil </span><span class="cov0" title="0">{
                        return 0
                }</span>
                <span class="cov8" title="1">if edge.Capacity &lt; pathFlow </span><span class="cov8" title="1">{
                        pathFlow = edge.Capacity
                }</span>
        }

        // Round down to multiple of delta for integer capacity graphs
        // This maintains the scaling property and avoids fractional flows in early phases
        // NOTE: Do not add epsilon before floor - this caused incorrect rounding up
        <span class="cov8" title="1">if delta &gt;= 1.0 &amp;&amp; pathFlow &gt;= delta </span><span class="cov8" title="1">{
                pathFlow = math.Floor(pathFlow/delta) * delta
        }</span>

        <span class="cov8" title="1">return pathFlow</span>
}

// augmentPathWithCost pushes flow along a path and returns the total cost incurred.
// Updates the residual graph by decreasing forward edge capacities and increasing
// backward edge capacities.
//
// Parameters:
//   - g: Residual graph (modified in place)
//   - path: Path from source to sink
//   - flow: Amount of flow to push
//
// Returns:
//   - Total cost of pushing this flow (sum of edge costs * flow)
func augmentPathWithCost(g *graph.ResidualGraph, path []int64, flow float64) float64 <span class="cov8" title="1">{
        pathCost := 0.0
        for i := 0; i &lt; len(path)-1; i++ </span><span class="cov8" title="1">{
                edge := g.GetEdge(path[i], path[i+1])
                if edge != nil </span><span class="cov8" title="1">{
                        pathCost += edge.Cost * flow
                }</span>
        }
        <span class="cov8" title="1">graph.AugmentPath(g, path, flow)
        return pathCost</span>
}

// finishWithSSP completes the flow computation using standard Successive Shortest Path.
// This is called after capacity scaling phases complete (when delta &lt; 1) to handle
// any remaining fractional flow requirements.
//
// Parameters:
//   - ctx: Context for cancellation
//   - g: Residual graph
//   - source, sink: Source and sink node IDs
//   - requiredFlow: Remaining flow to push
//   - potentials: Current node potentials
//   - options: Solver options
//
// Returns:
//   - MinCostFlowResult with the additional flow pushed
func finishWithSSP(
        ctx context.Context,
        g *graph.ResidualGraph,
        source, sink int64,
        requiredFlow float64,
        potentials map[int64]float64,
        options *SolverOptions,
) *MinCostFlowResult <span class="cov8" title="1">{
        totalFlow := 0.0
        totalCost := 0.0
        iterations := 0
        var paths []converter.PathWithFlow

        checkInterval := 50

        for totalFlow &lt; requiredFlow-options.Epsilon </span><span class="cov8" title="1">{
                if options.MaxIterations &gt; 0 &amp;&amp; iterations &gt;= options.MaxIterations </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">if iterations%checkInterval == 0 </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov8" title="1">
                                return &amp;MinCostFlowResult{
                                        Flow:       totalFlow,
                                        Cost:       totalCost,
                                        Iterations: iterations,
                                        Paths:      paths,
                                        Canceled:   true,
                                }</span>
                        default:<span class="cov8" title="1"></span>
                        }
                }

                // Use Dijkstra with potentials (no delta threshold)
                <span class="cov8" title="1">dijkstraResult := dijkstraWithPotentialsDeterministic(ctx, g, source, potentials, options.Epsilon)
                if dijkstraResult.Canceled </span><span class="cov0" title="0">{
                        return &amp;MinCostFlowResult{
                                Flow:       totalFlow,
                                Cost:       totalCost,
                                Iterations: iterations,
                                Paths:      paths,
                                Canceled:   true,
                        }
                }</span>

                <span class="cov8" title="1">if dijkstraResult.Distances[sink] &gt;= graph.Infinity-options.Epsilon </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">updatePotentials(g, potentials, dijkstraResult.Distances)

                path := graph.ReconstructPath(dijkstraResult.Parent, source, sink)
                if len(path) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">pathFlow := min(requiredFlow-totalFlow, graph.FindMinCapacityOnPath(g, path))
                if pathFlow &lt;= options.Epsilon </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">pathCost := augmentPathWithCost(g, path, pathFlow)

                totalFlow += pathFlow
                totalCost += pathCost
                iterations++

                if options.ReturnPaths </span><span class="cov0" title="0">{
                        paths = append(paths, converter.PathWithFlow{
                                NodeIDs: copyPath(path),
                                Flow:    pathFlow,
                        })
                }</span>
        }

        <span class="cov8" title="1">return &amp;MinCostFlowResult{
                Flow:       totalFlow,
                Cost:       totalCost,
                Iterations: iterations,
                Paths:      paths,
                Canceled:   false,
        }</span>
}

// dijkstraWithPotentialsDeterministic runs Dijkstra's algorithm with potentials
// and deterministic node ordering. Unlike dijkstraWithDeltaNetwork, this version
// considers all edges regardless of capacity (no delta threshold).
//
// This is used in the final SSP phase after capacity scaling completes.
func dijkstraWithPotentialsDeterministic(
        ctx context.Context,
        g *graph.ResidualGraph,
        source int64,
        potentials map[int64]float64,
        epsilon float64,
) *DijkstraResult <span class="cov8" title="1">{
        nodes := g.GetSortedNodes()

        dist := make(map[int64]float64, len(nodes))
        parent := make(map[int64]int64, len(nodes))

        for _, node := range nodes </span><span class="cov8" title="1">{
                dist[node] = graph.Infinity
                parent[node] = -1
        }</span>
        <span class="cov8" title="1">dist[source] = 0

        pq := make(dijkstraPQ, 0, len(nodes))
        heap.Init(&amp;pq)
        heap.Push(&amp;pq, &amp;dijkstraPQItem{node: source, distance: 0})

        checkInterval := 100
        iterations := 0

        for pq.Len() &gt; 0 </span><span class="cov8" title="1">{
                if iterations%checkInterval == 0 </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return &amp;DijkstraResult{Distances: dist, Parent: parent, Canceled: true}</span>
                        default:<span class="cov8" title="1"></span>
                        }
                }
                <span class="cov8" title="1">iterations++

                current := heap.Pop(&amp;pq).(*dijkstraPQItem)
                u := current.node

                if current.distance &gt; dist[u]+epsilon </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">neighbors := g.GetNeighborsList(u)
                for _, edge := range neighbors </span><span class="cov8" title="1">{
                        // Consider all edges with positive capacity
                        if edge.Capacity &lt;= epsilon </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">v := edge.To
                        reducedCost := edge.Cost + potentials[u] - potentials[v]
                        if reducedCost &lt; 0 </span><span class="cov0" title="0">{
                                reducedCost = 0
                        }</span>

                        <span class="cov8" title="1">newDist := dist[u] + reducedCost
                        if newDist &lt; dist[v]-epsilon </span><span class="cov8" title="1">{
                                dist[v] = newDist
                                parent[v] = u
                                heap.Push(&amp;pq, &amp;dijkstraPQItem{node: v, distance: newDist})
                        }</span>
                }
        }

        <span class="cov8" title="1">return &amp;DijkstraResult{Distances: dist, Parent: parent, Canceled: false}</span>
}

// =============================================================================
// Priority Queue for Dijkstra
// =============================================================================

// dijkstraPQItem represents an item in the Dijkstra priority queue.
type dijkstraPQItem struct {
        node     int64   // Node ID
        distance float64 // Distance from source
        index    int     // Index in the heap (managed by container/heap)
}

// dijkstraPQ implements a min-heap priority queue for Dijkstra's algorithm.
type dijkstraPQ []*dijkstraPQItem

func (pq dijkstraPQ) Len() int <span class="cov8" title="1">{ return len(pq) }</span>

func (pq dijkstraPQ) Less(i, j int) bool <span class="cov8" title="1">{
        // Min-heap by distance; break ties by node ID for determinism
        if pq[i].distance == pq[j].distance </span><span class="cov8" title="1">{
                return pq[i].node &lt; pq[j].node
        }</span>
        <span class="cov8" title="1">return pq[i].distance &lt; pq[j].distance</span>
}

func (pq dijkstraPQ) Swap(i, j int) <span class="cov8" title="1">{
        pq[i], pq[j] = pq[j], pq[i]
        pq[i].index = i
        pq[j].index = j
}</span>

func (pq *dijkstraPQ) Push(x any) <span class="cov8" title="1">{
        item := x.(*dijkstraPQItem)
        item.index = len(*pq)
        *pq = append(*pq, item)
}</span>

func (pq *dijkstraPQ) Pop() any <span class="cov8" title="1">{
        old := *pq
        n := len(old)
        item := old[n-1]
        old[n-1] = nil
        *pq = old[0 : n-1]
        return item
}</span>

// =============================================================================
// Utility Functions
// =============================================================================

// findMaxCapacity finds the maximum original capacity among all forward edges.
// This is used to determine the initial delta for capacity scaling.
func findMaxCapacity(g *graph.ResidualGraph) float64 <span class="cov8" title="1">{
        maxCap := 0.0
        for _, edges := range g.EdgesList </span><span class="cov8" title="1">{
                for _, edge := range edges </span><span class="cov8" title="1">{
                        if !edge.IsReverse &amp;&amp; edge.OriginalCapacity &gt; maxCap </span><span class="cov8" title="1">{
                                maxCap = edge.OriginalCapacity
                        }</span>
                }
        }
        <span class="cov8" title="1">return maxCap</span>
}

// copyPath creates a deep copy of a path slice.
func copyPath(path []int64) []int64 <span class="cov8" title="1">{
        result := make([]int64, len(path))
        copy(result, path)
        return result
}</span>

// =============================================================================
// Algorithm Selection Helpers
// =============================================================================

// MinCostAlgorithmType enumerates the available min-cost flow algorithms.
type MinCostAlgorithmType int

const (
        // MinCostAlgorithmSSP selects Successive Shortest Path algorithm.
        // Best for: small to medium graphs, graphs with small capacities.
        MinCostAlgorithmSSP MinCostAlgorithmType = iota

        // MinCostAlgorithmCapacityScaling selects Capacity Scaling algorithm.
        // Best for: large graphs with high capacity values (&gt; 10^6).
        MinCostAlgorithmCapacityScaling
)

// String returns the algorithm name for logging/debugging.
func (t MinCostAlgorithmType) String() string <span class="cov8" title="1">{
        switch t </span>{
        case MinCostAlgorithmSSP:<span class="cov8" title="1">
                return "SuccessiveShortestPath"</span>
        case MinCostAlgorithmCapacityScaling:<span class="cov8" title="1">
                return "CapacityScaling"</span>
        default:<span class="cov8" title="1">
                return "Unknown"</span>
        }
}

// ShouldUseCapacityScaling determines if Capacity Scaling is recommended
// for the given graph based on maximum edge capacity.
//
// Capacity Scaling is preferred when:
//   - Maximum capacity exceeds CapacityScalingThreshold (10^6)
//   - The graph is large enough to benefit from scaling phases
//
// Returns true if Capacity Scaling is recommended.
func ShouldUseCapacityScaling(g *graph.ResidualGraph) bool <span class="cov8" title="1">{
        return findMaxCapacity(g) &gt; CapacityScalingThreshold
}</span>

// RecommendMinCostAlgorithm analyzes graph characteristics and recommends
// the most suitable min-cost flow algorithm.
//
// Decision factors:
//   - Maximum edge capacity (high capacity favors Capacity Scaling)
//   - Graph size (very small graphs don't benefit from scaling)
//
// Returns the recommended algorithm type.
func RecommendMinCostAlgorithm(g *graph.ResidualGraph) MinCostAlgorithmType <span class="cov8" title="1">{
        if ShouldUseCapacityScaling(g) </span><span class="cov8" title="1">{
                return MinCostAlgorithmCapacityScaling
        }</span>
        <span class="cov8" title="1">return MinCostAlgorithmSSP</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package algorithms

import (
        "container/heap"
        "context"

        "logistics/services/solver-svc/internal/graph"
)

// =============================================================================
// Dijkstra's Algorithm
// =============================================================================
//
// Dijkstra's algorithm finds the shortest paths from a single source vertex to
// all other vertices in a graph with non-negative edge weights.
//
// Time Complexity: O((V + E) log V) with binary heap
// Space Complexity: O(V)
//
// Use Cases:
//   - Finding shortest paths in graphs with non-negative weights
//   - Successive shortest path algorithms (with potentials to handle negative costs)
//   - General single-source shortest path problems
//
// Important:
//   - Standard Dijkstra cannot handle negative edge weights correctly
//   - This implementation includes automatic fallback to Bellman-Ford when
//     negative edges are detected
//
// References:
//   - Dijkstra, E. W. (1959). "A note on two problems in connexion with graphs"
// =============================================================================

// DijkstraResult contains the result of Dijkstra's algorithm.
type DijkstraResult struct {
        // Distances maps each node to its shortest distance from the source.
        Distances map[int64]float64

        // Parent maps each node to its predecessor on the shortest path.
        Parent map[int64]int64

        // Canceled indicates whether the operation was canceled via context.
        Canceled bool

        // UsedBellmanFord indicates whether the algorithm fell back to Bellman-Ford
        // due to negative edge weights being detected.
        UsedBellmanFord bool
}

// GetDistances implements the ShortestPathResult interface.
func (r *DijkstraResult) GetDistances() map[int64]float64 <span class="cov8" title="1">{
        return r.Distances
}</span>

// GetParent implements the ShortestPathResult interface.
func (r *DijkstraResult) GetParent() map[int64]int64 <span class="cov8" title="1">{
        return r.Parent
}</span>

// priorityQueueItem represents an element in the priority queue.
type priorityQueueItem struct {
        node     int64
        distance float64
        index    int // Index in the heap for updates
}

// priorityQueue implements heap.Interface for Dijkstra's algorithm.
// It is a min-heap based on distance, with tie-breaking by node ID for determinism.
type priorityQueue []*priorityQueueItem

func (pq priorityQueue) Len() int <span class="cov8" title="1">{ return len(pq) }</span>

func (pq priorityQueue) Less(i, j int) bool <span class="cov8" title="1">{
        // Primary sort: by distance (min-heap)
        if pq[i].distance != pq[j].distance </span><span class="cov8" title="1">{
                return pq[i].distance &lt; pq[j].distance
        }</span>
        // Secondary sort: by node ID for deterministic ordering
        <span class="cov8" title="1">return pq[i].node &lt; pq[j].node</span>
}

func (pq priorityQueue) Swap(i, j int) <span class="cov8" title="1">{
        pq[i], pq[j] = pq[j], pq[i]
        pq[i].index = i
        pq[j].index = j
}</span>

func (pq *priorityQueue) Push(x any) <span class="cov8" title="1">{
        n := len(*pq)
        item := x.(*priorityQueueItem)
        item.index = n
        *pq = append(*pq, item)
}</span>

func (pq *priorityQueue) Pop() any <span class="cov8" title="1">{
        old := *pq
        n := len(old)
        item := old[n-1]
        old[n-1] = nil // Avoid memory leak
        item.index = -1
        *pq = old[0 : n-1]
        return item
}</span>

// update modifies the distance of an item in the priority queue.
func (pq *priorityQueue) update(item *priorityQueueItem, distance float64) <span class="cov8" title="1">{
        item.distance = distance
        heap.Fix(pq, item.index)
}</span>

// Dijkstra executes Dijkstra's algorithm without context cancellation support.
// Automatically falls back to Bellman-Ford if negative edges are detected.
//
// Parameters:
//   - g: The residual graph to search
//   - source: The source node ID
//
// Returns:
//   - *DijkstraResult containing distances and parent pointers
func Dijkstra(g *graph.ResidualGraph, source int64) *DijkstraResult <span class="cov8" title="1">{
        return DijkstraWithContext(context.Background(), g, source)
}</span>

// DijkstraWithContext executes Dijkstra's algorithm with context cancellation.
// Uses deterministic ordering for reproducible results.
//
// Parameters:
//   - ctx: Context for cancellation support
//   - g: The residual graph to search
//   - source: The source node ID
//
// Returns:
//   - *DijkstraResult with distances, parents, and status flags
func DijkstraWithContext(ctx context.Context, g *graph.ResidualGraph, source int64) *DijkstraResult <span class="cov8" title="1">{
        nodes := g.GetSortedNodes()

        dist := make(map[int64]float64, len(nodes))
        parent := make(map[int64]int64, len(nodes))

        for _, node := range nodes </span><span class="cov8" title="1">{
                dist[node] = graph.Infinity
                parent[node] = -1
        }</span>
        <span class="cov8" title="1">dist[source] = 0

        pq := make(priorityQueue, 0, len(nodes))
        heap.Init(&amp;pq)
        heap.Push(&amp;pq, &amp;priorityQueueItem{
                node:     source,
                distance: 0,
        })

        const checkInterval = 100
        iterations := 0

        for pq.Len() &gt; 0 </span><span class="cov8" title="1">{
                // Periodic context check
                if iterations%checkInterval == 0 </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov8" title="1">
                                return &amp;DijkstraResult{
                                        Distances: dist,
                                        Parent:    parent,
                                        Canceled:  true,
                                }</span>
                        default:<span class="cov8" title="1"></span>
                        }
                }
                <span class="cov8" title="1">iterations++

                current := heap.Pop(&amp;pq).(*priorityQueueItem)
                u := current.node

                // Skip stale entries (already processed with a better distance)
                if current.distance &gt; dist[u]+graph.Epsilon </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Use EdgesList for deterministic edge ordering
                <span class="cov8" title="1">neighbors := g.GetNeighborsList(u)
                for _, edge := range neighbors </span><span class="cov8" title="1">{
                        if edge.Capacity &lt;= graph.Epsilon </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">v := edge.To

                        // Detect negative edge weight - fallback to Bellman-Ford
                        if edge.Cost &lt; -graph.Epsilon </span><span class="cov8" title="1">{
                                bfResult := BellmanFordWithContext(ctx, g, source)
                                return &amp;DijkstraResult{
                                        Distances:       bfResult.Distances,
                                        Parent:          bfResult.Parent,
                                        Canceled:        bfResult.Canceled,
                                        UsedBellmanFord: true,
                                }
                        }</span>

                        <span class="cov8" title="1">newDist := dist[u] + edge.Cost

                        if newDist &lt; dist[v]-graph.Epsilon </span><span class="cov8" title="1">{
                                dist[v] = newDist
                                parent[v] = u
                                heap.Push(&amp;pq, &amp;priorityQueueItem{
                                        node:     v,
                                        distance: newDist,
                                })
                        }</span>
                }
        }

        <span class="cov8" title="1">return &amp;DijkstraResult{
                Distances: dist,
                Parent:    parent,
                Canceled:  false,
        }</span>
}

// DijkstraWithPotentials executes Dijkstra using reduced costs based on potentials.
// This allows Dijkstra to work correctly in graphs that originally had negative costs,
// as long as the potentials make all reduced costs non-negative.
//
// The reduced cost of edge (u,v) is: cost(u,v) + potential[u] - potential[v]
//
// Parameters:
//   - g: The residual graph
//   - source: The source node ID
//   - potentials: Map of node potentials
//
// Returns:
//   - *DijkstraResult with distances based on reduced costs
func DijkstraWithPotentials(g *graph.ResidualGraph, source int64, potentials map[int64]float64) *DijkstraResult <span class="cov8" title="1">{
        return DijkstraWithPotentialsContext(context.Background(), g, source, potentials)
}</span>

// DijkstraWithPotentialsContext is the context-aware version with configurable fallback threshold.
func DijkstraWithPotentialsContext(ctx context.Context, g *graph.ResidualGraph, source int64, potentials map[int64]float64) *DijkstraResult <span class="cov8" title="1">{
        return DijkstraWithPotentialsContextEx(ctx, g, source, potentials, DefaultNegativeEdgeFallbackThreshold)
}</span>

// DefaultNegativeEdgeFallbackThreshold is the default number of negative reduced costs
// to tolerate before falling back to Bellman-Ford.
const DefaultNegativeEdgeFallbackThreshold = 3

// DijkstraWithPotentialsContextEx provides full control over fallback behavior.
//
// This function uses Johnson's technique with node potentials to handle graphs
// that originally had negative edge costs. The reduced cost of an edge (u,v) is:
//
//        reducedCost(u,v) = cost(u,v) + potential[u] - potential[v]
//
// With proper potentials (computed by Bellman-Ford), all reduced costs should be
// non-negative. However, due to floating-point errors or improper potential updates,
// small negative values may occur.
//
// Fallback Behavior:
//   - Tiny negative values (&gt; -Epsilon): clamped to 0 (numerical noise)
//   - Significant negative values: immediate fallback to Bellman-Ford
//
// Parameters:
//   - ctx: Context for cancellation
//   - g: The residual graph
//   - source: The source node ID
//   - potentials: Map of node potentials
//   - fallbackThreshold: Ignored in current implementation (kept for API compatibility)
//
// Returns:
//   - *DijkstraResult with distances based on reduced costs
func DijkstraWithPotentialsContextEx(ctx context.Context, g *graph.ResidualGraph, source int64, potentials map[int64]float64, fallbackThreshold int) *DijkstraResult <span class="cov8" title="1">{
        nodes := g.GetSortedNodes()

        dist := make(map[int64]float64, len(nodes))
        parent := make(map[int64]int64, len(nodes))
        items := make(map[int64]*priorityQueueItem, len(nodes))

        for _, node := range nodes </span><span class="cov8" title="1">{
                dist[node] = graph.Infinity
                parent[node] = -1
        }</span>
        <span class="cov8" title="1">dist[source] = 0

        pq := make(priorityQueue, 0, len(nodes))
        heap.Init(&amp;pq)

        startItem := &amp;priorityQueueItem{
                node:     source,
                distance: 0,
        }
        heap.Push(&amp;pq, startItem)
        items[source] = startItem

        const checkInterval = 100
        iterations := 0
        usedFallback := false

        for pq.Len() &gt; 0 </span><span class="cov8" title="1">{
                if iterations%checkInterval == 0 </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov8" title="1">
                                return &amp;DijkstraResult{
                                        Distances: dist,
                                        Parent:    parent,
                                        Canceled:  true,
                                }</span>
                        default:<span class="cov8" title="1"></span>
                        }
                }
                <span class="cov8" title="1">iterations++

                current := heap.Pop(&amp;pq).(*priorityQueueItem)
                u := current.node

                // Skip stale entries
                if current.distance &gt; dist[u]+graph.Epsilon </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">neighbors := g.GetNeighborsList(u)
                for _, edge := range neighbors </span><span class="cov8" title="1">{
                        if edge.Capacity &lt;= graph.Epsilon </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">v := edge.To

                        // Compute reduced cost using potentials
                        potU := potentials[u]
                        potV := potentials[v]
                        reducedCost := edge.Cost + potU - potV

                        // Handle negative reduced costs
                        if reducedCost &lt; -graph.Epsilon </span><span class="cov8" title="1">{
                                // Significant negative reduced cost detected.
                                // This indicates either:
                                // 1. Potentials are not properly maintained
                                // 2. Graph structure changed after potential computation
                                // 3. Numerical instability accumulated over iterations
                                //
                                // Fall back to Bellman-Ford which handles negative edges correctly.
                                bfResult := BellmanFordWithPotentialsContext(ctx, g, source, potentials)
                                return &amp;DijkstraResult{
                                        Distances:       bfResult.Distances,
                                        Parent:          bfResult.Parent,
                                        Canceled:        bfResult.Canceled,
                                        UsedBellmanFord: true,
                                }
                        }</span>

                        // Clamp tiny negative values to zero (numerical noise)
                        <span class="cov8" title="1">if reducedCost &lt; 0 </span><span class="cov8" title="1">{
                                reducedCost = 0
                                usedFallback = true // Mark that we had numerical issues
                        }</span>

                        <span class="cov8" title="1">newDist := dist[u] + reducedCost

                        if newDist &lt; dist[v]-graph.Epsilon </span><span class="cov8" title="1">{
                                dist[v] = newDist
                                parent[v] = u

                                // Update existing item or add new one
                                if item, exists := items[v]; exists &amp;&amp; item.index &gt;= 0 </span><span class="cov8" title="1">{
                                        pq.update(item, newDist)
                                }</span> else<span class="cov8" title="1"> {
                                        newItem := &amp;priorityQueueItem{
                                                node:     v,
                                                distance: newDist,
                                        }
                                        heap.Push(&amp;pq, newItem)
                                        items[v] = newItem
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return &amp;DijkstraResult{
                Distances:       dist,
                Parent:          parent,
                Canceled:        false,
                UsedBellmanFord: usedFallback,
        }</span>
}

// DijkstraWithFallback explicitly checks for negative weights before running Dijkstra.
// If negative weights exist, it uses Bellman-Ford instead.
//
// Parameters:
//   - ctx: Context for cancellation
//   - g: The residual graph
//   - source: The source node ID
//
// Returns:
//   - *DijkstraResult with appropriate algorithm used
func DijkstraWithFallback(ctx context.Context, g *graph.ResidualGraph, source int64) *DijkstraResult <span class="cov8" title="1">{
        // Pre-check for negative weights in deterministic order
        nodes := g.GetSortedNodes()
        hasNegativeWeights := false

        for _, u := range nodes </span><span class="cov8" title="1">{
                edges := g.GetNeighborsList(u)
                for _, edge := range edges </span><span class="cov8" title="1">{
                        if edge.Capacity &gt; graph.Epsilon &amp;&amp; edge.Cost &lt; -graph.Epsilon </span><span class="cov8" title="1">{
                                hasNegativeWeights = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if hasNegativeWeights </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">if hasNegativeWeights </span><span class="cov8" title="1">{
                bfResult := BellmanFordWithContext(ctx, g, source)
                return &amp;DijkstraResult{
                        Distances:       bfResult.Distances,
                        Parent:          bfResult.Parent,
                        Canceled:        bfResult.Canceled,
                        UsedBellmanFord: true,
                }
        }</span>

        <span class="cov8" title="1">return DijkstraWithContext(ctx, g, source)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package algorithms

import (
        "context"

        "logistics/services/solver-svc/internal/converter"
        "logistics/services/solver-svc/internal/graph"
)

// =============================================================================
// Dinic's Algorithm (Dinitz's Algorithm)
// =============================================================================
//
// Dinic's algorithm finds the maximum flow in a flow network. It improves upon
// Ford-Fulkerson by using BFS to construct level graphs and finding blocking
// flows, reducing the number of augmenting path searches.
//
// Time Complexity: O(V² × E) general case, O(E × √V) for unit capacity graphs
// Space Complexity: O(V + E)
//
// Key Features:
//   - Level graph construction using BFS
//   - Blocking flow computation in each phase
//   - Current arc optimization for efficiency
//   - Optimal for unit capacity networks and bipartite matching
//
// Algorithm Phases:
//  1. BFS from source to build level graph (assigns levels to vertices)
//  2. Find blocking flow using DFS with current arc optimization
//  3. Repeat until sink is unreachable from source
//
// References:
//   - Dinitz, Y. (1970). "Algorithm for solution of a problem of maximum flow
//     in a network with power estimation"
//   - Even, S. &amp; Tarjan, R.E. (1975). "Network flow and testing graph connectivity"
// =============================================================================

// DinicResult contains the result of Dinic's algorithm.
type DinicResult struct {
        // MaxFlow is the maximum flow value computed.
        MaxFlow float64

        // Iterations is the number of BFS phases executed.
        Iterations int

        // Paths contains the augmenting paths found (if ReturnPaths option is enabled).
        Paths []converter.PathWithFlow

        // Canceled indicates whether the operation was canceled via context.
        Canceled bool
}

// Dinic executes Dinic's algorithm without context cancellation support.
//
// Parameters:
//   - g: The residual graph (will be modified)
//   - source: The source node ID
//   - sink: The sink node ID
//   - options: Solver options (nil for defaults)
//
// Returns:
//   - *DinicResult containing max flow and optional paths
func Dinic(g *graph.ResidualGraph, source, sink int64, options *SolverOptions) *DinicResult <span class="cov8" title="1">{
        return DinicWithContext(context.Background(), g, source, sink, options)
}</span>

// DinicWithContext executes Dinic's algorithm with context cancellation.
// Uses deterministic ordering for reproducible results.
//
// Parameters:
//   - ctx: Context for cancellation support
//   - g: The residual graph (will be modified)
//   - source: The source node ID
//   - sink: The sink node ID
//   - options: Solver options
//
// Returns:
//   - *DinicResult containing max flow, iteration count, paths, and cancellation status
func DinicWithContext(ctx context.Context, g *graph.ResidualGraph, source, sink int64, options *SolverOptions) *DinicResult <span class="cov8" title="1">{
        if options == nil </span><span class="cov8" title="1">{
                options = DefaultSolverOptions()
        }</span>

        <span class="cov8" title="1">maxFlow := 0.0
        iterations := 0
        var paths []converter.PathWithFlow

        const checkInterval = 100

        for options.MaxIterations &lt;= 0 || iterations &lt; options.MaxIterations </span><span class="cov8" title="1">{
                // Periodic context check
                if iterations%checkInterval == 0 </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov8" title="1">
                                return &amp;DinicResult{
                                        MaxFlow:    maxFlow,
                                        Iterations: iterations,
                                        Paths:      paths,
                                        Canceled:   true,
                                }</span>
                        default:<span class="cov8" title="1"></span>
                        }
                }

                // Phase 1: Build level graph using BFS
                <span class="cov8" title="1">level := bfsLevelDeterministic(g, source)

                // If sink is unreachable, we've found maximum flow
                if _, exists := level[sink]; !exists </span><span class="cov8" title="1">{
                        break</span>
                }

                // Phase 2: Find blocking flow
                <span class="cov8" title="1">blockingFlow, blockingPaths := findBlockingFlow(g, source, sink, level, options)

                if blockingFlow &lt;= options.Epsilon </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">maxFlow += blockingFlow

                if options.ReturnPaths </span><span class="cov8" title="1">{
                        paths = append(paths, blockingPaths...)
                }</span>

                <span class="cov8" title="1">iterations++</span>
        }

        <span class="cov8" title="1">return &amp;DinicResult{
                MaxFlow:    maxFlow,
                Iterations: iterations,
                Paths:      paths,
                Canceled:   false,
        }</span>
}

// findBlockingFlow finds a blocking flow in the level graph.
// A blocking flow saturates at least one edge on every path from source to sink.
//
// Uses iterative DFS with current arc optimization to achieve efficient performance.
func findBlockingFlow(g *graph.ResidualGraph, source, sink int64, level map[int64]int, options *SolverOptions) (float64, []converter.PathWithFlow) <span class="cov8" title="1">{
        totalFlow := 0.0
        var paths []converter.PathWithFlow

        // Current arc optimization: track next edge to try for each node
        currentArc := make(map[int64]int)

        for </span><span class="cov8" title="1">{
                // Find an augmenting path and its flow
                path, pathFlow := dfsBlockingPath(g, source, sink, level, currentArc, options.Epsilon)

                if pathFlow &lt;= options.Epsilon </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">totalFlow += pathFlow

                if options.ReturnPaths &amp;&amp; len(path) &gt; 0 </span><span class="cov8" title="1">{
                        pathCopy := make([]int64, len(path))
                        copy(pathCopy, path)
                        paths = append(paths, converter.PathWithFlow{
                                NodeIDs: pathCopy,
                                Flow:    pathFlow,
                        })
                }</span>
        }

        <span class="cov8" title="1">return totalFlow, paths</span>
}

// dfsBlockingPath finds one augmenting path using iterative DFS and augments it.
// Returns the path and the amount of flow pushed.
//
// The iterative implementation avoids stack overflow on deep graphs.
func dfsBlockingPath(g *graph.ResidualGraph, source, sink int64, level map[int64]int, currentArc map[int64]int, epsilon float64) ([]int64, float64) <span class="cov8" title="1">{
        type stackItem struct {
                node    int64
                pathIdx int
        }

        // Preallocate path and minCap slices
        path := make([]int64, 0, 64)
        minCap := make([]float64, 0, 64)

        stack := []stackItem{{node: source, pathIdx: 0}}
        path = append(path, source)
        minCap = append(minCap, graph.Infinity)

        for len(stack) &gt; 0 </span><span class="cov8" title="1">{
                current := &amp;stack[len(stack)-1]
                u := current.node

                // Found path to sink
                if u == sink </span><span class="cov8" title="1">{
                        bottleneck := minCap[len(minCap)-1]

                        // Augment path: update flows along the path
                        for i := 0; i &lt; len(path)-1; i++ </span><span class="cov8" title="1">{
                                g.UpdateFlow(path[i], path[i+1], bottleneck)
                        }</span>

                        // Return a copy of the path
                        <span class="cov8" title="1">result := make([]int64, len(path))
                        copy(result, path)
                        return result, bottleneck</span>
                }

                // Get edges from current node (deterministic order via EdgesList)
                <span class="cov8" title="1">edges := g.GetNeighborsList(u)
                startIdx := currentArc[u]

                advanced := false
                for i := startIdx; i &lt; len(edges); i++ </span><span class="cov8" title="1">{
                        edge := edges[i]
                        v := edge.To

                        // Check level graph constraints and capacity
                        if level[v] != level[u]+1 || edge.Capacity &lt;= epsilon </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        // Update current arc
                        <span class="cov8" title="1">currentArc[u] = i

                        // Compute bottleneck to v
                        newMinCap := minCap[len(minCap)-1]
                        if edge.Capacity &lt; newMinCap </span><span class="cov8" title="1">{
                                newMinCap = edge.Capacity
                        }</span>

                        // Push v onto path and stack
                        <span class="cov8" title="1">path = append(path, v)
                        minCap = append(minCap, newMinCap)
                        stack = append(stack, stackItem{node: v, pathIdx: len(path) - 1})

                        advanced = true
                        break</span>
                }

                <span class="cov8" title="1">if !advanced </span><span class="cov8" title="1">{
                        // No valid edge found - backtrack
                        currentArc[u] = len(edges) // Mark all edges as processed

                        // Remove node from level graph (dead end optimization)
                        delete(level, u)

                        // Pop from stack and path
                        stack = stack[:len(stack)-1]
                        path = path[:len(path)-1]
                        minCap = minCap[:len(minCap)-1]
                }</span>
        }

        <span class="cov8" title="1">return nil, 0</span>
}

// bfsLevelDeterministic constructs a level graph using BFS with deterministic ordering.
// Returns a map from node ID to its level (distance from source).
func bfsLevelDeterministic(g *graph.ResidualGraph, source int64) map[int64]int <span class="cov8" title="1">{
        level := make(map[int64]int, len(g.Nodes))
        level[source] = 0

        queue := make([]int64, 0, len(g.Nodes))
        queue = append(queue, source)
        head := 0

        for head &lt; len(queue) </span><span class="cov8" title="1">{
                u := queue[head]
                head++

                // Use EdgesList for deterministic ordering
                neighbors := g.GetNeighborsList(u)
                for _, edge := range neighbors </span><span class="cov8" title="1">{
                        v := edge.To
                        if _, exists := level[v]; !exists &amp;&amp; edge.Capacity &gt; graph.Epsilon </span><span class="cov8" title="1">{
                                level[v] = level[u] + 1
                                queue = append(queue, v)
                        }</span>
                }
        }

        <span class="cov8" title="1">return level</span>
}

// =============================================================================
// Recursive DFS Implementation (for comparison and small graphs)
// =============================================================================

// dinicDFSRecursive is a recursive DFS implementation for blocking flow.
// Use only for small graphs due to stack depth limitations.
//
// Returns the flow pushed and the path taken.
func dinicDFSRecursive(
        g *graph.ResidualGraph,
        u, sink int64,
        pushed float64,
        level map[int64]int,
        iter map[int64]int,
        epsilon float64,
) (float64, []int64) <span class="cov8" title="1">{
        if u == sink </span><span class="cov8" title="1">{
                return pushed, []int64{sink}
        }</span>

        <span class="cov8" title="1">neighbors := g.GetNeighborsList(u)
        if neighbors == nil </span><span class="cov8" title="1">{
                return 0, nil
        }</span>

        <span class="cov8" title="1">for ; iter[u] &lt; len(neighbors); iter[u]++ </span><span class="cov8" title="1">{
                edge := neighbors[iter[u]]
                v := edge.To

                if level[v] != level[u]+1 || edge.Capacity &lt;= epsilon </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">canPush := min(pushed, edge.Capacity)
                flow, path := dinicDFSRecursive(g, v, sink, canPush, level, iter, epsilon)

                if flow &gt; epsilon </span><span class="cov8" title="1">{
                        g.UpdateFlow(u, v, flow)
                        return flow, append([]int64{u}, path...)
                }</span>
        }

        // Dead end - remove from level graph only after exhausting all edges
        <span class="cov8" title="1">delete(level, u)
        return 0, nil</span>
}

// =============================================================================
// Dinic with Callback
// =============================================================================

// PathCallback is a function called for each augmenting path found.
type PathCallback func(path []int64, flow float64)

// DinicWithCallback executes Dinic's algorithm with a callback for each path.
// Useful for real-time path processing or streaming results.
//
// Parameters:
//   - ctx: Context for cancellation
//   - g: The residual graph
//   - source: Source node ID
//   - sink: Sink node ID
//   - options: Solver options
//   - callback: Function called for each path (can be nil)
//
// Returns:
//   - *DinicResult with max flow and collected paths
func DinicWithCallback(
        ctx context.Context,
        g *graph.ResidualGraph,
        source, sink int64,
        options *SolverOptions,
        callback PathCallback,
) *DinicResult <span class="cov8" title="1">{
        if options == nil </span><span class="cov8" title="1">{
                options = DefaultSolverOptions()
        }</span>

        <span class="cov8" title="1">maxFlow := 0.0
        iterations := 0
        var paths []converter.PathWithFlow

        const checkInterval = 50

        for options.MaxIterations &lt;= 0 || iterations &lt; options.MaxIterations </span><span class="cov8" title="1">{
                if iterations%checkInterval == 0 </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov8" title="1">
                                return &amp;DinicResult{
                                        MaxFlow:    maxFlow,
                                        Iterations: iterations,
                                        Paths:      paths,
                                        Canceled:   true,
                                }</span>
                        default:<span class="cov8" title="1"></span>
                        }
                }

                <span class="cov8" title="1">level := bfsLevelDeterministic(g, source)
                if _, exists := level[sink]; !exists </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">currentArc := make(map[int64]int)

                for </span><span class="cov8" title="1">{
                        path, flow := dfsBlockingPath(g, source, sink, level, currentArc, options.Epsilon)
                        if flow &lt;= options.Epsilon </span><span class="cov8" title="1">{
                                break</span>
                        }

                        <span class="cov8" title="1">maxFlow += flow

                        // Call callback for real-time processing
                        if callback != nil </span><span class="cov8" title="1">{
                                callback(path, flow)
                        }</span>

                        <span class="cov8" title="1">if options.ReturnPaths &amp;&amp; len(path) &gt; 0 </span><span class="cov8" title="1">{
                                pathCopy := make([]int64, len(path))
                                copy(pathCopy, path)
                                paths = append(paths, converter.PathWithFlow{
                                        NodeIDs: pathCopy,
                                        Flow:    flow,
                                })
                        }</span>
                }

                <span class="cov8" title="1">iterations++</span>
        }

        <span class="cov8" title="1">return &amp;DinicResult{
                MaxFlow:    maxFlow,
                Iterations: iterations,
                Paths:      paths,
                Canceled:   false,
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package algorithms

import (
        "context"

        "logistics/services/solver-svc/internal/converter"
        "logistics/services/solver-svc/internal/graph"
)

// =============================================================================
// Edmonds-Karp Algorithm
// =============================================================================
//
// The Edmonds-Karp algorithm is an implementation of the Ford-Fulkerson method
// using BFS to find augmenting paths. By always choosing the shortest augmenting
// path (in terms of number of edges), it guarantees polynomial time complexity.
//
// Time Complexity: O(V × E²)
// Space Complexity: O(V + E)
//
// Key Features:
//   - Uses BFS for finding augmenting paths (shortest path in unweighted graph)
//   - Guaranteed polynomial time (unlike basic Ford-Fulkerson)
//   - Simple to implement and understand
//   - Good for educational purposes and medium-sized graphs
//
// Comparison with other algorithms:
//   - Slower than Dinic for large graphs (O(V × E²) vs O(V² × E))
//   - More predictable than Ford-Fulkerson with DFS
//   - Simpler than Push-Relabel
//
// References:
//   - Edmonds, J. &amp; Karp, R.M. (1972). "Theoretical improvements in
//     algorithmic efficiency for network flow problems"
// =============================================================================

// EdmondsKarpResult contains the result of the Edmonds-Karp algorithm.
type EdmondsKarpResult struct {
        // MaxFlow is the maximum flow value computed.
        MaxFlow float64

        // Iterations is the number of augmenting paths found.
        Iterations int

        // Paths contains the augmenting paths found (if ReturnPaths option is enabled).
        Paths []converter.PathWithFlow

        // Canceled indicates whether the operation was canceled via context.
        Canceled bool
}

// EdmondsKarp executes the Edmonds-Karp algorithm without context cancellation.
//
// Parameters:
//   - g: The residual graph (will be modified)
//   - source: The source node ID
//   - sink: The sink node ID
//   - options: Solver options (nil for defaults)
//
// Returns:
//   - *EdmondsKarpResult containing max flow and optional paths
func EdmondsKarp(g *graph.ResidualGraph, source, sink int64, options *SolverOptions) *EdmondsKarpResult <span class="cov8" title="1">{
        return EdmondsKarpWithContext(context.Background(), g, source, sink, options)
}</span>

// EdmondsKarpWithContext executes the Edmonds-Karp algorithm with context cancellation.
// Uses deterministic BFS for reproducible results.
//
// Parameters:
//   - ctx: Context for cancellation support
//   - g: The residual graph (will be modified)
//   - source: The source node ID
//   - sink: The sink node ID
//   - options: Solver options
//
// Returns:
//   - *EdmondsKarpResult containing max flow, iterations, paths, and cancellation status
func EdmondsKarpWithContext(ctx context.Context, g *graph.ResidualGraph, source, sink int64, options *SolverOptions) *EdmondsKarpResult <span class="cov8" title="1">{
        if options == nil </span><span class="cov8" title="1">{
                options = DefaultSolverOptions()
        }</span>

        <span class="cov8" title="1">maxFlow := 0.0
        iterations := 0
        var paths []converter.PathWithFlow

        const checkInterval = 100

        for options.MaxIterations &lt;= 0 || iterations &lt; options.MaxIterations </span><span class="cov8" title="1">{
                // Periodic context check
                if iterations%checkInterval == 0 </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov8" title="1">
                                return &amp;EdmondsKarpResult{
                                        MaxFlow:    maxFlow,
                                        Iterations: iterations,
                                        Paths:      paths,
                                        Canceled:   true,
                                }</span>
                        default:<span class="cov8" title="1"></span>
                        }
                }

                // Find shortest augmenting path using BFS
                <span class="cov8" title="1">bfsResult := graph.BFSDeterministic(g, source, sink)
                if !bfsResult.Found </span><span class="cov8" title="1">{
                        break</span>
                }

                // Reconstruct the path
                <span class="cov8" title="1">path := graph.ReconstructPath(bfsResult.Parent, source, sink)
                if len(path) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                // Find bottleneck capacity
                <span class="cov8" title="1">pathFlow := graph.FindMinCapacityOnPath(g, path)
                if pathFlow &lt;= options.Epsilon </span><span class="cov0" title="0">{
                        break</span>
                }

                // Augment flow along the path
                <span class="cov8" title="1">graph.AugmentPath(g, path, pathFlow)

                maxFlow += pathFlow
                iterations++

                if options.ReturnPaths </span><span class="cov8" title="1">{
                        pathCopy := make([]int64, len(path))
                        copy(pathCopy, path)
                        paths = append(paths, converter.PathWithFlow{
                                NodeIDs: pathCopy,
                                Flow:    pathFlow,
                        })
                }</span>
        }

        <span class="cov8" title="1">return &amp;EdmondsKarpResult{
                MaxFlow:    maxFlow,
                Iterations: iterations,
                Paths:      paths,
                Canceled:   false,
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package algorithms

import (
        "context"

        "logistics/services/solver-svc/internal/converter"
        "logistics/services/solver-svc/internal/graph"
)

// =============================================================================
// Ford-Fulkerson Algorithm
// =============================================================================
//
// The Ford-Fulkerson algorithm computes maximum flow by repeatedly finding
// augmenting paths and pushing flow along them. This implementation uses DFS
// to find paths.
//
// Time Complexity: O(E × max_flow) - can be very slow for large max_flow values
// Space Complexity: O(V + E)
//
// IMPORTANT LIMITATIONS:
//   - May not terminate for irrational capacities
//   - Time complexity depends on max_flow value, not just graph size
//   - Consider using Edmonds-Karp or Dinic for production use
//
// Advantages:
//   - Simple to implement and understand
//   - Good for educational purposes
//   - Works well when max_flow is small relative to graph size
//
// This implementation provides both recursive and iterative DFS versions.
// The iterative version (FordFulkersonIterative) is recommended for large graphs
// to avoid stack overflow.
//
// References:
//   - Ford, L.R. &amp; Fulkerson, D.R. (1956). "Maximal flow through a network"
// =============================================================================

// FordFulkersonResult contains the result of the Ford-Fulkerson algorithm.
type FordFulkersonResult struct {
        // MaxFlow is the maximum flow value computed.
        MaxFlow float64

        // Iterations is the number of augmenting paths found.
        Iterations int

        // Paths contains the augmenting paths found (if ReturnPaths option is enabled).
        Paths []converter.PathWithFlow

        // Canceled indicates whether the operation was canceled via context.
        Canceled bool
}

// FordFulkerson executes the Ford-Fulkerson algorithm using iterative DFS.
// This is the recommended version as it avoids stack overflow on deep graphs.
//
// Parameters:
//   - g: The residual graph (will be modified)
//   - source: The source node ID
//   - sink: The sink node ID
//   - options: Solver options (nil for defaults)
//
// Returns:
//   - *FordFulkersonResult containing max flow and optional paths
func FordFulkerson(g *graph.ResidualGraph, source, sink int64, options *SolverOptions) *FordFulkersonResult <span class="cov8" title="1">{
        // Use iterative version by default to avoid stack overflow
        return FordFulkersonIterative(g, source, sink, options)
}</span>

// FordFulkersonWithContext executes Ford-Fulkerson with context cancellation.
func FordFulkersonWithContext(ctx context.Context, g *graph.ResidualGraph, source, sink int64, options *SolverOptions) *FordFulkersonResult <span class="cov8" title="1">{
        return FordFulkersonIterativeWithContext(ctx, g, source, sink, options)
}</span>

// FordFulkersonRecursive executes Ford-Fulkerson using recursive DFS.
// WARNING: May cause stack overflow on graphs with deep paths (&gt;10000 nodes).
// Use FordFulkersonIterative for large graphs.
//
// Parameters:
//   - g: The residual graph (will be modified)
//   - source: The source node ID
//   - sink: The sink node ID
//   - options: Solver options
//
// Returns:
//   - *FordFulkersonResult containing max flow and optional paths
func FordFulkersonRecursive(g *graph.ResidualGraph, source, sink int64, options *SolverOptions) *FordFulkersonResult <span class="cov8" title="1">{
        return FordFulkersonRecursiveWithContext(context.Background(), g, source, sink, options)
}</span>

// FordFulkersonRecursiveWithContext is the context-aware recursive version.
func FordFulkersonRecursiveWithContext(ctx context.Context, g *graph.ResidualGraph, source, sink int64, options *SolverOptions) *FordFulkersonResult <span class="cov8" title="1">{
        if options == nil </span><span class="cov8" title="1">{
                options = DefaultSolverOptions()
        }</span>

        // Set a reasonable default max iterations for safety
        <span class="cov8" title="1">maxIter := options.MaxIterations
        if maxIter &lt;= 0 </span><span class="cov8" title="1">{
                maxIter = 1_000_000
        }</span>

        <span class="cov8" title="1">maxFlow := 0.0
        iterations := 0
        var paths []converter.PathWithFlow

        const checkInterval = 100

        for iterations &lt; maxIter </span><span class="cov8" title="1">{
                // Periodic context check
                if iterations%checkInterval == 0 </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov8" title="1">
                                return &amp;FordFulkersonResult{
                                        MaxFlow:    maxFlow,
                                        Iterations: iterations,
                                        Paths:      paths,
                                        Canceled:   true,
                                }</span>
                        default:<span class="cov8" title="1"></span>
                        }
                }

                <span class="cov8" title="1">visited := make(map[int64]bool)
                parent := make(map[int64]int64)

                // Find path using recursive DFS
                found := dfsPathRecursive(g, source, sink, visited, parent, options.Epsilon)
                if !found </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">path := graph.ReconstructPath(parent, source, sink)
                if len(path) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">pathFlow := graph.FindMinCapacityOnPath(g, path)
                if pathFlow &lt;= options.Epsilon </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">graph.AugmentPath(g, path, pathFlow)

                maxFlow += pathFlow
                iterations++

                if options.ReturnPaths </span><span class="cov8" title="1">{
                        pathCopy := make([]int64, len(path))
                        copy(pathCopy, path)
                        paths = append(paths, converter.PathWithFlow{
                                NodeIDs: pathCopy,
                                Flow:    pathFlow,
                        })
                }</span>
        }

        <span class="cov8" title="1">return &amp;FordFulkersonResult{
                MaxFlow:    maxFlow,
                Iterations: iterations,
                Paths:      paths,
                Canceled:   false,
        }</span>
}

// dfsPathRecursive finds an augmenting path using recursive DFS.
// Uses deterministic edge ordering via EdgesList.
func dfsPathRecursive(g *graph.ResidualGraph, current, sink int64, visited map[int64]bool, parent map[int64]int64, epsilon float64) bool <span class="cov8" title="1">{
        if current == sink </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">visited[current] = true

        // Use EdgesList for deterministic ordering
        neighbors := g.GetNeighborsList(current)
        for _, edge := range neighbors </span><span class="cov8" title="1">{
                next := edge.To
                if !visited[next] &amp;&amp; edge.Capacity &gt; epsilon </span><span class="cov8" title="1">{
                        parent[next] = current

                        if dfsPathRecursive(g, next, sink, visited, parent, epsilon) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }

        <span class="cov8" title="1">return false</span>
}

// FordFulkersonIterative executes Ford-Fulkerson using iterative DFS.
// This version is safe for graphs with deep paths.
//
// Parameters:
//   - g: The residual graph (will be modified)
//   - source: The source node ID
//   - sink: The sink node ID
//   - options: Solver options
//
// Returns:
//   - *FordFulkersonResult containing max flow and optional paths
func FordFulkersonIterative(g *graph.ResidualGraph, source, sink int64, options *SolverOptions) *FordFulkersonResult <span class="cov8" title="1">{
        return FordFulkersonIterativeWithContext(context.Background(), g, source, sink, options)
}</span>

// FordFulkersonIterativeWithContext is the context-aware iterative version.
func FordFulkersonIterativeWithContext(ctx context.Context, g *graph.ResidualGraph, source, sink int64, options *SolverOptions) *FordFulkersonResult <span class="cov8" title="1">{
        if options == nil </span><span class="cov8" title="1">{
                options = DefaultSolverOptions()
        }</span>

        <span class="cov8" title="1">maxFlow := 0.0
        iterations := 0
        var paths []converter.PathWithFlow

        const checkInterval = 100

        for options.MaxIterations &lt;= 0 || iterations &lt; options.MaxIterations </span><span class="cov8" title="1">{
                // Periodic context check
                if iterations%checkInterval == 0 </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov8" title="1">
                                return &amp;FordFulkersonResult{
                                        MaxFlow:    maxFlow,
                                        Iterations: iterations,
                                        Paths:      paths,
                                        Canceled:   true,
                                }</span>
                        default:<span class="cov8" title="1"></span>
                        }
                }

                // Find path using iterative DFS
                <span class="cov8" title="1">path, found := dfsPathIterative(g, source, sink, options.Epsilon)
                if !found </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">pathFlow := graph.FindMinCapacityOnPath(g, path)
                if pathFlow &lt;= options.Epsilon </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">graph.AugmentPath(g, path, pathFlow)

                maxFlow += pathFlow
                iterations++

                if options.ReturnPaths </span><span class="cov0" title="0">{
                        paths = append(paths, converter.PathWithFlow{
                                NodeIDs: path,
                                Flow:    pathFlow,
                        })
                }</span>
        }

        <span class="cov8" title="1">return &amp;FordFulkersonResult{
                MaxFlow:    maxFlow,
                Iterations: iterations,
                Paths:      paths,
                Canceled:   false,
        }</span>
}

// dfsPathIterative finds an augmenting path using iterative DFS.
// Uses explicit stack to avoid recursion depth issues.
func dfsPathIterative(g *graph.ResidualGraph, source, sink int64, epsilon float64) ([]int64, bool) <span class="cov8" title="1">{
        type stackItem struct {
                node    int64
                parent  int64
                edgeIdx int // Index of next edge to try
        }

        visited := make(map[int64]bool)
        parent := make(map[int64]int64)

        // Initialize stack with source
        stack := []stackItem{{node: source, parent: -1, edgeIdx: 0}}

        for len(stack) &gt; 0 </span><span class="cov8" title="1">{
                current := &amp;stack[len(stack)-1]

                // First visit to this node
                if !visited[current.node] </span><span class="cov8" title="1">{
                        visited[current.node] = true
                        parent[current.node] = current.parent

                        // Check if we reached the sink
                        if current.node == sink </span><span class="cov8" title="1">{
                                return graph.ReconstructPath(parent, source, sink), true
                        }</span>
                }

                // Get edges in deterministic order
                <span class="cov8" title="1">neighbors := g.GetNeighborsList(current.node)

                // Find next unvisited neighbor with capacity
                found := false
                for i := current.edgeIdx; i &lt; len(neighbors); i++ </span><span class="cov8" title="1">{
                        edge := neighbors[i]
                        next := edge.To

                        if !visited[next] &amp;&amp; edge.Capacity &gt; epsilon </span><span class="cov8" title="1">{
                                current.edgeIdx = i + 1 // Remember position for backtrack
                                stack = append(stack, stackItem{node: next, parent: current.node, edgeIdx: 0})
                                found = true
                                break</span>
                        }
                }

                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        // No more neighbors - backtrack
                        stack = stack[:len(stack)-1]
                }</span>
        }

        <span class="cov8" title="1">return nil, false</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package algorithms provides implementations of network flow algorithms.
//
// This file implements the Successive Shortest Path (SSP) algorithm for
// Min-Cost Max-Flow problems, along with utility functions for algorithm
// selection and result handling.
//
// The SSP algorithm works by repeatedly finding shortest paths from source
// to sink using reduced costs, then augmenting flow along these paths.
// Node potentials are maintained to ensure non-negative reduced costs,
// enabling the use of Dijkstra's algorithm.
//
// For graphs with very large capacities, the Capacity Scaling variant
// (implemented in capacity_scaling.go) may be more efficient.
//
// References:
//   - Ahuja, R.K., et al. "Network Flows" (1993), Chapter 9
//   - Kleinberg, J., Tardos, E. "Algorithm Design" (2005), Chapter 7
package algorithms

import (
        "context"

        "logistics/services/solver-svc/internal/converter"
        "logistics/services/solver-svc/internal/graph"
)

// ShortestPathResult defines the interface for shortest path algorithm results.
// This abstraction allows SSP to work with both Dijkstra and Bellman-Ford results.
type ShortestPathResult interface {
        // GetDistances returns the shortest distances from source to all nodes.
        // Unreachable nodes have distance = graph.Infinity.
        GetDistances() map[int64]float64

        // GetParent returns the parent map for path reconstruction.
        // parent[v] = u means the shortest path to v goes through u.
        // parent[source] = -1.
        GetParent() map[int64]int64
}

// MinCostFlowResult encapsulates the result of a min-cost flow computation.
type MinCostFlowResult struct {
        // Flow is the total flow successfully pushed from source to sink.
        Flow float64

        // Cost is the total cost incurred (sum of flow * cost for all edges used).
        Cost float64

        // Iterations counts the number of augmenting paths found.
        Iterations int

        // Paths contains the augmenting paths if ReturnPaths option was enabled.
        Paths []converter.PathWithFlow

        // Canceled indicates if the computation was interrupted by context cancellation.
        Canceled bool
}

// =============================================================================
// Main Entry Points
// =============================================================================

// MinCostMaxFlow finds the minimum cost maximum flow from source to sink.
// This is the primary entry point that automatically selects the best algorithm
// based on graph characteristics.
//
// Algorithm Selection:
//   - For graphs with max capacity &gt; 10^6: uses Capacity Scaling
//   - Otherwise: uses Successive Shortest Path with potentials
//
// Parameters:
//   - g: Residual graph to compute flow on
//   - source: Source node ID
//   - sink: Sink node ID
//   - requiredFlow: Maximum flow to push (use math.MaxFloat64 for max flow)
//   - options: Solver options (nil uses defaults)
//
// Returns:
//   - MinCostFlowResult with optimal flow and minimum cost
//
// Example:
//
//        g := converter.ToResidualGraph(protoGraph)
//        result := MinCostMaxFlow(g, sourceID, sinkID, math.MaxFloat64, nil)
//        fmt.Printf("Optimal flow: %f with cost: %f\n", result.Flow, result.Cost)
func MinCostMaxFlow(g *graph.ResidualGraph, source, sink int64, requiredFlow float64, options *SolverOptions) *MinCostFlowResult <span class="cov8" title="1">{
        return MinCostMaxFlowWithContext(context.Background(), g, source, sink, requiredFlow, options)
}</span>

// MinCostMaxFlowWithContext is the context-aware version of MinCostMaxFlow.
// Supports cancellation via context for long-running computations.
//
// The computation is periodically interrupted to check context status.
// If cancelled, returns partial results with Canceled=true.
func MinCostMaxFlowWithContext(ctx context.Context, g *graph.ResidualGraph, source, sink int64, requiredFlow float64, options *SolverOptions) *MinCostFlowResult <span class="cov8" title="1">{
        if options == nil </span><span class="cov8" title="1">{
                options = DefaultSolverOptions()
        }</span>

        // Select algorithm based on graph characteristics
        <span class="cov8" title="1">recommendation := RecommendMinCostAlgorithm(g)

        switch recommendation </span>{
        case MinCostAlgorithmCapacityScaling:<span class="cov0" title="0">
                return CapacityScalingMinCostFlowWithContext(ctx, g, source, sink, requiredFlow, options)</span>
        default:<span class="cov8" title="1">
                return SuccessiveShortestPathInternal(ctx, g, source, sink, requiredFlow, options)</span>
        }
}

// SuccessiveShortestPath is an alias for MinCostMaxFlow for API compatibility.
func SuccessiveShortestPath(g *graph.ResidualGraph, source, sink int64, requiredFlow float64, options *SolverOptions) *MinCostFlowResult <span class="cov8" title="1">{
        return MinCostMaxFlow(g, source, sink, requiredFlow, options)
}</span>

// SuccessiveShortestPathWithContext is an alias with context support.
func SuccessiveShortestPathWithContext(ctx context.Context, g *graph.ResidualGraph, source, sink int64, requiredFlow float64, options *SolverOptions) *MinCostFlowResult <span class="cov0" title="0">{
        return MinCostMaxFlowWithContext(ctx, g, source, sink, requiredFlow, options)
}</span>

// MinCostFlowWithAlgorithm allows explicit algorithm selection, overriding
// the automatic recommendation.
//
// Use this when you know the algorithm characteristics of your graph or
// when benchmarking different algorithms.
func MinCostFlowWithAlgorithm(ctx context.Context, g *graph.ResidualGraph, source, sink int64, requiredFlow float64, algorithm MinCostAlgorithmType, options *SolverOptions) *MinCostFlowResult <span class="cov8" title="1">{
        if options == nil </span><span class="cov8" title="1">{
                options = DefaultSolverOptions()
        }</span>

        <span class="cov8" title="1">switch algorithm </span>{
        case MinCostAlgorithmCapacityScaling:<span class="cov8" title="1">
                return CapacityScalingMinCostFlowWithContext(ctx, g, source, sink, requiredFlow, options)</span>
        default:<span class="cov8" title="1">
                return SuccessiveShortestPathInternal(ctx, g, source, sink, requiredFlow, options)</span>
        }
}

// =============================================================================
// Successive Shortest Path Implementation
// =============================================================================

// SuccessiveShortestPathInternal implements the SSP algorithm with Johnson's
// potential technique for handling negative edge costs.
//
// Algorithm Overview:
//  1. Initialize potentials using Bellman-Ford from source (handles negative costs)
//  2. While flow &lt; required and path exists:
//     a. Find shortest path using Dijkstra with reduced costs
//     b. Update potentials: π(v) += d(v)
//     c. Find bottleneck capacity and augment flow
//  3. Periodically reinitialize potentials for numerical stability
//
// Time Complexity: O(V*E + V*E*log(V) * F) where F = number of augmenting paths
// Space Complexity: O(V + E)
//
// The algorithm maintains the invariant that reduced costs c'(u,v) = c(u,v) + π(u) - π(v)
// are non-negative for all edges with positive residual capacity. This allows using
// Dijkstra's algorithm instead of Bellman-Ford for finding shortest paths.
func SuccessiveShortestPathInternal(ctx context.Context, g *graph.ResidualGraph, source, sink int64, requiredFlow float64, options *SolverOptions) *MinCostFlowResult <span class="cov8" title="1">{
        if options == nil </span><span class="cov0" title="0">{
                options = DefaultSolverOptions()
        }</span>

        // Get sorted nodes for deterministic iteration
        <span class="cov8" title="1">nodes := g.GetSortedNodes()

        totalFlow := 0.0
        totalCost := 0.0
        iterations := 0
        var paths []converter.PathWithFlow

        // Initialize potentials to zero for all nodes
        potentials := make(map[int64]float64, len(nodes))
        for _, node := range nodes </span><span class="cov8" title="1">{
                potentials[node] = 0
        }</span>

        // Compute initial potentials using Bellman-Ford
        // This handles any negative edge costs in the original graph
        <span class="cov8" title="1">initResult := BellmanFordWithContext(ctx, g, source)
        if initResult.Canceled </span><span class="cov8" title="1">{
                return &amp;MinCostFlowResult{Canceled: true}
        }</span>

        // If graph has negative cycles, min-cost flow is undefined
        <span class="cov8" title="1">if initResult.HasNegativeCycle </span><span class="cov0" title="0">{
                return &amp;MinCostFlowResult{}
        }</span>

        // Set initial potentials from Bellman-Ford distances
        <span class="cov8" title="1">for _, node := range nodes </span><span class="cov8" title="1">{
                if initResult.Distances[node] &lt; graph.Infinity-graph.Epsilon </span><span class="cov8" title="1">{
                        potentials[node] = initResult.Distances[node]
                }</span>
        }

        // Frequency of context cancellation checks
        <span class="cov8" title="1">checkInterval := 50

        // Adaptive reinitializaiton interval for numerical stability
        // Larger graphs need less frequent reinitialization relative to their size
        reinitInterval := computeReinitInterval(len(nodes))

        // Track if we should use the initial BF result for the first path
        useInitialResult := true

        // Main SSP loop
        for totalFlow &lt; requiredFlow-options.Epsilon </span><span class="cov8" title="1">{
                // Check iteration limit
                if options.MaxIterations &gt; 0 &amp;&amp; iterations &gt;= options.MaxIterations </span><span class="cov8" title="1">{
                        break</span>
                }

                // Periodic context cancellation check
                <span class="cov8" title="1">if iterations%checkInterval == 0 </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return &amp;MinCostFlowResult{
                                        Flow:       totalFlow,
                                        Cost:       totalCost,
                                        Iterations: iterations,
                                        Paths:      paths,
                                        Canceled:   true,
                                }</span>
                        default:<span class="cov8" title="1"></span>
                        }
                }

                <span class="cov8" title="1">var spResult ShortestPathResult
                var shouldUpdatePotentials bool

                // Periodic full reinitialization for numerical stability
                // Over many iterations, floating-point errors can accumulate in potentials
                if iterations &gt; 0 &amp;&amp; iterations%reinitInterval == 0 </span><span class="cov0" title="0">{
                        bfResult := BellmanFordWithContext(ctx, g, source)
                        if bfResult.Canceled </span><span class="cov0" title="0">{
                                return &amp;MinCostFlowResult{
                                        Flow:       totalFlow,
                                        Cost:       totalCost,
                                        Iterations: iterations,
                                        Paths:      paths,
                                        Canceled:   true,
                                }
                        }</span>
                        <span class="cov0" title="0">if bfResult.HasNegativeCycle </span><span class="cov0" title="0">{
                                // This shouldn't happen if the algorithm is correct
                                break</span>
                        }

                        // Complete potential reset
                        <span class="cov0" title="0">for _, node := range nodes </span><span class="cov0" title="0">{
                                if bfResult.Distances[node] &lt; graph.Infinity-graph.Epsilon </span><span class="cov0" title="0">{
                                        potentials[node] = bfResult.Distances[node]
                                }</span>
                        }
                        <span class="cov0" title="0">spResult = bfResult
                        shouldUpdatePotentials = false</span>
                } else<span class="cov8" title="1"> if useInitialResult </span><span class="cov8" title="1">{
                        // Reuse the initial Bellman-Ford result for the first iteration
                        spResult = initResult
                        shouldUpdatePotentials = false
                        useInitialResult = false
                }</span> else<span class="cov8" title="1"> {
                        // Normal case: use Dijkstra with potentials
                        dijkstraResult := DijkstraWithPotentialsContext(ctx, g, source, potentials)
                        if dijkstraResult.Canceled </span><span class="cov8" title="1">{
                                return &amp;MinCostFlowResult{
                                        Flow:       totalFlow,
                                        Cost:       totalCost,
                                        Iterations: iterations,
                                        Paths:      paths,
                                        Canceled:   true,
                                }
                        }</span>
                        <span class="cov8" title="1">spResult = dijkstraResult
                        shouldUpdatePotentials = true</span>
                }

                <span class="cov8" title="1">distances := spResult.GetDistances()
                parent := spResult.GetParent()

                // No path to sink - flow is maximized
                if distances[sink] &gt;= graph.Infinity-options.Epsilon </span><span class="cov8" title="1">{
                        break</span>
                }

                // Update potentials based on new distances
                <span class="cov8" title="1">if shouldUpdatePotentials </span><span class="cov8" title="1">{
                        for _, node := range nodes </span><span class="cov8" title="1">{
                                if distances[node] &lt; graph.Infinity-graph.Epsilon </span><span class="cov8" title="1">{
                                        potentials[node] += distances[node]
                                }</span>
                        }
                }

                // Reconstruct shortest path
                <span class="cov8" title="1">path := graph.ReconstructPath(parent, source, sink)
                if len(path) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                // Find bottleneck capacity
                <span class="cov8" title="1">pathFlow := requiredFlow - totalFlow
                bottleneck := graph.FindMinCapacityOnPath(g, path)
                if bottleneck &lt; pathFlow </span><span class="cov8" title="1">{
                        pathFlow = bottleneck
                }</span>

                <span class="cov8" title="1">if pathFlow &lt;= options.Epsilon </span><span class="cov0" title="0">{
                        break</span>
                }

                // Compute path cost before augmentation (costs are on original edges)
                <span class="cov8" title="1">pathCost := computePathCost(g, path, pathFlow)

                // Augment flow along the path
                graph.AugmentPath(g, path, pathFlow)

                totalFlow += pathFlow
                totalCost += pathCost
                iterations++

                // Record path if requested
                if options.ReturnPaths </span><span class="cov8" title="1">{
                        pathCopy := make([]int64, len(path))
                        copy(pathCopy, path)
                        paths = append(paths, converter.PathWithFlow{
                                NodeIDs: pathCopy,
                                Flow:    pathFlow,
                        })
                }</span>
        }

        <span class="cov8" title="1">return &amp;MinCostFlowResult{
                Flow:       totalFlow,
                Cost:       totalCost,
                Iterations: iterations,
                Paths:      paths,
                Canceled:   false,
        }</span>
}

// =============================================================================
// Bellman-Ford Based Implementation
// =============================================================================

// MinCostFlowBellmanFord implements min-cost flow using only Bellman-Ford
// for shortest path computations (no Dijkstra, no potentials).
//
// This is slower than the potentials-based version but is simpler and can
// handle any graph structure including those with negative cycles (which it
// will detect and abort).
//
// Use this when:
//   - Graph structure changes between iterations
//   - Debugging potential-related issues
//   - Educational purposes
//
// Time Complexity: O(V * E * F) where F = number of augmenting paths
func MinCostFlowBellmanFord(g *graph.ResidualGraph, source, sink int64, requiredFlow float64, options *SolverOptions) *MinCostFlowResult <span class="cov8" title="1">{
        return MinCostFlowBellmanFordWithContext(context.Background(), g, source, sink, requiredFlow, options)
}</span>

// MinCostFlowBellmanFordWithContext is the context-aware version.
func MinCostFlowBellmanFordWithContext(ctx context.Context, g *graph.ResidualGraph, source, sink int64, requiredFlow float64, options *SolverOptions) *MinCostFlowResult <span class="cov8" title="1">{
        if options == nil </span><span class="cov8" title="1">{
                options = DefaultSolverOptions()
        }</span>

        <span class="cov8" title="1">totalFlow := 0.0
        totalCost := 0.0
        iterations := 0
        var paths []converter.PathWithFlow

        checkInterval := 50

        for totalFlow &lt; requiredFlow-options.Epsilon </span><span class="cov8" title="1">{
                if options.MaxIterations &gt; 0 &amp;&amp; iterations &gt;= options.MaxIterations </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">if iterations%checkInterval == 0 </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov8" title="1">
                                return &amp;MinCostFlowResult{
                                        Flow:       totalFlow,
                                        Cost:       totalCost,
                                        Iterations: iterations,
                                        Paths:      paths,
                                        Canceled:   true,
                                }</span>
                        default:<span class="cov8" title="1"></span>
                        }
                }

                // Run full Bellman-Ford each iteration
                <span class="cov8" title="1">bfResult := BellmanFordWithContext(ctx, g, source)
                if bfResult.Canceled </span><span class="cov0" title="0">{
                        return &amp;MinCostFlowResult{
                                Flow:       totalFlow,
                                Cost:       totalCost,
                                Iterations: iterations,
                                Paths:      paths,
                                Canceled:   true,
                        }
                }</span>

                // Negative cycle detected - abort
                <span class="cov8" title="1">if bfResult.HasNegativeCycle </span><span class="cov0" title="0">{
                        break</span>
                }

                // No path to sink
                <span class="cov8" title="1">if bfResult.Distances[sink] &gt;= graph.Infinity-options.Epsilon </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">path := graph.ReconstructPath(bfResult.Parent, source, sink)
                if len(path) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">pathFlow := requiredFlow - totalFlow
                bottleneck := graph.FindMinCapacityOnPath(g, path)
                if bottleneck &lt; pathFlow </span><span class="cov8" title="1">{
                        pathFlow = bottleneck
                }</span>

                <span class="cov8" title="1">if pathFlow &lt;= options.Epsilon </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">pathCost := computePathCost(g, path, pathFlow)
                graph.AugmentPath(g, path, pathFlow)

                totalFlow += pathFlow
                totalCost += pathCost
                iterations++

                if options.ReturnPaths </span><span class="cov8" title="1">{
                        pathCopy := make([]int64, len(path))
                        copy(pathCopy, path)
                        paths = append(paths, converter.PathWithFlow{
                                NodeIDs: pathCopy,
                                Flow:    pathFlow,
                        })
                }</span>
        }

        <span class="cov8" title="1">return &amp;MinCostFlowResult{
                Flow:       totalFlow,
                Cost:       totalCost,
                Iterations: iterations,
                Paths:      paths,
                Canceled:   false,
        }</span>
}

// =============================================================================
// Helper Functions
// =============================================================================

// computePathCost calculates the total cost of pushing a given flow along a path.
// Cost = sum of (edge.Cost * flow) for all edges in the path.
func computePathCost(g *graph.ResidualGraph, path []int64, flow float64) float64 <span class="cov8" title="1">{
        cost := 0.0
        for i := 0; i &lt; len(path)-1; i++ </span><span class="cov8" title="1">{
                edge := g.GetEdge(path[i], path[i+1])
                if edge != nil </span><span class="cov8" title="1">{
                        cost += edge.Cost * flow
                }</span>
        }
        <span class="cov8" title="1">return cost</span>
}

// computeReinitInterval determines how often to reinitialize potentials
// using Bellman-Ford for numerical stability.
//
// The interval is adaptive based on graph size:
//   - Small graphs (&lt; 50 nodes): every 100 iterations
//   - Medium graphs (50-500 nodes): every 200 iterations
//   - Large graphs (&gt; 500 nodes): every 500 iterations
//
// This balances numerical stability against the overhead of Bellman-Ford.
func computeReinitInterval(nodeCount int) int <span class="cov8" title="1">{
        switch </span>{
        case nodeCount &lt; 50:<span class="cov8" title="1">
                return 100</span>
        case nodeCount &lt; 500:<span class="cov8" title="1">
                return 200</span>
        default:<span class="cov8" title="1">
                return 500</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package algorithms

import (
        "container/heap"
        "context"

        "logistics/services/solver-svc/internal/graph"
)

// =============================================================================
// Push-Relabel Algorithm (Preflow-Push)
// =============================================================================
//
// The Push-Relabel algorithm (also known as Preflow-Push) computes maximum flow
// by maintaining a preflow and gradually converting it to a valid flow.
// Unlike augmenting path methods, it works locally on vertices.
//
// Time Complexity:
//   - FIFO variant: O(V³)
//   - Highest Label variant: O(V² √E)
//   - Lowest Label variant: O(V² E)
//
// Space Complexity: O(V + E)
//
// Key Concepts:
//   - Preflow: Allows excess flow at vertices (more inflow than outflow)
//   - Height function: Labels vertices; flow only goes from higher to lower
//   - Push: Moves excess flow to lower neighbors
//   - Relabel: Increases height when no valid push is possible
//
// Optimizations Implemented:
//   - Gap heuristic: When a height has no vertices, cut off higher vertices
//   - Global relabeling: Periodically recompute heights via BFS from sink
//   - Current arc optimization: Skip recently saturated edges
//   - Highest/Lowest label selection: Better vertex selection strategies
//
// This implementation provides three variants:
//   - PushRelabel: FIFO vertex selection
//   - PushRelabelHighestLabel: Highest active vertex first
//   - PushRelabelLowestLabel: Lowest active vertex first
//
// References:
//   - Goldberg, A.V. &amp; Tarjan, R.E. (1988). "A new approach to the maximum-flow problem"
//   - Cherkassky, B.V. &amp; Goldberg, A.V. (1997). "On implementing push-relabel method
//     for the maximum flow problem"
// =============================================================================

// PushRelabelResult contains the result of the Push-Relabel algorithm.
type PushRelabelResult struct {
        // MaxFlow is the maximum flow value computed.
        MaxFlow float64

        // Iterations is the number of push/relabel operations performed.
        Iterations int

        // Canceled indicates whether the operation was canceled via context.
        Canceled bool
}

// =============================================================================
// Data Structures
// =============================================================================

// prNode represents a vertex entry in the priority queue with versioning
// to handle stale entries efficiently.
type prNode struct {
        id      int64
        height  int
        version int
}

// maxHeap implements a max-heap for Highest Label vertex selection.
// Uses versioning to efficiently handle height updates without removal.
type maxHeap struct {
        items       []prNode
        nodeVersion map[int64]int // Current version of each node
}

func newMaxHeap(capacity int) *maxHeap <span class="cov8" title="1">{
        return &amp;maxHeap{
                items:       make([]prNode, 0, capacity),
                nodeVersion: make(map[int64]int, capacity),
        }
}</span>

func (h *maxHeap) Len() int           <span class="cov8" title="1">{ return len(h.items) }</span>
func (h *maxHeap) Less(i, j int) bool <span class="cov8" title="1">{ return h.items[i].height &gt; h.items[j].height }</span>
func (h *maxHeap) Swap(i, j int)      <span class="cov8" title="1">{ h.items[i], h.items[j] = h.items[j], h.items[i] }</span>

func (h *maxHeap) Push(x any) <span class="cov8" title="1">{
        h.items = append(h.items, x.(prNode))
}</span>

func (h *maxHeap) Pop() any <span class="cov8" title="1">{
        old := h.items
        n := len(old)
        item := old[n-1]
        h.items = old[0 : n-1]
        return item
}</span>

// push adds a vertex to the heap with a new version.
func (h *maxHeap) push(id int64, height int) <span class="cov8" title="1">{
        h.nodeVersion[id]++
        heap.Push(h, prNode{id: id, height: height, version: h.nodeVersion[id]})
}</span>

// pop extracts a vertex, skipping stale entries.
func (h *maxHeap) pop() (int64, bool) <span class="cov8" title="1">{
        for h.Len() &gt; 0 </span><span class="cov8" title="1">{
                item := heap.Pop(h).(prNode)
                // Check if this entry is still valid
                if item.version == h.nodeVersion[item.id] </span><span class="cov8" title="1">{
                        return item.id, true
                }</span>
                // Stale entry - skip
        }
        <span class="cov8" title="1">return 0, false</span>
}

// =============================================================================
// Algorithm State
// =============================================================================

// pushRelabelState holds the mutable state during algorithm execution.
type pushRelabelState struct {
        g       *graph.ResidualGraph
        source  int64
        sink    int64
        n       int
        nodes   []int64       // Deterministic node ordering
        nodeIdx map[int64]int // Node ID to index mapping

        height      []int     // height[nodeIdx[v]]
        excess      []float64 // excess[nodeIdx[v]]
        heightCount []int     // Number of vertices at each height

        maxHeight int
        epsilon   float64

        // Current arc optimization
        currentArc []int // Index of next edge to try for each vertex
}

// newPushRelabelState initializes the algorithm state.
func newPushRelabelState(g *graph.ResidualGraph, source, sink int64, options *SolverOptions) *pushRelabelState <span class="cov8" title="1">{
        nodes := g.GetSortedNodes()
        n := len(nodes)

        nodeIdx := make(map[int64]int, n)
        for i, node := range nodes </span><span class="cov8" title="1">{
                nodeIdx[node] = i
        }</span>

        <span class="cov8" title="1">return &amp;pushRelabelState{
                g:           g,
                source:      source,
                sink:        sink,
                n:           n,
                nodes:       nodes,
                nodeIdx:     nodeIdx,
                height:      make([]int, n),
                excess:      make([]float64, n),
                heightCount: make([]int, 2*n+1),
                currentArc:  make([]int, n),
                maxHeight:   2*n - 1,
                epsilon:     options.Epsilon,
        }</span>
}

// Height/excess accessors for cleaner code
func (s *pushRelabelState) getHeight(node int64) int            <span class="cov8" title="1">{ return s.height[s.nodeIdx[node]] }</span>
func (s *pushRelabelState) setHeight(node int64, h int)         <span class="cov8" title="1">{ s.height[s.nodeIdx[node]] = h }</span>
func (s *pushRelabelState) getExcess(node int64) float64        <span class="cov8" title="1">{ return s.excess[s.nodeIdx[node]] }</span>
func (s *pushRelabelState) addExcess(node int64, delta float64) <span class="cov8" title="1">{ s.excess[s.nodeIdx[node]] += delta }</span>
func (s *pushRelabelState) getCurrentArc(node int64) int        <span class="cov8" title="1">{ return s.currentArc[s.nodeIdx[node]] }</span>
func (s *pushRelabelState) setCurrentArc(node int64, arc int)   <span class="cov8" title="1">{ s.currentArc[s.nodeIdx[node]] = arc }</span>

// =============================================================================
// Push-Relabel FIFO Variant
// =============================================================================

// PushRelabel executes the Push-Relabel algorithm with FIFO vertex selection.
//
// Parameters:
//   - g: The residual graph (will be modified)
//   - source: The source node ID
//   - sink: The sink node ID
//   - options: Solver options
//
// Returns:
//   - *PushRelabelResult containing max flow and iteration count
func PushRelabel(g *graph.ResidualGraph, source, sink int64, options *SolverOptions) *PushRelabelResult <span class="cov8" title="1">{
        return PushRelabelWithContext(context.Background(), g, source, sink, options)
}</span>

// PushRelabelWithContext executes Push-Relabel with context cancellation.
func PushRelabelWithContext(ctx context.Context, g *graph.ResidualGraph, source, sink int64, options *SolverOptions) *PushRelabelResult <span class="cov8" title="1">{
        if options == nil </span><span class="cov8" title="1">{
                options = DefaultSolverOptions()
        }</span>

        <span class="cov8" title="1">if len(g.Nodes) == 0 </span><span class="cov0" title="0">{
                return &amp;PushRelabelResult{MaxFlow: 0, Iterations: 0}
        }</span>

        <span class="cov8" title="1">state := newPushRelabelState(g, source, sink, options)
        state.initialize()

        // FIFO queue of active vertices
        queue := make([]int64, 0, state.n)
        inQueue := make(map[int64]bool, state.n)

        // Add initially active vertices
        for _, node := range state.nodes </span><span class="cov8" title="1">{
                if node != source &amp;&amp; node != sink &amp;&amp; state.getExcess(node) &gt; state.epsilon </span><span class="cov8" title="1">{
                        queue = append(queue, node)
                        inQueue[node] = true
                }</span>
        }

        <span class="cov8" title="1">iterations := 0
        globalRelabelFreq := state.n
        const checkInterval = 100

        for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                if options.MaxIterations &gt; 0 &amp;&amp; iterations &gt;= options.MaxIterations </span><span class="cov8" title="1">{
                        break</span>
                }

                // Context check
                <span class="cov8" title="1">if iterations%checkInterval == 0 </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov8" title="1">
                                return &amp;PushRelabelResult{
                                        MaxFlow:    state.getExcess(sink),
                                        Iterations: iterations,
                                        Canceled:   true,
                                }</span>
                        default:<span class="cov8" title="1"></span>
                        }
                }

                // Periodic global relabeling
                <span class="cov8" title="1">if iterations &gt; 0 &amp;&amp; iterations%globalRelabelFreq == 0 </span><span class="cov0" title="0">{
                        state.globalRelabel()
                        // Rebuild queue
                        queue = queue[:0]
                        for k := range inQueue </span><span class="cov0" title="0">{
                                delete(inQueue, k)
                        }</span>
                        <span class="cov0" title="0">for _, node := range state.nodes </span><span class="cov0" title="0">{
                                if node != source &amp;&amp; node != sink </span><span class="cov0" title="0">{
                                        if state.getExcess(node) &gt; state.epsilon &amp;&amp; state.getHeight(node) &lt;= state.maxHeight </span><span class="cov0" title="0">{
                                                queue = append(queue, node)
                                                inQueue[node] = true
                                        }</span>
                                }
                        }
                        // Check if queue became empty after rebuild
                        <span class="cov0" title="0">if len(queue) == 0 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }

                // Pop vertex from queue
                <span class="cov8" title="1">u := queue[0]
                queue = queue[1:]
                delete(inQueue, u)

                // Discharge the vertex
                state.discharge(u, func(v int64) </span><span class="cov8" title="1">{
                        if v != source &amp;&amp; v != sink &amp;&amp; !inQueue[v] &amp;&amp; state.getExcess(v) &gt; state.epsilon </span><span class="cov8" title="1">{
                                queue = append(queue, v)
                                inQueue[v] = true
                        }</span>
                })

                // Re-add if still active
                <span class="cov8" title="1">if state.getExcess(u) &gt; state.epsilon &amp;&amp; state.getHeight(u) &lt;= state.maxHeight </span><span class="cov0" title="0">{
                        if !inQueue[u] </span><span class="cov0" title="0">{
                                queue = append(queue, u)
                                inQueue[u] = true
                        }</span>
                }

                <span class="cov8" title="1">iterations++</span>
        }

        <span class="cov8" title="1">return &amp;PushRelabelResult{
                MaxFlow:    state.getExcess(sink),
                Iterations: iterations,
                Canceled:   false,
        }</span>
}

// =============================================================================
// Push-Relabel Highest Label Variant
// =============================================================================

// PushRelabelHighestLabel executes Push-Relabel with Highest Label selection.
// This variant achieves O(V² √E) time complexity.
//
// Parameters:
//   - g: The residual graph (will be modified)
//   - source: The source node ID
//   - sink: The sink node ID
//   - options: Solver options
//
// Returns:
//   - *PushRelabelResult containing max flow and iteration count
func PushRelabelHighestLabel(g *graph.ResidualGraph, source, sink int64, options *SolverOptions) *PushRelabelResult <span class="cov8" title="1">{
        return PushRelabelHighestLabelWithContext(context.Background(), g, source, sink, options)
}</span>

// PushRelabelHighestLabelWithContext is the context-aware Highest Label variant.
func PushRelabelHighestLabelWithContext(ctx context.Context, g *graph.ResidualGraph, source, sink int64, options *SolverOptions) *PushRelabelResult <span class="cov8" title="1">{
        if options == nil </span><span class="cov8" title="1">{
                options = DefaultSolverOptions()
        }</span>

        <span class="cov8" title="1">if len(g.Nodes) == 0 </span><span class="cov8" title="1">{
                return &amp;PushRelabelResult{MaxFlow: 0, Iterations: 0}
        }</span>

        <span class="cov8" title="1">state := newPushRelabelState(g, source, sink, options)
        state.initialize()

        // Max-heap with versioning for efficient updates
        activeHeap := newMaxHeap(state.n)

        // Add initially active vertices
        for _, node := range state.nodes </span><span class="cov8" title="1">{
                if node != source &amp;&amp; node != sink &amp;&amp; state.getExcess(node) &gt; state.epsilon </span><span class="cov8" title="1">{
                        activeHeap.push(node, state.getHeight(node))
                }</span>
        }

        <span class="cov8" title="1">iterations := 0
        globalRelabelFreq := state.n
        const checkInterval = 100

        for activeHeap.Len() &gt; 0 </span><span class="cov8" title="1">{
                if options.MaxIterations &gt; 0 &amp;&amp; iterations &gt;= options.MaxIterations </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">if iterations%checkInterval == 0 </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov8" title="1">
                                return &amp;PushRelabelResult{
                                        MaxFlow:    state.getExcess(sink),
                                        Iterations: iterations,
                                        Canceled:   true,
                                }</span>
                        default:<span class="cov8" title="1"></span>
                        }
                        <span class="cov8" title="1">if activeHeap.Len() == 0 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }

                // Periodic global relabeling
                <span class="cov8" title="1">if iterations &gt; 0 &amp;&amp; iterations%globalRelabelFreq == 0 </span><span class="cov0" title="0">{
                        state.globalRelabel()
                        // Rebuild heap
                        activeHeap = newMaxHeap(state.n)
                        for _, node := range state.nodes </span><span class="cov0" title="0">{
                                if node != source &amp;&amp; node != sink </span><span class="cov0" title="0">{
                                        if state.getExcess(node) &gt; state.epsilon &amp;&amp; state.getHeight(node) &lt;= state.maxHeight </span><span class="cov0" title="0">{
                                                activeHeap.push(node, state.getHeight(node))
                                        }</span>
                                }
                        }
                }

                // Get highest active vertex
                <span class="cov8" title="1">u, ok := activeHeap.pop()
                if !ok </span><span class="cov0" title="0">{
                        break</span>
                }

                // Skip if no longer active
                <span class="cov8" title="1">if state.getExcess(u) &lt;= state.epsilon || state.getHeight(u) &gt; state.maxHeight </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Discharge
                <span class="cov8" title="1">state.discharge(u, func(v int64) </span><span class="cov8" title="1">{
                        if v != source &amp;&amp; v != sink &amp;&amp; state.getExcess(v) &gt; state.epsilon </span><span class="cov8" title="1">{
                                activeHeap.push(v, state.getHeight(v))
                        }</span>
                })

                // Re-add if still active
                <span class="cov8" title="1">if state.getExcess(u) &gt; state.epsilon &amp;&amp; state.getHeight(u) &lt;= state.maxHeight </span><span class="cov0" title="0">{
                        activeHeap.push(u, state.getHeight(u))
                }</span>

                <span class="cov8" title="1">iterations++</span>
        }

        <span class="cov8" title="1">return &amp;PushRelabelResult{
                MaxFlow:    state.getExcess(sink),
                Iterations: iterations,
                Canceled:   false,
        }</span>
}

// =============================================================================
// Push-Relabel Lowest Label Variant
// =============================================================================

// PushRelabelLowestLabel executes Push-Relabel with Lowest Label selection.
//
// Parameters:
//   - g: The residual graph (will be modified)
//   - source: The source node ID
//   - sink: The sink node ID
//   - options: Solver options
//
// Returns:
//   - *PushRelabelResult containing max flow and iteration count
func PushRelabelLowestLabel(g *graph.ResidualGraph, source, sink int64, options *SolverOptions) *PushRelabelResult <span class="cov8" title="1">{
        return PushRelabelLowestLabelWithContext(context.Background(), g, source, sink, options)
}</span>

// PushRelabelLowestLabelWithContext is the context-aware Lowest Label variant.
func PushRelabelLowestLabelWithContext(ctx context.Context, g *graph.ResidualGraph, source, sink int64, options *SolverOptions) *PushRelabelResult <span class="cov8" title="1">{
        if options == nil </span><span class="cov8" title="1">{
                options = DefaultSolverOptions()
        }</span>

        <span class="cov8" title="1">if len(g.Nodes) == 0 </span><span class="cov8" title="1">{
                return &amp;PushRelabelResult{MaxFlow: 0, Iterations: 0}
        }</span>

        <span class="cov8" title="1">state := newPushRelabelState(g, source, sink, options)
        state.initialize()

        // Bucket-based structure for each height level
        buckets := make([][]int64, 2*state.n+1)
        for i := range buckets </span><span class="cov8" title="1">{
                buckets[i] = make([]int64, 0)
        }</span>

        <span class="cov8" title="1">inBucket := make(map[int64]bool, state.n)
        minActiveHeight := state.maxHeight + 1

        // Initialize buckets
        for _, node := range state.nodes </span><span class="cov8" title="1">{
                if node != source &amp;&amp; node != sink </span><span class="cov8" title="1">{
                        if state.getExcess(node) &gt; state.epsilon &amp;&amp; state.getHeight(node) &lt;= state.maxHeight </span><span class="cov8" title="1">{
                                h := state.getHeight(node)
                                buckets[h] = append(buckets[h], node)
                                inBucket[node] = true
                                if h &lt; minActiveHeight </span><span class="cov8" title="1">{
                                        minActiveHeight = h
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">iterations := 0
        globalRelabelFreq := state.n
        const checkInterval = 100

        for minActiveHeight &lt;= state.maxHeight </span><span class="cov8" title="1">{
                if options.MaxIterations &gt; 0 &amp;&amp; iterations &gt;= options.MaxIterations </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">if iterations%checkInterval == 0 </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov8" title="1">
                                return &amp;PushRelabelResult{
                                        MaxFlow:    state.getExcess(sink),
                                        Iterations: iterations,
                                        Canceled:   true,
                                }</span>
                        default:<span class="cov8" title="1"></span>
                        }
                }

                // Periodic global relabeling
                <span class="cov8" title="1">if iterations &gt; 0 &amp;&amp; iterations%globalRelabelFreq == 0 </span><span class="cov8" title="1">{
                        state.globalRelabel()
                        // Rebuild buckets
                        for i := range buckets </span><span class="cov8" title="1">{
                                buckets[i] = buckets[i][:0]
                        }</span>
                        <span class="cov8" title="1">if minActiveHeight &gt; state.maxHeight </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov8" title="1">for k := range inBucket </span><span class="cov0" title="0">{
                                delete(inBucket, k)
                        }</span>
                        <span class="cov8" title="1">minActiveHeight = state.maxHeight + 1

                        for _, node := range state.nodes </span><span class="cov8" title="1">{
                                if node != source &amp;&amp; node != sink </span><span class="cov8" title="1">{
                                        if state.getExcess(node) &gt; state.epsilon &amp;&amp; state.getHeight(node) &lt;= state.maxHeight </span><span class="cov0" title="0">{
                                                h := state.getHeight(node)
                                                buckets[h] = append(buckets[h], node)
                                                inBucket[node] = true
                                                if h &lt; minActiveHeight </span><span class="cov0" title="0">{
                                                        minActiveHeight = h
                                                }</span>
                                        }
                                }
                        }
                }

                // Find non-empty bucket with minimum height
                <span class="cov8" title="1">for minActiveHeight &lt;= state.maxHeight &amp;&amp; len(buckets[minActiveHeight]) == 0 </span><span class="cov8" title="1">{
                        minActiveHeight++
                }</span>

                <span class="cov8" title="1">if minActiveHeight &gt; state.maxHeight </span><span class="cov8" title="1">{
                        break</span>
                }

                // Extract vertex from bucket
                <span class="cov8" title="1">bucket := buckets[minActiveHeight]
                u := bucket[len(bucket)-1]
                buckets[minActiveHeight] = bucket[:len(bucket)-1]
                delete(inBucket, u)

                // Skip if no longer valid
                if state.getExcess(u) &lt;= state.epsilon || state.getHeight(u) != minActiveHeight </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Discharge
                <span class="cov8" title="1">state.discharge(u, func(v int64) </span><span class="cov8" title="1">{
                        if v != source &amp;&amp; v != sink &amp;&amp; !inBucket[v] </span><span class="cov8" title="1">{
                                if state.getExcess(v) &gt; state.epsilon &amp;&amp; state.getHeight(v) &lt;= state.maxHeight </span><span class="cov8" title="1">{
                                        h := state.getHeight(v)
                                        buckets[h] = append(buckets[h], v)
                                        inBucket[v] = true
                                        if h &lt; minActiveHeight </span><span class="cov8" title="1">{
                                                minActiveHeight = h
                                        }</span>
                                }
                        }
                })

                // Re-add if still active
                <span class="cov8" title="1">if state.getExcess(u) &gt; state.epsilon &amp;&amp; state.getHeight(u) &lt;= state.maxHeight </span><span class="cov0" title="0">{
                        if !inBucket[u] </span><span class="cov0" title="0">{
                                h := state.getHeight(u)
                                buckets[h] = append(buckets[h], u)
                                inBucket[u] = true
                        }</span>
                }

                <span class="cov8" title="1">iterations++</span>
        }

        <span class="cov8" title="1">return &amp;PushRelabelResult{
                MaxFlow:    state.getExcess(sink),
                Iterations: iterations,
                Canceled:   false,
        }</span>
}

// =============================================================================
// Core Operations
// =============================================================================

// initialize sets up the initial preflow and heights.
func (s *pushRelabelState) initialize() <span class="cov8" title="1">{
        // Initialize heights: source = n, others = 0
        for i := range s.height </span><span class="cov8" title="1">{
                s.height[i] = 0
        }</span>
        <span class="cov8" title="1">s.setHeight(s.source, s.n)

        // Count vertices at each height
        for i := range s.heightCount </span><span class="cov8" title="1">{
                s.heightCount[i] = 0
        }</span>
        <span class="cov8" title="1">for _, node := range s.nodes </span><span class="cov8" title="1">{
                h := s.getHeight(node)
                if h &lt;= s.maxHeight </span><span class="cov8" title="1">{
                        s.heightCount[h]++
                }</span>
        }

        // Initial push from source: saturate all outgoing edges
        <span class="cov8" title="1">edges := s.g.GetNeighborsList(s.source)
        for _, edge := range edges </span><span class="cov8" title="1">{
                if edge.Capacity &gt; s.epsilon </span><span class="cov8" title="1">{
                        flow := edge.Capacity
                        s.g.UpdateFlow(s.source, edge.To, flow)
                        s.addExcess(edge.To, flow)
                        s.addExcess(s.source, -flow)
                }</span>
        }

        // Global relabel for accurate initial heights
        <span class="cov8" title="1">s.globalRelabel()</span>
}

// globalRelabel recomputes heights using reverse BFS from sink.
// Uses deterministic ordering for reproducible results.
//
// The algorithm traverses the graph in reverse: for each node u, we find
// all nodes v that have an edge TO u with positive residual capacity.
// This means v can push flow to u, so height[v] = height[u] + 1.
//
// Implementation Note:
// GetIncomingEdgesList(u) returns edges where the edge goes FROM some node TO u.
// The Edge.Capacity is the capacity of that forward edge (from -&gt; u).
func (s *pushRelabelState) globalRelabel() <span class="cov8" title="1">{
        // Reset height counts
        for i := range s.heightCount </span><span class="cov8" title="1">{
                s.heightCount[i] = 0
        }</span>

        // Initialize new heights to maxHeight + 1 (unreachable)
        <span class="cov8" title="1">newHeight := make([]int, s.n)
        for i := range newHeight </span><span class="cov8" title="1">{
                newHeight[i] = s.maxHeight + 1
        }</span>
        <span class="cov8" title="1">newHeight[s.nodeIdx[s.sink]] = 0

        // BFS from sink using reverse edges
        queue := make([]int64, 0, s.n)
        queue = append(queue, s.sink)
        head := 0

        for head &lt; len(queue) </span><span class="cov8" title="1">{
                u := queue[head]
                head++

                uHeight := newHeight[s.nodeIdx[u]]

                // Get all edges that point TO u (i.e., edges v -&gt; u)
                // For each such edge, if it has capacity, then v can reach u
                incomingList := s.g.GetIncomingEdgesList(u)
                for _, incoming := range incomingList </span><span class="cov8" title="1">{
                        v := incoming.From
                        vIdx := s.nodeIdx[v]

                        // incoming.Edge represents the edge v -&gt; u
                        // If this edge has capacity, v can push flow to u
                        if newHeight[vIdx] &gt; s.maxHeight &amp;&amp; incoming.Edge.Capacity &gt; s.epsilon </span><span class="cov8" title="1">{
                                newHeight[vIdx] = uHeight + 1
                                queue = append(queue, v)
                        }</span>
                }
        }

        // Source always has height n
        <span class="cov8" title="1">newHeight[s.nodeIdx[s.source]] = s.n

        // Apply new heights
        for i, h := range newHeight </span><span class="cov8" title="1">{
                s.height[i] = h
                if h &lt;= s.maxHeight </span><span class="cov8" title="1">{
                        s.heightCount[h]++
                }</span>
        }

        // Reset current arcs
        <span class="cov8" title="1">for i := range s.currentArc </span><span class="cov8" title="1">{
                s.currentArc[i] = 0
        }</span>
}

// discharge processes a vertex until it has no excess or cannot push.
func (s *pushRelabelState) discharge(u int64, onActivate func(int64)) <span class="cov8" title="1">{
        edges := s.g.GetNeighborsList(u)
        if edges == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">for s.getExcess(u) &gt; s.epsilon &amp;&amp; s.getHeight(u) &lt;= s.maxHeight </span><span class="cov8" title="1">{
                currentArc := s.getCurrentArc(u)

                if currentArc &gt;= len(edges) </span><span class="cov8" title="1">{
                        if !s.relabel(u) </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">s.setCurrentArc(u, 0)
                        continue</span>
                }

                <span class="cov8" title="1">edge := edges[currentArc]
                v := edge.To

                if edge.Capacity &gt; s.epsilon &amp;&amp; s.getHeight(u) == s.getHeight(v)+1 </span><span class="cov8" title="1">{
                        delta := min(s.getExcess(u), edge.Capacity)
                        s.g.UpdateFlow(u, v, delta)
                        s.addExcess(u, -delta)
                        s.addExcess(v, delta)

                        if onActivate != nil </span><span class="cov8" title="1">{
                                onActivate(v)
                        }</span>
                } else<span class="cov8" title="1"> {
                        s.setCurrentArc(u, currentArc+1)
                }</span>
        }
}

// relabel increases the height of a vertex.
func (s *pushRelabelState) relabel(u int64) bool <span class="cov8" title="1">{
        oldHeight := s.getHeight(u)
        if oldHeight &gt; s.maxHeight </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">edges := s.g.GetNeighborsList(u)
        if edges == nil </span><span class="cov0" title="0">{
                s.heightCount[oldHeight]--
                s.setHeight(u, s.maxHeight+1)
                return false
        }</span>

        // Find minimum height among neighbors with residual capacity
        <span class="cov8" title="1">minHeight := s.maxHeight + 1
        for _, edge := range edges </span><span class="cov8" title="1">{
                if edge.Capacity &gt; s.epsilon </span><span class="cov8" title="1">{
                        h := s.getHeight(edge.To)
                        if h &lt; minHeight </span><span class="cov8" title="1">{
                                minHeight = h
                        }</span>
                }
        }

        <span class="cov8" title="1">if minHeight &gt;= s.maxHeight </span><span class="cov8" title="1">{
                s.heightCount[oldHeight]--
                s.setHeight(u, s.maxHeight+1)
                return false
        }</span>

        <span class="cov8" title="1">newHeight := minHeight + 1
        if newHeight &gt; s.maxHeight </span><span class="cov0" title="0">{
                s.heightCount[oldHeight]--
                s.setHeight(u, s.maxHeight+1)
                return false
        }</span>

        // Gap heuristic: if this height becomes empty, vertices above are unreachable
        <span class="cov8" title="1">s.heightCount[oldHeight]--
        if s.heightCount[oldHeight] == 0 &amp;&amp; oldHeight &lt; s.n </span><span class="cov8" title="1">{
                s.applyGapHeuristic(oldHeight)
        }</span>

        <span class="cov8" title="1">s.heightCount[newHeight]++
        s.setHeight(u, newHeight)

        return true</span>
}

// applyGapHeuristic raises all vertices above the gap to maxHeight + 1.
func (s *pushRelabelState) applyGapHeuristic(gapHeight int) <span class="cov8" title="1">{
        for i, node := range s.nodes </span><span class="cov8" title="1">{
                h := s.height[i]
                if h &gt; gapHeight &amp;&amp; h &lt;= s.maxHeight &amp;&amp; node != s.source </span><span class="cov8" title="1">{
                        s.heightCount[h]--
                        s.height[i] = s.maxHeight + 1
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package algorithms provides implementations of various network flow algorithms
// including max-flow algorithms (Ford-Fulkerson, Edmonds-Karp, Dinic, Push-Relabel)
// and min-cost max-flow algorithms (Successive Shortest Path, Capacity Scaling).
//
// # Thread Safety
//
// Individual algorithm functions are NOT thread-safe. Each goroutine should work
// with its own copy of the graph. Use ResidualGraph.Clone() or the SolverPool
// for concurrent operations.
//
// # Determinism
//
// All algorithms are designed to produce deterministic results when given the same
// input graph. This is achieved by iterating over nodes and edges in sorted order.
//
// # Context Support
//
// All algorithms support context cancellation for timeout and graceful shutdown.
// The XxxWithContext variants should be preferred for production use.
//
// # Example Usage
//
//        g := graph.NewResidualGraph()
//        g.AddEdgeWithReverse(1, 2, 10, 0)
//        g.AddEdgeWithReverse(2, 3, 5, 0)
//
//        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
//        defer cancel()
//
//        result := algorithms.Solve(ctx, g, 1, 3, commonv1.Algorithm_ALGORITHM_DINIC, nil)
//        if result.Error != nil {
//            log.Printf("Error: %v", result.Error)
//        } else {
//            log.Printf("Max flow: %f", result.MaxFlow)
//        }
package algorithms

import (
        "context"
        "errors"
        "fmt"
        "math"
        "sync"
        "time"

        commonv1 "logistics/gen/go/logistics/common/v1"
        "logistics/services/solver-svc/internal/converter"
        "logistics/services/solver-svc/internal/graph"
)

// =============================================================================
// Error Definitions
// =============================================================================

// Standard errors returned by solver operations.
// These errors can be checked using errors.Is() for robust error handling.
var (
        // ErrNilGraph indicates that a nil graph was passed to a solver function.
        ErrNilGraph = errors.New("graph is nil")

        // ErrSourceNotFound indicates that the source node does not exist in the graph.
        ErrSourceNotFound = errors.New("source node not in graph")

        // ErrSinkNotFound indicates that the sink node does not exist in the graph.
        ErrSinkNotFound = errors.New("sink node not in graph")

        // ErrSourceEqualSink indicates that source and sink are the same node.
        ErrSourceEqualSink = errors.New("source equals sink")

        // ErrContextCanceled indicates that the operation was cancelled via context.
        ErrContextCanceled = errors.New("context canceled")

        // ErrTimeout indicates that the operation exceeded the configured timeout.
        ErrTimeout = errors.New("operation timeout")
)

// =============================================================================
// Solver Options
// =============================================================================

// SolverOptions configures the behavior of flow algorithms.
//
// Zero values are safe to use - DefaultSolverOptions() will be applied.
// Options can be chained using the builder pattern:
//
//        opts := DefaultSolverOptions().
//            WithTimeout(10 * time.Second).
//            WithPool(customPool)
type SolverOptions struct {
        // Epsilon is the tolerance for floating-point comparisons.
        // Values smaller than Epsilon are considered zero.
        // Default: graph.Epsilon (1e-9)
        Epsilon float64

        // MaxIterations limits the number of augmenting path iterations.
        // Zero or negative means unlimited.
        // Default: 0 (unlimited)
        MaxIterations int

        // Timeout sets the maximum duration for the algorithm.
        // Zero means no timeout (relies on context).
        // Default: 30 seconds
        Timeout time.Duration

        // ReturnPaths indicates whether to collect and return individual flow paths.
        // Enabling this increases memory usage proportional to the number of paths.
        // Default: false
        ReturnPaths bool

        // NegativeEdgeFallbackThreshold sets the number of negative reduced cost edges
        // encountered before falling back from Dijkstra to Bellman-Ford.
        // Default: 3
        NegativeEdgeFallbackThreshold int

        // Pool is the graph pool for memory reuse.
        // If nil, the global pool is used.
        Pool *graph.GraphPool

        // Resources holds pooled resources for this request.
        // Typically managed internally.
        Resources *graph.PooledResources
}

// DefaultSolverOptions returns options with sensible defaults for most use cases.
//
// Default values:
//   - Epsilon: 1e-9
//   - MaxIterations: unlimited
//   - Timeout: 30 seconds
//   - ReturnPaths: false
//   - NegativeEdgeFallbackThreshold: 3
func DefaultSolverOptions() *SolverOptions <span class="cov8" title="1">{
        return &amp;SolverOptions{
                Epsilon:                       graph.Epsilon,
                MaxIterations:                 0,
                Timeout:                       30 * time.Second,
                ReturnPaths:                   false,
                NegativeEdgeFallbackThreshold: 3,
                Pool:                          graph.GetPool(),
        }
}</span>

// WithPool sets the graph pool and returns the options for chaining.
func (o *SolverOptions) WithPool(pool *graph.GraphPool) *SolverOptions <span class="cov8" title="1">{
        o.Pool = pool
        return o
}</span>

// WithTimeout sets the timeout and returns the options for chaining.
func (o *SolverOptions) WithTimeout(timeout time.Duration) *SolverOptions <span class="cov8" title="1">{
        o.Timeout = timeout
        return o
}</span>

// WithReturnPaths enables path collection and returns the options for chaining.
func (o *SolverOptions) WithReturnPaths(returnPaths bool) *SolverOptions <span class="cov8" title="1">{
        o.ReturnPaths = returnPaths
        return o
}</span>

// WithMaxIterations sets the iteration limit and returns the options for chaining.
func (o *SolverOptions) WithMaxIterations(max int) *SolverOptions <span class="cov8" title="1">{
        o.MaxIterations = max
        return o
}</span>

// =============================================================================
// Solver Result
// =============================================================================

// SolverResult contains the complete result of a flow computation.
//
// Check Status and Error first to determine if the result is valid:
//
//        result := Solve(ctx, g, source, sink, algo, opts)
//        if result.Status != commonv1.FlowStatus_FLOW_STATUS_OPTIMAL {
//            log.Printf("Failed: %v", result.Error)
//            return
//        }
//        log.Printf("Max flow: %f, Cost: %f", result.MaxFlow, result.TotalCost)
type SolverResult struct {
        // MaxFlow is the maximum flow value found.
        MaxFlow float64

        // TotalCost is the total cost of the flow (for min-cost algorithms).
        TotalCost float64

        // Iterations is the number of augmenting path iterations performed.
        Iterations int

        // Paths contains individual flow paths if ReturnPaths was enabled.
        // Each path includes the sequence of node IDs and the flow amount.
        Paths []converter.PathWithFlow

        // Status indicates the outcome of the computation.
        Status commonv1.FlowStatus

        // Error contains any error that occurred during computation.
        // nil if Status is FLOW_STATUS_OPTIMAL.
        Error error

        // Duration is the wall-clock time taken by the algorithm.
        Duration time.Duration
}

// =============================================================================
// Validation
// =============================================================================

// validateGraph performs basic validation of the graph and source/sink nodes.
//
// Returns nil if the graph is valid, or a descriptive error otherwise.
// The error wraps one of the standard errors (ErrNilGraph, ErrSourceNotFound, etc.)
// for easy checking with errors.Is().
func validateGraph(g *graph.ResidualGraph, source, sink int64) error <span class="cov8" title="1">{
        if g == nil </span><span class="cov8" title="1">{
                return ErrNilGraph
        }</span>
        <span class="cov8" title="1">if !g.Nodes[source] </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: %d", ErrSourceNotFound, source)
        }</span>
        <span class="cov8" title="1">if !g.Nodes[sink] </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: %d", ErrSinkNotFound, sink)
        }</span>
        <span class="cov8" title="1">if source == sink </span><span class="cov8" title="1">{
                return ErrSourceEqualSink
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// =============================================================================
// Main Solver Entry Point
// =============================================================================

// Solve is the primary entry point for solving flow problems.
//
// It dispatches to the appropriate algorithm based on the algorithm parameter
// and handles context management, timeout, and error wrapping.
//
// # Parameters
//
//   - ctx: Context for cancellation and timeout. Must not be nil.
//   - g: The residual graph. Will be modified by the algorithm.
//   - source: The source node ID. Must exist in the graph.
//   - sink: The sink node ID. Must exist in the graph and differ from source.
//   - algorithm: The algorithm to use. ALGORITHM_UNSPECIFIED defaults to Dinic.
//   - options: Solver options. nil uses DefaultSolverOptions().
//
// # Algorithm Selection
//
//   - ALGORITHM_FORD_FULKERSON: Classic DFS-based algorithm. O(E × max_flow).
//   - ALGORITHM_EDMONDS_KARP: BFS-based. O(VE²). Good for general graphs.
//   - ALGORITHM_DINIC: Level graph + blocking flow. O(V²E). Best for most cases.
//   - ALGORITHM_PUSH_RELABEL: Preflow-push. O(V³) or O(V²√E). Best for dense graphs.
//   - ALGORITHM_MIN_COST: SSP or Capacity Scaling. Finds minimum cost max flow.
//
// # Thread Safety
//
// This function is NOT thread-safe. The graph g will be modified.
// For concurrent use, clone the graph first or use SolverPool.
//
// # Example
//
//        ctx := context.Background()
//        g := buildGraph()
//        result := Solve(ctx, g, 1, 100, commonv1.Algorithm_ALGORITHM_DINIC, nil)
//        if result.Error != nil {
//            return fmt.Errorf("solve failed: %w", result.Error)
//        }
//        fmt.Printf("Max flow: %.2f\n", result.MaxFlow)
func Solve(ctx context.Context, g *graph.ResidualGraph, source, sink int64, algorithm commonv1.Algorithm, options *SolverOptions) *SolverResult <span class="cov8" title="1">{
        start := time.Now()

        if options == nil </span><span class="cov8" title="1">{
                options = DefaultSolverOptions()
        }</span>

        // Validate input
        <span class="cov8" title="1">if err := validateGraph(g, source, sink); err != nil </span><span class="cov8" title="1">{
                return &amp;SolverResult{
                        Status:   commonv1.FlowStatus_FLOW_STATUS_ERROR,
                        Error:    err,
                        Duration: time.Since(start),
                }
        }</span>

        // Create context with timeout if specified
        <span class="cov8" title="1">if options.Timeout &gt; 0 </span><span class="cov8" title="1">{
                var cancel context.CancelFunc
                ctx, cancel = context.WithTimeout(ctx, options.Timeout)
                defer cancel()
        }</span>

        <span class="cov8" title="1">result := solveInternal(ctx, g, source, sink, algorithm, options)
        result.Duration = time.Since(start)

        return result</span>
}

// solveInternal dispatches to the appropriate algorithm implementation.
func solveInternal(ctx context.Context, g *graph.ResidualGraph, source, sink int64, algorithm commonv1.Algorithm, options *SolverOptions) *SolverResult <span class="cov8" title="1">{
        switch algorithm </span>{
        case commonv1.Algorithm_ALGORITHM_EDMONDS_KARP:<span class="cov8" title="1">
                return solveEdmondsKarp(ctx, g, source, sink, options)</span>

        case commonv1.Algorithm_ALGORITHM_DINIC:<span class="cov8" title="1">
                return solveDinic(ctx, g, source, sink, options)</span>

        case commonv1.Algorithm_ALGORITHM_PUSH_RELABEL:<span class="cov8" title="1">
                return solvePushRelabel(ctx, g, source, sink, options)</span>

        case commonv1.Algorithm_ALGORITHM_MIN_COST:<span class="cov8" title="1">
                return solveMinCost(ctx, g, source, sink, options)</span>

        case commonv1.Algorithm_ALGORITHM_FORD_FULKERSON:<span class="cov8" title="1">
                return solveFordFulkerson(ctx, g, source, sink, options)</span>

        default:<span class="cov8" title="1">
                // Default to Dinic as it has the best general performance
                return solveDinic(ctx, g, source, sink, options)</span>
        }
}

// solveEdmondsKarp runs the Edmonds-Karp algorithm and wraps the result.
func solveEdmondsKarp(ctx context.Context, g *graph.ResidualGraph, source, sink int64, options *SolverOptions) *SolverResult <span class="cov8" title="1">{
        result := EdmondsKarpWithContext(ctx, g, source, sink, options)
        if result.Canceled </span><span class="cov0" title="0">{
                return &amp;SolverResult{
                        MaxFlow:    result.MaxFlow,
                        Iterations: result.Iterations,
                        Paths:      result.Paths,
                        Status:     commonv1.FlowStatus_FLOW_STATUS_ERROR,
                        Error:      ErrContextCanceled,
                }
        }</span>
        <span class="cov8" title="1">return &amp;SolverResult{
                MaxFlow:    result.MaxFlow,
                TotalCost:  g.GetTotalCost(),
                Iterations: result.Iterations,
                Paths:      result.Paths,
                Status:     commonv1.FlowStatus_FLOW_STATUS_OPTIMAL,
        }</span>
}

// solveDinic runs the Dinic algorithm and wraps the result.
func solveDinic(ctx context.Context, g *graph.ResidualGraph, source, sink int64, options *SolverOptions) *SolverResult <span class="cov8" title="1">{
        result := DinicWithContext(ctx, g, source, sink, options)
        if result.Canceled </span><span class="cov8" title="1">{
                return &amp;SolverResult{
                        MaxFlow:    result.MaxFlow,
                        Iterations: result.Iterations,
                        Paths:      result.Paths,
                        Status:     commonv1.FlowStatus_FLOW_STATUS_ERROR,
                        Error:      ErrContextCanceled,
                }
        }</span>
        <span class="cov8" title="1">return &amp;SolverResult{
                MaxFlow:    result.MaxFlow,
                TotalCost:  g.GetTotalCost(),
                Iterations: result.Iterations,
                Paths:      result.Paths,
                Status:     commonv1.FlowStatus_FLOW_STATUS_OPTIMAL,
        }</span>
}

// solvePushRelabel runs the Push-Relabel algorithm and wraps the result.
func solvePushRelabel(ctx context.Context, g *graph.ResidualGraph, source, sink int64, options *SolverOptions) *SolverResult <span class="cov8" title="1">{
        result := PushRelabelWithContext(ctx, g, source, sink, options)
        if result.Canceled </span><span class="cov0" title="0">{
                return &amp;SolverResult{
                        MaxFlow:    result.MaxFlow,
                        Iterations: result.Iterations,
                        Status:     commonv1.FlowStatus_FLOW_STATUS_ERROR,
                        Error:      ErrContextCanceled,
                }
        }</span>
        <span class="cov8" title="1">return &amp;SolverResult{
                MaxFlow:    result.MaxFlow,
                TotalCost:  g.GetTotalCost(),
                Iterations: result.Iterations,
                Status:     commonv1.FlowStatus_FLOW_STATUS_OPTIMAL,
        }</span>
}

// solveFordFulkerson runs the Ford-Fulkerson algorithm and wraps the result.
func solveFordFulkerson(ctx context.Context, g *graph.ResidualGraph, source, sink int64, options *SolverOptions) *SolverResult <span class="cov8" title="1">{
        result := FordFulkersonWithContext(ctx, g, source, sink, options)
        if result.Canceled </span><span class="cov0" title="0">{
                return &amp;SolverResult{
                        MaxFlow:    result.MaxFlow,
                        Iterations: result.Iterations,
                        Paths:      result.Paths,
                        Status:     commonv1.FlowStatus_FLOW_STATUS_ERROR,
                        Error:      ErrContextCanceled,
                }
        }</span>
        <span class="cov8" title="1">return &amp;SolverResult{
                MaxFlow:    result.MaxFlow,
                TotalCost:  g.GetTotalCost(),
                Iterations: result.Iterations,
                Paths:      result.Paths,
                Status:     commonv1.FlowStatus_FLOW_STATUS_OPTIMAL,
        }</span>
}

// solveMinCost runs the min-cost max-flow algorithm and wraps the result.
//
// This function finds the maximum flow with minimum total cost. The algorithm
// automatically terminates when no augmenting path exists, so no pre-computation
// of the maximum flow value is needed.
func solveMinCost(ctx context.Context, g *graph.ResidualGraph, source, sink int64, options *SolverOptions) *SolverResult <span class="cov8" title="1">{
        // Pass Infinity as required flow — the algorithm will find the maximum
        // possible flow and stop when sink becomes unreachable
        result := MinCostMaxFlowWithContext(ctx, g, source, sink, math.MaxFloat64, options)

        if result.Canceled </span><span class="cov0" title="0">{
                return &amp;SolverResult{
                        MaxFlow:    result.Flow,
                        TotalCost:  result.Cost,
                        Iterations: result.Iterations,
                        Paths:      result.Paths,
                        Status:     commonv1.FlowStatus_FLOW_STATUS_ERROR,
                        Error:      ErrContextCanceled,
                }
        }</span>

        <span class="cov8" title="1">return &amp;SolverResult{
                MaxFlow:    result.Flow,
                TotalCost:  result.Cost,
                Iterations: result.Iterations,
                Paths:      result.Paths,
                Status:     commonv1.FlowStatus_FLOW_STATUS_OPTIMAL,
        }</span>
}

// =============================================================================
// Solver Pool
// =============================================================================

// SolverPool manages concurrent solver executions with resource pooling.
//
// It provides:
//   - Concurrency limiting to prevent resource exhaustion
//   - Graph pooling for memory reuse
//   - Automatic graph cloning for thread safety
//
// # Example
//
//        pool := NewSolverPool(runtime.NumCPU())
//
//        // Concurrent solving
//        var wg sync.WaitGroup
//        for _, task := range tasks {
//            wg.Add(1)
//            go func(t Task) {
//                defer wg.Done()
//                result := pool.SolvePooled(ctx, t.Graph, t.Source, t.Sink, t.Algo, nil)
//                handleResult(result)
//            }(task)
//        }
//        wg.Wait()
type SolverPool struct {
        graphPool *graph.GraphPool
        workers   chan struct{} // Semaphore for concurrency limiting
}

// NewSolverPool creates a new solver pool with the specified maximum concurrency.
//
// maxConcurrency limits the number of simultaneous solver executions.
// If maxConcurrency &lt;= 0, it defaults to 10.
//
// The pool uses the global graph pool for memory reuse.
func NewSolverPool(maxConcurrency int) *SolverPool <span class="cov8" title="1">{
        if maxConcurrency &lt;= 0 </span><span class="cov0" title="0">{
                maxConcurrency = 10
        }</span>
        <span class="cov8" title="1">return &amp;SolverPool{
                graphPool: graph.GetPool(),
                workers:   make(chan struct{}, maxConcurrency),
        }</span>
}

// Acquire obtains a worker slot from the pool.
//
// Blocks until a slot is available or the context is cancelled.
// Returns nil on success, or ctx.Err() if the context was cancelled.
//
// Call Release() when the work is complete.
func (sp *SolverPool) Acquire(ctx context.Context) error <span class="cov8" title="1">{
        select </span>{
        case sp.workers &lt;- struct{}{}:<span class="cov8" title="1">
                return nil</span>
        case &lt;-ctx.Done():<span class="cov8" title="1">
                return ctx.Err()</span>
        }
}

// Release returns a worker slot to the pool.
//
// Must be called exactly once after each successful Acquire().
func (sp *SolverPool) Release() <span class="cov8" title="1">{
        &lt;-sp.workers
}</span>

// SolvePooled solves a flow problem using pooled resources.
//
// This method is thread-safe and will:
//  1. Acquire a worker slot (blocking if at capacity)
//  2. Clone the graph from the pool
//  3. Run the algorithm on the cloned graph
//  4. Release resources back to the pool
//
// The original graph g is NOT modified.
//
// # Parameters
//
// Same as Solve(), but the graph is cloned internally.
//
// # Returns
//
// SolverResult with the computation results. On context cancellation during
// slot acquisition, returns an error result.
func (sp *SolverPool) SolvePooled(ctx context.Context, g *graph.ResidualGraph, source, sink int64, algorithm commonv1.Algorithm, options *SolverOptions) *SolverResult <span class="cov8" title="1">{
        if err := sp.Acquire(ctx); err != nil </span><span class="cov0" title="0">{
                return &amp;SolverResult{
                        Status: commonv1.FlowStatus_FLOW_STATUS_ERROR,
                        Error:  err,
                }
        }</span>
        <span class="cov8" title="1">defer sp.Release()

        // Clone graph from pool for thread safety
        cloned := g.CloneToPooled(sp.graphPool)
        defer sp.graphPool.ReleaseGraph(cloned)

        if options == nil </span><span class="cov8" title="1">{
                options = DefaultSolverOptions()
        }</span>
        <span class="cov8" title="1">options.Pool = sp.graphPool

        return Solve(ctx, cloned, source, sink, algorithm, options)</span>
}

// BatchSolve solves multiple flow problems in parallel.
//
// Tasks are executed concurrently up to the pool's concurrency limit.
// Results are returned in the same order as the input tasks.
//
// The method blocks until all tasks are complete or the context is cancelled.
//
// # Example
//
//        tasks := []BatchTask{
//            {TaskID: "task1", Graph: g1, Source: 1, Sink: 10, Algorithm: algo},
//            {TaskID: "task2", Graph: g2, Source: 1, Sink: 20, Algorithm: algo},
//        }
//        results := pool.BatchSolve(ctx, tasks)
//        for _, r := range results {
//            fmt.Printf("Task %s: flow=%f\n", r.TaskID, r.Result.MaxFlow)
//        }
func (sp *SolverPool) BatchSolve(ctx context.Context, tasks []BatchTask) []BatchResult <span class="cov8" title="1">{
        results := make([]BatchResult, len(tasks))
        var wg sync.WaitGroup

        for i, task := range tasks </span><span class="cov8" title="1">{
                wg.Add(1)
                go func(idx int, t BatchTask) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        result := sp.SolvePooled(ctx, t.Graph, t.Source, t.Sink, t.Algorithm, t.Options)
                        results[idx] = BatchResult{
                                TaskID: t.TaskID,
                                Result: result,
                        }
                }</span>(i, task)
        }

        <span class="cov8" title="1">wg.Wait()
        return results</span>
}

// BatchTask represents a single task for batch processing.
type BatchTask struct {
        // TaskID is a user-defined identifier for correlating results.
        TaskID string

        // Graph is the input graph. Will be cloned internally.
        Graph *graph.ResidualGraph

        // Source is the source node ID.
        Source int64

        // Sink is the sink node ID.
        Sink int64

        // Algorithm specifies which algorithm to use.
        Algorithm commonv1.Algorithm

        // Options for the solver. nil uses defaults.
        Options *SolverOptions
}

// BatchResult contains the result of a batch task.
type BatchResult struct {
        // TaskID matches the input BatchTask.TaskID.
        TaskID string

        // Result is the solver result for this task.
        Result *SolverResult
}

// =============================================================================
// Algorithm Information
// =============================================================================

// AlgorithmInfo provides metadata about a flow algorithm.
//
// Use GetAlgorithmInfo() or GetAllAlgorithms() to retrieve this information
// for displaying to users or for algorithm selection logic.
type AlgorithmInfo struct {
        // Algorithm is the algorithm enum value.
        Algorithm commonv1.Algorithm

        // Name is the human-readable name.
        Name string

        // Description is a brief description of the algorithm.
        Description string

        // TimeComplexity is the Big-O time complexity.
        TimeComplexity string

        // SpaceComplexity is the Big-O space complexity.
        SpaceComplexity string

        // SupportsMinCost indicates if the algorithm minimizes cost.
        SupportsMinCost bool

        // SupportsNegativeCosts indicates if the algorithm handles negative edge costs.
        SupportsNegativeCosts bool

        // BestFor lists scenarios where this algorithm excels.
        BestFor []string

        // Caveats lists potential issues or limitations.
        Caveats []string
}

// GetAlgorithmInfo returns detailed information about a specific algorithm.
//
// Returns nil for unknown algorithms.
func GetAlgorithmInfo(algo commonv1.Algorithm) *AlgorithmInfo <span class="cov8" title="1">{
        infos := map[commonv1.Algorithm]*AlgorithmInfo{
                commonv1.Algorithm_ALGORITHM_FORD_FULKERSON: {
                        Algorithm:       commonv1.Algorithm_ALGORITHM_FORD_FULKERSON,
                        Name:            "Ford-Fulkerson",
                        Description:     "Classic augmenting path algorithm using DFS",
                        TimeComplexity:  "O(E × max_flow)",
                        SpaceComplexity: "O(V + E)",
                        BestFor:         []string{"small_graphs", "integer_capacities", "educational"},
                        Caveats: []string{
                                "May be very slow for large max_flow values",
                                "May not terminate for irrational capacities",
                                "Consider using Edmonds-Karp or Dinic instead",
                        },
                },
                commonv1.Algorithm_ALGORITHM_EDMONDS_KARP: {
                        Algorithm:       commonv1.Algorithm_ALGORITHM_EDMONDS_KARP,
                        Name:            "Edmonds-Karp",
                        Description:     "Ford-Fulkerson with BFS for shortest augmenting paths",
                        TimeComplexity:  "O(V × E²)",
                        SpaceComplexity: "O(V + E)",
                        BestFor:         []string{"general_graphs", "small_to_medium_size"},
                        Caveats:         []string{"Slower than Dinic for large graphs"},
                },
                commonv1.Algorithm_ALGORITHM_DINIC: {
                        Algorithm:       commonv1.Algorithm_ALGORITHM_DINIC,
                        Name:            "Dinic",
                        Description:     "Level graphs with blocking flow optimization",
                        TimeComplexity:  "O(V² × E)",
                        SpaceComplexity: "O(V + E)",
                        BestFor:         []string{"large_graphs", "unit_capacity_graphs", "bipartite_matching"},
                        Caveats:         []string{},
                },
                commonv1.Algorithm_ALGORITHM_PUSH_RELABEL: {
                        Algorithm:       commonv1.Algorithm_ALGORITHM_PUSH_RELABEL,
                        Name:            "Push-Relabel (FIFO with Highest Label option)",
                        Description:     "Preflow-push with FIFO/Highest Label vertex selection and gap heuristic",
                        TimeComplexity:  "O(V³) for FIFO, O(V²√E) for Highest Label",
                        SpaceComplexity: "O(V + E)",
                        BestFor:         []string{"dense_graphs", "very_large_graphs"},
                        Caveats:         []string{"More complex implementation", "Does not naturally produce paths"},
                },
                commonv1.Algorithm_ALGORITHM_MIN_COST: {
                        Algorithm:             commonv1.Algorithm_ALGORITHM_MIN_COST,
                        Name:                  "Min-Cost Max-Flow (SSP + Capacity Scaling)",
                        Description:           "Successive Shortest Paths with potentials; auto-switches to Capacity Scaling for large capacities",
                        TimeComplexity:        "O(V × E + V × E × log(V) × F) for SSP; O(E² log U) for Capacity Scaling",
                        SpaceComplexity:       "O(V + E)",
                        SupportsMinCost:       true,
                        SupportsNegativeCosts: true,
                        BestFor:               []string{"cost_optimization", "transportation_problems", "assignment_problems"},
                        Caveats: []string{
                                "Slower than pure max-flow algorithms",
                                "Uses Dijkstra with fallback to Bellman-Ford for negative edges",
                        },
                },
        }

        return infos[algo]
}</span>

// GetAllAlgorithms returns information about all available algorithms.
//
// The returned slice is in a stable order suitable for display.
func GetAllAlgorithms() []*AlgorithmInfo <span class="cov8" title="1">{
        algorithms := []commonv1.Algorithm{
                commonv1.Algorithm_ALGORITHM_FORD_FULKERSON,
                commonv1.Algorithm_ALGORITHM_EDMONDS_KARP,
                commonv1.Algorithm_ALGORITHM_DINIC,
                commonv1.Algorithm_ALGORITHM_PUSH_RELABEL,
                commonv1.Algorithm_ALGORITHM_MIN_COST,
        }

        var infos []*AlgorithmInfo
        for _, algo := range algorithms </span><span class="cov8" title="1">{
                if info := GetAlgorithmInfo(algo); info != nil </span><span class="cov8" title="1">{
                        infos = append(infos, info)
                }</span>
        }
        <span class="cov8" title="1">return infos</span>
}

// RecommendAlgorithm suggests the best algorithm based on graph characteristics.
//
// # Parameters
//
//   - nodeCount: Number of nodes in the graph.
//   - edgeCount: Number of edges in the graph.
//   - needMinCost: Whether minimum cost is required.
//   - hasNegativeCosts: Whether the graph has negative edge costs.
//
// # Returns
//
// The recommended algorithm enum value.
//
// # Recommendation Logic
//
//   - If min-cost is needed or graph has negative costs: MIN_COST
//   - If graph is dense (&gt;50% edges) and large (&gt;100 nodes): PUSH_RELABEL
//   - If graph is large (&gt;100 nodes): DINIC
//   - Otherwise: EDMONDS_KARP
func RecommendAlgorithm(nodeCount, edgeCount int, needMinCost bool, hasNegativeCosts bool) commonv1.Algorithm <span class="cov8" title="1">{
        // Min-cost requirement takes priority
        if needMinCost || hasNegativeCosts </span><span class="cov8" title="1">{
                return commonv1.Algorithm_ALGORITHM_MIN_COST
        }</span>

        // Calculate graph density
        <span class="cov8" title="1">maxEdges := nodeCount * (nodeCount - 1)
        if maxEdges == 0 </span><span class="cov0" title="0">{
                return commonv1.Algorithm_ALGORITHM_EDMONDS_KARP
        }</span>

        <span class="cov8" title="1">density := float64(edgeCount) / float64(maxEdges)

        // Dense graphs with many nodes benefit from Push-Relabel
        if density &gt; 0.5 &amp;&amp; nodeCount &gt; 100 </span><span class="cov8" title="1">{
                return commonv1.Algorithm_ALGORITHM_PUSH_RELABEL
        }</span>

        // Large graphs benefit from Dinic
        <span class="cov8" title="1">if nodeCount &gt; 100 </span><span class="cov8" title="1">{
                return commonv1.Algorithm_ALGORITHM_DINIC
        }</span>

        // Default to Edmonds-Karp for small graphs
        <span class="cov8" title="1">return commonv1.Algorithm_ALGORITHM_EDMONDS_KARP</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package converter provides utilities for converting between protobuf graph
// representations and the internal residual graph structures used by flow algorithms.
//
// The package handles:
//   - Converting proto Graph messages to ResidualGraph for algorithm execution
//   - Converting algorithm results back to proto format for API responses
//   - Computing graph statistics and metrics
//   - Filtering and selecting edges based on various criteria
//
// Thread Safety:
// All functions in this package are stateless and thread-safe. The returned
// slices and maps are newly allocated and safe to modify.
//
// Determinism:
// All functions that iterate over graph structures use sorted node orderings
// to ensure deterministic output regardless of map iteration order.
package converter

import (
        "sort"

        commonv1 "logistics/gen/go/logistics/common/v1"
        "logistics/services/solver-svc/internal/graph"
)

// PathWithFlow represents an augmenting path with its associated flow value.
// Used to track individual paths found during flow algorithm execution.
type PathWithFlow struct {
        // NodeIDs contains the sequence of node IDs from source to sink.
        // The path is valid if len(NodeIDs) &gt;= 2 (at least source and sink).
        NodeIDs []int64

        // Flow is the amount of flow pushed along this path.
        // Always positive for valid paths.
        Flow float64
}

// =============================================================================
// Proto to Internal Conversion
// =============================================================================

// ToResidualGraph converts a protobuf Graph message to an internal ResidualGraph
// structure suitable for flow algorithm execution.
//
// The conversion process:
//  1. Creates a new ResidualGraph
//  2. Adds all nodes from the proto graph
//  3. Adds edges with their reverse edges for residual capacity tracking
//  4. Handles bidirectional edges by adding both directions
//
// Parameters:
//   - protoGraph: The protobuf Graph message to convert
//
// Returns:
//   - A new ResidualGraph ready for algorithm execution
//
// Example:
//
//        rg := ToResidualGraph(request.Graph)
//        result := algorithms.Dinic(rg, sourceID, sinkID, nil)
func ToResidualGraph(protoGraph *commonv1.Graph) *graph.ResidualGraph <span class="cov8" title="1">{
        rg := graph.NewResidualGraph()

        // Add all nodes first
        for _, node := range protoGraph.Nodes </span><span class="cov8" title="1">{
                rg.AddNode(node.Id)
        }</span>

        // Add edges with reverse edges for residual graph structure
        <span class="cov8" title="1">for _, edge := range protoGraph.Edges </span><span class="cov8" title="1">{
                rg.AddEdgeWithReverse(edge.From, edge.To, edge.Capacity, edge.Cost)

                // For bidirectional edges, add the reverse direction as well
                if edge.Bidirectional </span><span class="cov8" title="1">{
                        rg.AddEdgeWithReverse(edge.To, edge.From, edge.Capacity, edge.Cost)
                }</span>
        }

        <span class="cov8" title="1">return rg</span>
}

// =============================================================================
// Path Conversion
// =============================================================================

// ToPaths converts internal PathWithFlow slices to protobuf Path messages.
// Each path includes the flow amount and computed cost.
//
// The cost for each path is computed as: sum of edge costs * path flow.
//
// Parameters:
//   - paths: Slice of internal path representations
//   - rg: The residual graph (used to look up edge costs)
//
// Returns:
//   - Slice of protobuf Path messages
//
// Note: Paths with fewer than 2 nodes are filtered out as invalid.
func ToPaths(paths []PathWithFlow, rg *graph.ResidualGraph) []*commonv1.Path <span class="cov8" title="1">{
        result := make([]*commonv1.Path, 0, len(paths))

        for _, p := range paths </span><span class="cov8" title="1">{
                // Valid paths must have at least source and sink
                if len(p.NodeIDs) &lt; 2 </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Compute total edge cost for the path
                <span class="cov8" title="1">unitCost := calculatePathCost(rg, p.NodeIDs)

                result = append(result, &amp;commonv1.Path{
                        NodeIds: p.NodeIDs,
                        Flow:    p.Flow,
                        Cost:    unitCost * p.Flow, // Total cost = unit cost * flow
                })</span>
        }

        <span class="cov8" title="1">return result</span>
}

// ToPathsFromNodeIDs converts raw node ID sequences to protobuf Paths.
// Flow is computed as the minimum residual capacity along each path.
//
// This is useful when you have path sequences but haven't tracked flow values.
//
// Parameters:
//   - paths: Slice of node ID sequences
//   - rg: The residual graph
//
// Returns:
//   - Slice of protobuf Path messages with computed flows
func ToPathsFromNodeIDs(paths [][]int64, rg *graph.ResidualGraph) []*commonv1.Path <span class="cov8" title="1">{
        result := make([]*commonv1.Path, 0, len(paths))

        for _, nodeIDs := range paths </span><span class="cov8" title="1">{
                if len(nodeIDs) &lt; 2 </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Flow is the bottleneck capacity
                <span class="cov8" title="1">flow := graph.FindMinCapacityOnPath(rg, nodeIDs)
                unitCost := calculatePathCost(rg, nodeIDs)

                result = append(result, &amp;commonv1.Path{
                        NodeIds: nodeIDs,
                        Flow:    flow,
                        Cost:    unitCost * flow,
                })</span>
        }

        <span class="cov8" title="1">return result</span>
}

// ToPathsWithFlowReconstruction reconstructs path flows from edge flow values.
// The flow for each path is the minimum edge flow along the path.
//
// This is useful when paths were recorded during execution but flow values
// need to be recomputed from the final graph state.
//
// Parameters:
//   - paths: Slice of node ID sequences
//   - rg: The residual graph with flow values
//
// Returns:
//   - Slice of protobuf Path messages
func ToPathsWithFlowReconstruction(paths [][]int64, rg *graph.ResidualGraph) []*commonv1.Path <span class="cov8" title="1">{
        result := make([]*commonv1.Path, 0, len(paths))

        for _, nodeIDs := range paths </span><span class="cov8" title="1">{
                if len(nodeIDs) &lt; 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Find minimum flow along the path
                <span class="cov8" title="1">minFlow := graph.Infinity
                for i := 0; i &lt; len(nodeIDs)-1; i++ </span><span class="cov8" title="1">{
                        edge := rg.GetEdge(nodeIDs[i], nodeIDs[i+1])
                        if edge == nil </span><span class="cov8" title="1">{
                                minFlow = 0
                                break</span>
                        }
                        <span class="cov8" title="1">if edge.Flow &lt; minFlow </span><span class="cov8" title="1">{
                                minFlow = edge.Flow
                        }</span>
                }

                // Handle edge cases
                <span class="cov8" title="1">if minFlow &gt;= graph.Infinity || minFlow &lt; 0 </span><span class="cov0" title="0">{
                        minFlow = 0
                }</span>

                <span class="cov8" title="1">unitCost := calculatePathCost(rg, nodeIDs)

                result = append(result, &amp;commonv1.Path{
                        NodeIds: nodeIDs,
                        Flow:    minFlow,
                        Cost:    unitCost * minFlow,
                })</span>
        }

        <span class="cov8" title="1">return result</span>
}

// calculatePathCost computes the sum of edge costs along a path.
// This is the cost per unit of flow, not the total cost.
func calculatePathCost(rg *graph.ResidualGraph, nodeIDs []int64) float64 <span class="cov8" title="1">{
        var totalCost float64

        for i := 0; i &lt; len(nodeIDs)-1; i++ </span><span class="cov8" title="1">{
                edge := rg.GetEdge(nodeIDs[i], nodeIDs[i+1])
                if edge != nil </span><span class="cov8" title="1">{
                        totalCost += edge.Cost
                }</span>
        }

        <span class="cov8" title="1">return totalCost</span>
}

// =============================================================================
// Edge Conversion
// =============================================================================

// FlowEdgeOptions configures which edges to include in conversion output.
type FlowEdgeOptions struct {
        // IncludeZeroFlow includes edges with no flow when true.
        // Default: false (only edges with positive flow are included)
        IncludeZeroFlow bool

        // IncludeReverseEdge includes reverse/residual edges when true.
        // Default: false (only forward edges are included)
        IncludeReverseEdge bool

        // MinFlowThreshold is the minimum flow value to include an edge.
        // Edges with flow &lt; MinFlowThreshold are excluded (unless IncludeZeroFlow).
        // Default: graph.Epsilon
        MinFlowThreshold float64
}

// DefaultFlowEdgeOptions returns the default options for edge conversion.
// By default, only forward edges with positive flow are included.
func DefaultFlowEdgeOptions() *FlowEdgeOptions <span class="cov8" title="1">{
        return &amp;FlowEdgeOptions{
                IncludeZeroFlow:    false,
                IncludeReverseEdge: false,
                MinFlowThreshold:   graph.Epsilon,
        }
}</span>

// ToFlowEdges converts residual graph edges to protobuf FlowEdge messages.
// Uses default options: only forward edges with positive flow.
//
// The edges are returned in deterministic order (sorted by from node, then to node).
//
// Parameters:
//   - rg: The residual graph with flow values
//
// Returns:
//   - Slice of protobuf FlowEdge messages
func ToFlowEdges(rg *graph.ResidualGraph) []*commonv1.FlowEdge <span class="cov8" title="1">{
        return ToFlowEdgesWithOptions(rg, DefaultFlowEdgeOptions())
}</span>

// ToFlowEdgesWithOptions converts edges with custom filtering options.
//
// Parameters:
//   - rg: The residual graph
//   - opts: Options controlling which edges to include
//
// Returns:
//   - Filtered slice of protobuf FlowEdge messages in deterministic order
func ToFlowEdgesWithOptions(rg *graph.ResidualGraph, opts *FlowEdgeOptions) []*commonv1.FlowEdge <span class="cov8" title="1">{
        if opts == nil </span><span class="cov0" title="0">{
                opts = DefaultFlowEdgeOptions()
        }</span>

        <span class="cov8" title="1">var result []*commonv1.FlowEdge

        // Iterate in deterministic order using sorted node list
        nodes := rg.GetSortedNodes()
        for _, from := range nodes </span><span class="cov8" title="1">{
                // Use EdgesList which maintains insertion order
                edges := rg.GetNeighborsList(from)
                for _, edge := range edges </span><span class="cov8" title="1">{
                        // Apply filters
                        if edge.IsReverse &amp;&amp; !opts.IncludeReverseEdge </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">if edge.Flow &lt; opts.MinFlowThreshold &amp;&amp; !opts.IncludeZeroFlow </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        // Compute utilization ratio
                        <span class="cov8" title="1">utilization := 0.0
                        if edge.OriginalCapacity &gt; 0 </span><span class="cov8" title="1">{
                                utilization = edge.Flow / edge.OriginalCapacity
                        }</span>

                        <span class="cov8" title="1">result = append(result, &amp;commonv1.FlowEdge{
                                From:        from,
                                To:          edge.To,
                                Flow:        edge.Flow,
                                Capacity:    edge.OriginalCapacity,
                                Cost:        edge.Cost,
                                Utilization: utilization,
                        })</span>
                }
        }

        <span class="cov8" title="1">return result</span>
}

// ToAllEdges returns all forward edges regardless of flow.
// Useful for visualizing the complete network structure.
func ToAllEdges(rg *graph.ResidualGraph) []*commonv1.FlowEdge <span class="cov8" title="1">{
        opts := &amp;FlowEdgeOptions{
                IncludeZeroFlow:    true,
                IncludeReverseEdge: false,
                MinFlowThreshold:   0,
        }
        return ToFlowEdgesWithOptions(rg, opts)
}</span>

// ToDebugEdges returns all edges including reverse edges.
// Useful for debugging residual graph structure.
func ToDebugEdges(rg *graph.ResidualGraph) []*commonv1.FlowEdge <span class="cov8" title="1">{
        opts := &amp;FlowEdgeOptions{
                IncludeZeroFlow:    true,
                IncludeReverseEdge: true,
                MinFlowThreshold:   0,
        }
        return ToFlowEdgesWithOptions(rg, opts)
}</span>

// =============================================================================
// Edge Filters
// =============================================================================

// EdgeFilter is a function type for custom edge filtering.
// Returns true if the edge should be included in the output.
type EdgeFilter func(from int64, edge *graph.ResidualEdge) bool

// ToFlowEdgesFiltered converts edges using a custom filter function.
// Edges are returned in deterministic order.
//
// Parameters:
//   - rg: The residual graph
//   - filter: Function to determine if each edge should be included
//
// Returns:
//   - Filtered slice of protobuf FlowEdge messages
func ToFlowEdgesFiltered(rg *graph.ResidualGraph, filter EdgeFilter) []*commonv1.FlowEdge <span class="cov8" title="1">{
        var result []*commonv1.FlowEdge

        nodes := rg.GetSortedNodes()
        for _, from := range nodes </span><span class="cov8" title="1">{
                edges := rg.GetNeighborsList(from)
                for _, edge := range edges </span><span class="cov8" title="1">{
                        if filter != nil &amp;&amp; !filter(from, edge) </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">utilization := 0.0
                        if edge.OriginalCapacity &gt; 0 </span><span class="cov8" title="1">{
                                utilization = edge.Flow / edge.OriginalCapacity
                        }</span>

                        <span class="cov8" title="1">result = append(result, &amp;commonv1.FlowEdge{
                                From:        from,
                                To:          edge.To,
                                Flow:        edge.Flow,
                                Capacity:    edge.OriginalCapacity,
                                Cost:        edge.Cost,
                                Utilization: utilization,
                        })</span>
                }
        }

        <span class="cov8" title="1">return result</span>
}

// FilterActiveEdges returns a filter that selects only forward edges with positive flow.
func FilterActiveEdges() EdgeFilter <span class="cov8" title="1">{
        return func(from int64, edge *graph.ResidualEdge) bool </span><span class="cov8" title="1">{
                return !edge.IsReverse &amp;&amp; edge.Flow &gt; graph.Epsilon
        }</span>
}

// FilterHighUtilization returns a filter that selects edges with utilization &gt;= threshold.
//
// Parameters:
//   - threshold: Minimum utilization ratio (0.0 to 1.0)
//
// Example:
//
//        // Get edges that are at least 80% utilized
//        filter := FilterHighUtilization(0.8)
//        edges := ToFlowEdgesFiltered(rg, filter)
func FilterHighUtilization(threshold float64) EdgeFilter <span class="cov8" title="1">{
        return func(from int64, edge *graph.ResidualEdge) bool </span><span class="cov8" title="1">{
                if edge.IsReverse || edge.OriginalCapacity &lt;= 0 </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">utilization := edge.Flow / edge.OriginalCapacity
                return utilization &gt;= threshold</span>
        }
}

// FilterSaturatedEdges returns a filter that selects fully saturated edges
// (edges where flow equals capacity within epsilon tolerance).
func FilterSaturatedEdges() EdgeFilter <span class="cov8" title="1">{
        return FilterHighUtilization(1.0 - graph.Epsilon)
}</span>

// FilterByNodes returns a filter that selects edges between specified nodes.
//
// Parameters:
//   - nodes: Map of node IDs to include (both endpoints must be in the map)
func FilterByNodes(nodes map[int64]bool) EdgeFilter <span class="cov8" title="1">{
        return func(from int64, edge *graph.ResidualEdge) bool </span><span class="cov8" title="1">{
                if edge.IsReverse </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">return nodes[from] &amp;&amp; nodes[edge.To]</span>
        }
}

// =============================================================================
// Graph Update
// =============================================================================

// UpdateGraphWithFlow creates a copy of a proto Graph with flow values
// populated from algorithm results.
//
// This is useful for returning the modified graph state to clients.
//
// Parameters:
//   - protoGraph: Original protobuf graph
//   - rg: Residual graph with computed flow values
//
// Returns:
//   - New protobuf Graph with CurrentFlow fields populated
func UpdateGraphWithFlow(protoGraph *commonv1.Graph, rg *graph.ResidualGraph) *commonv1.Graph <span class="cov8" title="1">{
        result := &amp;commonv1.Graph{
                Nodes:    protoGraph.Nodes,
                Edges:    make([]*commonv1.Edge, len(protoGraph.Edges)),
                SourceId: protoGraph.SourceId,
                SinkId:   protoGraph.SinkId,
                Name:     protoGraph.Name,
                Metadata: protoGraph.Metadata,
        }

        for i, edge := range protoGraph.Edges </span><span class="cov8" title="1">{
                newEdge := &amp;commonv1.Edge{
                        From:          edge.From,
                        To:            edge.To,
                        Capacity:      edge.Capacity,
                        Cost:          edge.Cost,
                        Length:        edge.Length,
                        RoadType:      edge.RoadType,
                        Bidirectional: edge.Bidirectional,
                }

                // Populate flow from residual graph
                if re := rg.GetEdge(edge.From, edge.To); re != nil </span><span class="cov8" title="1">{
                        newEdge.CurrentFlow = re.Flow
                }</span>

                <span class="cov8" title="1">result.Edges[i] = newEdge</span>
        }

        <span class="cov8" title="1">return result</span>
}

// =============================================================================
// Statistics
// =============================================================================

// CalculateGraphStatistics computes various metrics about the graph structure.
//
// Computed metrics include:
//   - Node and edge counts
//   - Warehouse and delivery point counts (by node type)
//   - Total and average capacity/length
//   - Graph density
//
// Parameters:
//   - protoGraph: The protobuf graph to analyze
//
// Returns:
//   - GraphStatistics message with computed metrics
func CalculateGraphStatistics(protoGraph *commonv1.Graph) *commonv1.GraphStatistics <span class="cov8" title="1">{
        var warehouseCount, deliveryPointCount int64
        var totalCapacity, totalLength float64

        // Count node types
        for _, node := range protoGraph.Nodes </span><span class="cov8" title="1">{
                switch node.Type </span>{
                case commonv1.NodeType_NODE_TYPE_WAREHOUSE:<span class="cov8" title="1">
                        warehouseCount++</span>
                case commonv1.NodeType_NODE_TYPE_DELIVERY_POINT:<span class="cov8" title="1">
                        deliveryPointCount++</span>
                }
        }

        // Sum edge metrics
        <span class="cov8" title="1">for _, edge := range protoGraph.Edges </span><span class="cov8" title="1">{
                totalCapacity += edge.Capacity
                totalLength += edge.Length
        }</span>

        <span class="cov8" title="1">nodeCount := int64(len(protoGraph.Nodes))
        edgeCount := int64(len(protoGraph.Edges))

        // Compute averages
        avgLength := 0.0
        if edgeCount &gt; 0 </span><span class="cov8" title="1">{
                avgLength = totalLength / float64(edgeCount)
        }</span>

        // Compute density: actual edges / max possible edges
        // For directed graph: max edges = n * (n-1)
        <span class="cov8" title="1">density := 0.0
        if nodeCount &gt; 1 </span><span class="cov8" title="1">{
                maxEdges := nodeCount * (nodeCount - 1)
                density = float64(edgeCount) / float64(maxEdges)
        }</span>

        <span class="cov8" title="1">return &amp;commonv1.GraphStatistics{
                NodeCount:          nodeCount,
                EdgeCount:          edgeCount,
                WarehouseCount:     warehouseCount,
                DeliveryPointCount: deliveryPointCount,
                TotalCapacity:      totalCapacity,
                AverageEdgeLength:  avgLength,
                IsConnected:        true, // TODO: implement actual connectivity check
                Density:            density,
        }</span>
}

// =============================================================================
// Utility Functions
// =============================================================================

// GetSortedNodeIDs extracts and sorts node IDs from a boolean map.
// Useful for deterministic iteration over node sets.
func GetSortedNodeIDs(nodes map[int64]bool) []int64 <span class="cov8" title="1">{
        result := make([]int64, 0, len(nodes))
        for id := range nodes </span><span class="cov8" title="1">{
                result = append(result, id)
        }</span>
        <span class="cov8" title="1">sort.Slice(result, func(i, j int) bool </span><span class="cov8" title="1">{ return result[i] &lt; result[j] }</span>)
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package graph provides core data structures and algorithms for graph-based
// network flow computations.
//
// This file implements Breadth-First Search (BFS) variants used by flow algorithms:
//   - Standard BFS for finding augmenting paths (Edmonds-Karp)
//   - Level BFS for building level graphs (Dinic's algorithm)
//   - Reverse BFS for computing node heights (Push-Relabel)
//
// All BFS implementations use deterministic node ordering to ensure reproducible
// results regardless of map iteration order.
package graph

import (
        "logistics/pkg/domain"
)

// BFSResult encapsulates the result of a BFS traversal.
// Imported from domain package for consistency across the codebase.
type BFSResult = domain.BFSResult

// =============================================================================
// Queue Implementation
// =============================================================================

// Queue provides an efficient FIFO queue for BFS traversal.
// It uses a slice with a head pointer to avoid repeated allocations
// during typical BFS operations.
//
// The queue grows as needed but reuses underlying storage between operations.
// For optimal performance with large graphs, pre-allocate with NewQueue(expectedSize).
type Queue struct {
        data []int64 // Underlying storage
        head int     // Index of next element to dequeue
}

// NewQueue creates a new Queue with the specified initial capacity.
// The capacity should be set to the expected maximum queue size
// (typically the number of nodes in the graph for BFS).
//
// Example:
//
//        q := NewQueue(len(graph.Nodes))
//        q.Push(sourceID)
func NewQueue(capacity int) *Queue <span class="cov8" title="1">{
        return &amp;Queue{
                data: make([]int64, 0, capacity),
                head: 0,
        }
}</span>

// Push adds an element to the end of the queue.
// Amortized O(1) time complexity.
func (q *Queue) Push(v int64) <span class="cov8" title="1">{
        q.data = append(q.data, v)
}</span>

// Pop removes and returns the element at the front of the queue.
// O(1) time complexity.
//
// Panics if the queue is empty. Always check Empty() before calling Pop().
func (q *Queue) Pop() int64 <span class="cov8" title="1">{
        v := q.data[q.head]
        q.head++
        return v
}</span>

// Empty returns true if the queue contains no elements.
func (q *Queue) Empty() bool <span class="cov8" title="1">{
        return q.head &gt;= len(q.data)
}</span>

// Len returns the number of elements currently in the queue.
func (q *Queue) Len() int <span class="cov8" title="1">{
        return len(q.data) - q.head
}</span>

// Reset clears the queue for reuse, keeping the underlying capacity.
// This is more efficient than creating a new queue.
func (q *Queue) Reset() <span class="cov8" title="1">{
        q.data = q.data[:0]
        q.head = 0
}</span>

// =============================================================================
// Standard BFS
// =============================================================================

// BFS performs breadth-first search from source to sink.
// This is the standard BFS used by the Edmonds-Karp algorithm.
//
// The search only traverses edges with positive residual capacity.
// Returns as soon as the sink is found (early termination).
//
// Parameters:
//   - g: The residual graph to search
//   - source: Starting node ID
//   - sink: Target node ID
//
// Returns:
//   - BFSResult with Found=true if sink is reachable, parent map for path reconstruction
//
// Example:
//
//        result := BFS(g, sourceID, sinkID)
//        if result.Found {
//            path := ReconstructPath(result.Parent, sourceID, sinkID)
//        }
func BFS(g *ResidualGraph, source, sink int64) *BFSResult <span class="cov8" title="1">{
        return BFSDeterministic(g, source, sink)
}</span>

// BFSDeterministic performs BFS with deterministic neighbor ordering.
// This is the primary BFS implementation that guarantees reproducible results.
//
// The algorithm uses EdgesList (which maintains insertion order) rather than
// iterating over maps, ensuring the same path is found regardless of Go's
// map iteration randomization.
//
// Time Complexity: O(V + E)
// Space Complexity: O(V)
func BFSDeterministic(g *ResidualGraph, source, sink int64) *BFSResult <span class="cov8" title="1">{
        parent := make(map[int64]int64, len(g.Nodes))
        visited := make(map[int64]bool, len(g.Nodes))

        queue := NewQueue(len(g.Nodes))
        queue.Push(source)
        visited[source] = true
        parent[source] = -1

        for !queue.Empty() </span><span class="cov8" title="1">{
                u := queue.Pop()

                // Use EdgesList for deterministic ordering
                neighbors := g.GetNeighborsList(u)
                for _, edge := range neighbors </span><span class="cov8" title="1">{
                        v := edge.To

                        // Only traverse edges with positive residual capacity
                        if !visited[v] &amp;&amp; edge.Capacity &gt; Epsilon </span><span class="cov8" title="1">{
                                parent[v] = u
                                visited[v] = true
                                queue.Push(v)

                                // Early termination when sink is found
                                if v == sink </span><span class="cov8" title="1">{
                                        return &amp;BFSResult{
                                                Found:   true,
                                                Parent:  parent,
                                                Visited: visited,
                                        }
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return &amp;BFSResult{
                Found:   false,
                Parent:  parent,
                Visited: visited,
        }</span>
}

// =============================================================================
// Level BFS (for Dinic's Algorithm)
// =============================================================================

// BFSLevel builds a level graph by computing BFS distances from the source.
// This is used by Dinic's algorithm to construct the layered network.
//
// A level graph partitions vertices into layers where:
//   - level[source] = 0
//   - level[v] = level[u] + 1 for edge (u,v) in the BFS tree
//   - Only edges going from level i to level i+1 are considered valid
//
// Parameters:
//   - g: The residual graph
//   - source: Starting node ID
//
// Returns:
//   - Map from node ID to its level (BFS distance from source)
//   - Unreachable nodes are not included in the map
//
// Example:
//
//        level := BFSLevel(g, sourceID)
//        if _, exists := level[sinkID]; exists {
//            // Sink is reachable, proceed with blocking flow
//        }
func BFSLevel(g *ResidualGraph, source int64) map[int64]int <span class="cov8" title="1">{
        level := make(map[int64]int, len(g.Nodes))
        level[source] = 0

        queue := NewQueue(len(g.Nodes))
        queue.Push(source)

        for !queue.Empty() </span><span class="cov8" title="1">{
                u := queue.Pop()

                // Deterministic neighbor ordering via EdgesList
                neighbors := g.GetNeighborsList(u)
                for _, edge := range neighbors </span><span class="cov8" title="1">{
                        v := edge.To

                        // Only consider edges with positive capacity
                        if _, exists := level[v]; !exists &amp;&amp; edge.Capacity &gt; Epsilon </span><span class="cov8" title="1">{
                                level[v] = level[u] + 1
                                queue.Push(v)
                        }</span>
                }
        }

        <span class="cov8" title="1">return level</span>
}

// =============================================================================
// BFS with Callback
// =============================================================================

// BFSWithCallback performs BFS and invokes a callback for each visited node.
// The callback receives the node ID and its level (distance from source).
//
// If the callback returns false, the BFS terminates early.
// This is useful for:
//   - Finding all nodes within a certain distance
//   - Computing reachability with early termination
//   - Custom traversal logic
//
// Parameters:
//   - g: The residual graph
//   - source: Starting node ID
//   - callback: Function called for each visited node; return false to stop
//
// Example:
//
//        // Find all nodes within 3 hops of source
//        nearby := make([]int64, 0)
//        BFSWithCallback(g, source, func(node int64, level int) bool {
//            if level &gt; 3 {
//                return false // Stop BFS
//            }
//            nearby = append(nearby, node)
//            return true
//        })
func BFSWithCallback(g *ResidualGraph, source int64, callback func(node int64, level int) bool) <span class="cov8" title="1">{
        visited := make(map[int64]bool, len(g.Nodes))
        level := make(map[int64]int, len(g.Nodes))

        queue := NewQueue(len(g.Nodes))
        queue.Push(source)
        visited[source] = true
        level[source] = 0

        for !queue.Empty() </span><span class="cov8" title="1">{
                u := queue.Pop()

                // Invoke callback; stop if it returns false
                if !callback(u, level[u]) </span><span class="cov8" title="1">{
                        return
                }</span>

                <span class="cov8" title="1">neighbors := g.GetNeighborsList(u)
                for _, edge := range neighbors </span><span class="cov8" title="1">{
                        v := edge.To
                        if !visited[v] &amp;&amp; edge.Capacity &gt; Epsilon </span><span class="cov8" title="1">{
                                visited[v] = true
                                level[v] = level[u] + 1
                                queue.Push(v)
                        }</span>
                }
        }
}

// =============================================================================
// Reverse BFS (for Push-Relabel)
// =============================================================================

// BFSReverse performs backward BFS from the sink to compute node heights.
// This is used by the Push-Relabel algorithm for global relabeling.
//
// The search traverses edges in reverse direction: for edge (u,v), we check
// if we can reach u from v. This requires looking at incoming edges.
//
// Parameters:
//   - g: The residual graph
//   - sink: The sink node to start from
//
// Returns:
//   - Map from node ID to height (reverse BFS distance from sink)
//   - Nodes not reverse-reachable from sink are not included
//
// The heights are used in Push-Relabel to determine valid push directions:
// flow can only be pushed from higher to lower vertices.
func BFSReverse(g *ResidualGraph, sink int64) map[int64]int <span class="cov8" title="1">{
        height := make(map[int64]int, len(g.Nodes))
        height[sink] = 0

        queue := NewQueue(len(g.Nodes))
        queue.Push(sink)

        for !queue.Empty() </span><span class="cov8" title="1">{
                u := queue.Pop()

                // Get incoming edges in deterministic order
                incomingEdges := g.GetIncomingEdgesList(u)
                for _, incoming := range incomingEdges </span><span class="cov8" title="1">{
                        v := incoming.From

                        // Check if the reverse edge has capacity (can push from v to u)
                        if _, exists := height[v]; !exists &amp;&amp; incoming.Edge.Capacity &gt; Epsilon </span><span class="cov8" title="1">{
                                height[v] = height[u] + 1
                                queue.Push(v)
                        }</span>
                }
        }

        <span class="cov8" title="1">return height</span>
}

// =============================================================================
// Multi-Path BFS
// =============================================================================

// BFSAllPaths finds all shortest paths from source to sink.
// This is useful for analyzing network structure or finding alternative routes.
//
// The algorithm:
//  1. Build level graph using BFSLevel
//  2. DFS on level graph to enumerate all paths
//
// Parameters:
//   - g: The residual graph
//   - source: Starting node ID
//   - sink: Target node ID
//   - maxPaths: Maximum number of paths to find (0 uses default of 100)
//
// Returns:
//   - Slice of paths, where each path is a slice of node IDs from source to sink
//   - Empty slice if sink is unreachable
//
// Warning: The number of shortest paths can be exponential in graph size.
// Always use a reasonable maxPaths limit.
func BFSAllPaths(g *ResidualGraph, source, sink int64, maxPaths int) [][]int64 <span class="cov8" title="1">{
        if maxPaths &lt;= 0 </span><span class="cov0" title="0">{
                maxPaths = 100
        }</span>

        // Build level graph
        <span class="cov8" title="1">level := BFSLevel(g, source)
        if _, exists := level[sink]; !exists </span><span class="cov8" title="1">{
                return nil // Sink not reachable
        }</span>

        <span class="cov8" title="1">var paths [][]int64
        var currentPath []int64

        // DFS on level graph to enumerate paths
        var dfs func(node int64)
        dfs = func(node int64) </span><span class="cov8" title="1">{
                if len(paths) &gt;= maxPaths </span><span class="cov8" title="1">{
                        return
                }</span>

                <span class="cov8" title="1">currentPath = append(currentPath, node)

                if node == sink </span><span class="cov8" title="1">{
                        // Found a complete path - copy it
                        pathCopy := make([]int64, len(currentPath))
                        copy(pathCopy, currentPath)
                        paths = append(paths, pathCopy)
                }</span> else<span class="cov8" title="1"> {
                        // Continue DFS along level graph edges
                        neighbors := g.GetNeighborsList(node)
                        for _, edge := range neighbors </span><span class="cov8" title="1">{
                                v := edge.To
                                // Only follow edges that go to next level
                                if level[v] == level[node]+1 &amp;&amp; edge.Capacity &gt; Epsilon </span><span class="cov8" title="1">{
                                        dfs(v)
                                }</span>
                        }
                }

                // Backtrack
                <span class="cov8" title="1">currentPath = currentPath[:len(currentPath)-1]</span>
        }

        <span class="cov8" title="1">dfs(source)
        return paths</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package graph provides core data structures and algorithms for graph operations.
//
// This file provides utilities for path manipulation in flow networks:
//   - Path reconstruction from parent pointers
//   - Bottleneck capacity computation
//   - Flow augmentation along paths
package graph

import (
        "logistics/pkg/domain"
)

// ReconstructPath builds a path from source to sink using the parent map
// produced by BFS or other shortest path algorithms.
//
// The parent map encodes a shortest path tree where parent[v] = u means
// the path to v goes through u. Starting from sink, we follow parent
// pointers back to source and reverse to get the forward path.
//
// Parameters:
//   - parent: Map from node ID to parent node ID (parent[source] = -1)
//   - source: Starting node of the path
//   - sink: Ending node of the path
//
// Returns:
//   - Slice of node IDs from source to sink (inclusive)
//   - Empty slice if no path exists (sink not in parent map or not connected)
//
// Example:
//
//        result := BFS(g, 1, 5)
//        if result.Found {
//            path := ReconstructPath(result.Parent, 1, 5)
//            // path might be [1, 3, 4, 5]
//        }
//
// Implementation delegates to pkg/domain for consistency across packages.
func ReconstructPath(parent map[int64]int64, source, sink int64) []int64 <span class="cov8" title="1">{
        return domain.ReconstructPath(parent, source, sink)
}</span>

// FindMinCapacityOnPath finds the minimum residual capacity along a path.
// This value (the "bottleneck") determines the maximum flow that can be
// pushed along this path without exceeding any edge's capacity.
//
// Parameters:
//   - g: The residual graph containing edge capacities
//   - path: Sequence of node IDs from source to sink
//
// Returns:
//   - Minimum capacity among all edges in the path
//   - 0 if path is invalid (&lt; 2 nodes) or any edge doesn't exist
//
// Example:
//
//        path := []int64{1, 3, 5}
//        bottleneck := FindMinCapacityOnPath(g, path)
//        // bottleneck = min(cap[1-&gt;3], cap[3-&gt;5])
//
// Time Complexity: O(|path|)
func FindMinCapacityOnPath(g *ResidualGraph, path []int64) float64 <span class="cov8" title="1">{
        if len(path) &lt; 2 </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">minCapacity := Infinity

        for i := 0; i &lt; len(path)-1; i++ </span><span class="cov8" title="1">{
                from := path[i]
                to := path[i+1]

                edge := g.GetEdge(from, to)
                if edge == nil </span><span class="cov8" title="1">{
                        // Edge doesn't exist - invalid path
                        return 0
                }</span>

                <span class="cov8" title="1">if edge.Capacity &lt; minCapacity </span><span class="cov8" title="1">{
                        minCapacity = edge.Capacity
                }</span>
        }

        // Guard against returning Infinity if path was empty
        <span class="cov8" title="1">if minCapacity == Infinity </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">return minCapacity</span>
}

// AugmentPath pushes flow along a path and updates residual capacities.
//
// For each edge (u, v) in the path:
//   - Decreases capacity of (u, v) by flow
//   - Increases capacity of reverse edge (v, u) by flow
//   - Updates flow counters on both edges
//
// This maintains the residual graph property where the capacity of a reverse
// edge represents the amount of flow that can be "cancelled" by pushing
// flow in the opposite direction.
//
// Parameters:
//   - g: The residual graph (modified in place)
//   - path: Sequence of node IDs from source to sink
//   - flow: Amount of flow to push (should be &lt;= bottleneck capacity)
//
// Example:
//
//        path := []int64{1, 3, 5}
//        bottleneck := FindMinCapacityOnPath(g, path)
//        AugmentPath(g, path, bottleneck)
//        // Now cap[1-&gt;3] decreased, cap[3-&gt;1] increased, etc.
//
// Note: This function assumes the path is valid and flow &lt;= bottleneck.
// Calling with flow &gt; bottleneck may result in negative capacities.
//
// Time Complexity: O(|path|)
func AugmentPath(g *ResidualGraph, path []int64, flow float64) <span class="cov8" title="1">{
        for i := 0; i &lt; len(path)-1; i++ </span><span class="cov8" title="1">{
                from := path[i]
                to := path[i+1]
                g.UpdateFlow(from, to, flow)
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Package graph provides data structures and utilities for network flow algorithms.
//
// This package contains:
//   - ResidualGraph: The core graph representation for flow algorithms
//   - GraphPool: Memory pooling for efficient graph allocation
//   - BFS utilities: Breadth-first search implementations
//   - Path utilities: Path reconstruction and augmentation
//
// # Memory Management
//
// Network flow algorithms often need to create temporary graphs and data structures.
// The GraphPool provides efficient memory reuse through sync.Pool, reducing GC pressure
// in high-throughput scenarios.
//
// # Thread Safety
//
// ResidualGraph is NOT thread-safe. Each goroutine should work with its own graph.
// Use Clone() or CloneToPooled() for concurrent operations.
// For shared read access, use SafeResidualGraph.
//
// # Example
//
//        // Using the global pool
//        pool := graph.GetPool()
//        g := pool.AcquireGraph()
//        defer pool.ReleaseGraph(g)
//
//        g.AddEdgeWithReverse(1, 2, 10, 0)
//        // ... use graph ...
package graph

import (
        "sync"
)

// =============================================================================
// Graph Pool
// =============================================================================

// GraphPool provides memory pooling for ResidualGraph and related data structures.
//
// Using a pool significantly reduces memory allocations and GC pressure when
// processing many graphs or running algorithms repeatedly.
//
// The pool is safe for concurrent use from multiple goroutines.
//
// # Usage
//
// For single graph operations:
//
//        pool := graph.GetPool()  // Use global pool
//        g := pool.AcquireGraph()
//        defer pool.ReleaseGraph(g)
//        // ... use g ...
//
// For request-scoped resources:
//
//        resources := NewPooledResources()
//        defer resources.Release()
//        g := resources.Graph()
//        dist := resources.FloatMap()
//        // ... use resources ...
//
// # Implementation Notes
//
// The pool uses sync.Pool internally, which means:
//   - Objects may be garbage collected if not in use
//   - Objects are not pre-allocated
//   - The pool grows and shrinks based on demand
type GraphPool struct {
        graphs      sync.Pool
        int64Slices sync.Pool
        int64Maps   sync.Pool
        floatMaps   sync.Pool
        boolMaps    sync.Pool
        intMaps     sync.Pool
}

// globalPool is the singleton pool instance.
// Initialized at package load time.
var globalPool = &amp;GraphPool{
        graphs: sync.Pool{
                New: func() any <span class="cov8" title="1">{
                        return &amp;ResidualGraph{
                                Nodes:        make(map[int64]bool, 64),
                                Edges:        make(map[int64]map[int64]*ResidualEdge, 64),
                                EdgesList:    make(map[int64][]*ResidualEdge, 64),
                                ReverseEdges: make(map[int64]map[int64]*ResidualEdge, 64),
                        }
                }</span>,
        },
        int64Slices: sync.Pool{
                New: func() any <span class="cov8" title="1">{
                        s := make([]int64, 0, 128)
                        return &amp;s
                }</span>,
        },
        int64Maps: sync.Pool{
                New: func() any <span class="cov8" title="1">{
                        return make(map[int64]int64, 64)
                }</span>,
        },
        floatMaps: sync.Pool{
                New: func() any <span class="cov8" title="1">{
                        return make(map[int64]float64, 64)
                }</span>,
        },
        boolMaps: sync.Pool{
                New: func() any <span class="cov8" title="1">{
                        return make(map[int64]bool, 64)
                }</span>,
        },
        intMaps: sync.Pool{
                New: func() any <span class="cov8" title="1">{
                        return make(map[int64]int, 64)
                }</span>,
        },
}

// GetPool returns the global graph pool.
//
// The global pool is thread-safe and should be used for most operations.
// Creating custom pools is rarely necessary.
func GetPool() *GraphPool <span class="cov8" title="1">{
        return globalPool
}</span>

// =============================================================================
// Graph Pool Methods
// =============================================================================

// AcquireGraph obtains a ResidualGraph from the pool.
//
// The returned graph is cleared and ready for use.
// Call ReleaseGraph() when done to return it to the pool.
//
// # Example
//
//        g := pool.AcquireGraph()
//        defer pool.ReleaseGraph(g)
//        g.AddNode(1)
//        g.AddEdgeWithReverse(1, 2, 10, 0)
func (p *GraphPool) AcquireGraph() *ResidualGraph <span class="cov8" title="1">{
        return p.graphs.Get().(*ResidualGraph)
}</span>

// ReleaseGraph returns a ResidualGraph to the pool.
//
// The graph is cleared before being pooled.
// After calling this method, the graph must not be used.
//
// It is safe to pass nil to this method.
func (p *GraphPool) ReleaseGraph(g *ResidualGraph) <span class="cov8" title="1">{
        if g == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">g.Clear()
        p.graphs.Put(g)</span>
}

// AcquireInt64Slice obtains a []int64 slice from the pool.
//
// The returned slice has length 0 but may have non-zero capacity.
// Call ReleaseInt64Slice() when done.
func (p *GraphPool) AcquireInt64Slice() *[]int64 <span class="cov8" title="1">{
        return p.int64Slices.Get().(*[]int64)
}</span>

// ReleaseInt64Slice returns a []int64 slice to the pool.
//
// The slice is reset to length 0 before pooling.
// It is safe to pass nil.
func (p *GraphPool) ReleaseInt64Slice(s *[]int64) <span class="cov8" title="1">{
        if s == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">*s = (*s)[:0]
        p.int64Slices.Put(s)</span>
}

// AcquireInt64Map obtains a map[int64]int64 from the pool.
//
// The returned map is cleared and ready for use.
// Call ReleaseInt64Map() when done.
func (p *GraphPool) AcquireInt64Map() map[int64]int64 <span class="cov8" title="1">{
        return p.int64Maps.Get().(map[int64]int64)
}</span>

// ReleaseInt64Map returns a map[int64]int64 to the pool.
//
// The map is cleared before pooling.
// It is safe to pass nil.
func (p *GraphPool) ReleaseInt64Map(m map[int64]int64) <span class="cov8" title="1">{
        if m == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">clear(m)
        p.int64Maps.Put(m)</span>
}

// AcquireFloatMap obtains a map[int64]float64 from the pool.
//
// The returned map is cleared and ready for use.
// Call ReleaseFloatMap() when done.
func (p *GraphPool) AcquireFloatMap() map[int64]float64 <span class="cov8" title="1">{
        return p.floatMaps.Get().(map[int64]float64)
}</span>

// ReleaseFloatMap returns a map[int64]float64 to the pool.
//
// The map is cleared before pooling.
// It is safe to pass nil.
func (p *GraphPool) ReleaseFloatMap(m map[int64]float64) <span class="cov8" title="1">{
        if m == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">clear(m)
        p.floatMaps.Put(m)</span>
}

// AcquireBoolMap obtains a map[int64]bool from the pool.
//
// The returned map is cleared and ready for use.
// Call ReleaseBoolMap() when done.
func (p *GraphPool) AcquireBoolMap() map[int64]bool <span class="cov8" title="1">{
        return p.boolMaps.Get().(map[int64]bool)
}</span>

// ReleaseBoolMap returns a map[int64]bool to the pool.
//
// The map is cleared before pooling.
// It is safe to pass nil.
func (p *GraphPool) ReleaseBoolMap(m map[int64]bool) <span class="cov8" title="1">{
        if m == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">clear(m)
        p.boolMaps.Put(m)</span>
}

// AcquireIntMap obtains a map[int64]int from the pool.
//
// The returned map is cleared and ready for use.
// Call ReleaseIntMap() when done.
func (p *GraphPool) AcquireIntMap() map[int64]int <span class="cov8" title="1">{
        return p.intMaps.Get().(map[int64]int)
}</span>

// ReleaseIntMap returns a map[int64]int to the pool.
//
// The map is cleared before pooling.
// It is safe to pass nil.
func (p *GraphPool) ReleaseIntMap(m map[int64]int) <span class="cov8" title="1">{
        if m == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">clear(m)
        p.intMaps.Put(m)</span>
}

// =============================================================================
// Pooled Resources
// =============================================================================

// PooledResources manages a set of pooled resources for a single request.
//
// This is useful when an algorithm needs multiple temporary data structures.
// All resources are tracked and can be released with a single call to Release().
//
// # Usage Pattern
//
//        func processRequest(g *ResidualGraph) {
//            resources := NewPooledResources()
//            defer resources.Release()  // Always release!
//
//            dist := resources.FloatMap()
//            parent := resources.Int64Map()
//            visited := resources.BoolMap()
//
//            // ... use resources ...
//        }
//
// # Thread Safety
//
// PooledResources is NOT thread-safe. Each goroutine should have its own instance.
type PooledResources struct {
        pool        *GraphPool
        graphs      []*ResidualGraph
        int64Maps   []map[int64]int64
        floatMaps   []map[int64]float64
        boolMaps    []map[int64]bool
        intMaps     []map[int64]int
        int64Slices []*[]int64
}

// NewPooledResources creates a new resource container using the global pool.
//
// Always call Release() when done, typically via defer:
//
//        resources := NewPooledResources()
//        defer resources.Release()
func NewPooledResources() *PooledResources <span class="cov8" title="1">{
        return &amp;PooledResources{
                pool: globalPool,
        }
}</span>

// NewPooledResourcesWithPool creates a resource container with a custom pool.
//
// This is useful when you need isolated pooling or custom pool configuration.
func NewPooledResourcesWithPool(pool *GraphPool) *PooledResources <span class="cov8" title="1">{
        if pool == nil </span><span class="cov8" title="1">{
                pool = globalPool
        }</span>
        <span class="cov8" title="1">return &amp;PooledResources{
                pool: pool,
        }</span>
}

// Graph acquires a ResidualGraph and tracks it for automatic release.
//
// The returned graph is cleared and ready for use.
// Do not manually release graphs obtained this way.
func (pr *PooledResources) Graph() *ResidualGraph <span class="cov8" title="1">{
        g := pr.pool.AcquireGraph()
        pr.graphs = append(pr.graphs, g)
        return g
}</span>

// Int64Map acquires a map[int64]int64 and tracks it for automatic release.
func (pr *PooledResources) Int64Map() map[int64]int64 <span class="cov8" title="1">{
        m := pr.pool.AcquireInt64Map()
        pr.int64Maps = append(pr.int64Maps, m)
        return m
}</span>

// FloatMap acquires a map[int64]float64 and tracks it for automatic release.
func (pr *PooledResources) FloatMap() map[int64]float64 <span class="cov8" title="1">{
        m := pr.pool.AcquireFloatMap()
        pr.floatMaps = append(pr.floatMaps, m)
        return m
}</span>

// BoolMap acquires a map[int64]bool and tracks it for automatic release.
func (pr *PooledResources) BoolMap() map[int64]bool <span class="cov8" title="1">{
        m := pr.pool.AcquireBoolMap()
        pr.boolMaps = append(pr.boolMaps, m)
        return m
}</span>

// IntMap acquires a map[int64]int and tracks it for automatic release.
func (pr *PooledResources) IntMap() map[int64]int <span class="cov8" title="1">{
        m := pr.pool.AcquireIntMap()
        pr.intMaps = append(pr.intMaps, m)
        return m
}</span>

// Int64Slice acquires a []int64 slice and tracks it for automatic release.
func (pr *PooledResources) Int64Slice() *[]int64 <span class="cov8" title="1">{
        s := pr.pool.AcquireInt64Slice()
        pr.int64Slices = append(pr.int64Slices, s)
        return s
}</span>

// Release returns all tracked resources to the pool.
//
// After calling Release(), do not use any resources obtained from this container.
// It is safe to call Release() multiple times.
func (pr *PooledResources) Release() <span class="cov8" title="1">{
        // Release all tracked resources
        for _, g := range pr.graphs </span><span class="cov8" title="1">{
                pr.pool.ReleaseGraph(g)
        }</span>
        <span class="cov8" title="1">for _, m := range pr.int64Maps </span><span class="cov8" title="1">{
                pr.pool.ReleaseInt64Map(m)
        }</span>
        <span class="cov8" title="1">for _, m := range pr.floatMaps </span><span class="cov8" title="1">{
                pr.pool.ReleaseFloatMap(m)
        }</span>
        <span class="cov8" title="1">for _, m := range pr.boolMaps </span><span class="cov8" title="1">{
                pr.pool.ReleaseBoolMap(m)
        }</span>
        <span class="cov8" title="1">for _, m := range pr.intMaps </span><span class="cov8" title="1">{
                pr.pool.ReleaseIntMap(m)
        }</span>
        <span class="cov8" title="1">for _, s := range pr.int64Slices </span><span class="cov8" title="1">{
                pr.pool.ReleaseInt64Slice(s)
        }</span>

        // Clear tracking slices (keep capacity for reuse)
        <span class="cov8" title="1">pr.graphs = pr.graphs[:0]
        pr.int64Maps = pr.int64Maps[:0]
        pr.floatMaps = pr.floatMaps[:0]
        pr.boolMaps = pr.boolMaps[:0]
        pr.intMaps = pr.intMaps[:0]
        pr.int64Slices = pr.int64Slices[:0]</span>
}

// Reset is an alias for Release() for consistency with other Reset methods.
func (pr *PooledResources) Reset() <span class="cov8" title="1">{
        pr.Release()
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// Package graph provides data structures and utilities for network flow algorithms.
package graph

import (
        "sort"
        "sync"

        "logistics/pkg/domain"
)

// =============================================================================
// Constants
// =============================================================================

// Epsilon is the tolerance for floating-point comparisons.
// Values smaller than Epsilon are considered zero.
// This is crucial for numerical stability in flow algorithms.
const Epsilon = domain.Epsilon

// Infinity represents an unreachable distance or unlimited capacity.
// Used as the initial distance in shortest path algorithms.
const Infinity = domain.Infinity

// =============================================================================
// Residual Edge
// =============================================================================

// ResidualEdge represents an edge in the residual graph.
//
// In the residual graph, each original edge (u, v) with capacity c and cost w
// is represented by two edges:
//   - Forward edge (u, v) with capacity c and cost w
//   - Backward edge (v, u) with capacity 0 and cost -w
//
// When flow f is pushed along (u, v):
//   - Forward edge capacity becomes c - f
//   - Backward edge capacity becomes f
//
// This allows the algorithm to "undo" flow decisions.
type ResidualEdge struct {
        // To is the destination node ID.
        To int64

        // Capacity is the current residual capacity.
        // For forward edges: OriginalCapacity - Flow
        // For backward edges: equals the flow on the corresponding forward edge
        Capacity float64

        // Cost is the cost per unit of flow.
        // For backward edges, this is the negative of the forward edge cost.
        Cost float64

        // Flow is the amount of flow currently on this edge.
        // Only meaningful for forward edges.
        Flow float64

        // OriginalCapacity is the initial capacity of the edge.
        // Used for reset operations and utilization calculations.
        OriginalCapacity float64

        // IsReverse indicates whether this is a backward (reverse) edge.
        // Reverse edges are created automatically and should not be counted
        // when computing statistics.
        IsReverse bool

        // Index is the position of this edge in the EdgesList slice.
        // Used for efficient edge lookup and current-arc optimization.
        Index int
}

// ResidualCapacity returns the remaining capacity on this edge.
// This is equivalent to accessing the Capacity field directly.
func (e *ResidualEdge) ResidualCapacity() float64 <span class="cov8" title="1">{
        return e.Capacity
}</span>

// HasCapacity returns true if the edge has positive residual capacity.
// Uses Epsilon for floating-point comparison.
func (e *ResidualEdge) HasCapacity() bool <span class="cov8" title="1">{
        return e.Capacity &gt; Epsilon
}</span>

// =============================================================================
// Incoming Edge (for reverse traversal)
// =============================================================================

// IncomingEdge represents an edge for reverse graph traversal.
//
// Used by algorithms like Push-Relabel's globalRelabel that need to
// traverse edges in the reverse direction.
type IncomingEdge struct {
        // From is the source node of the edge.
        From int64

        // Edge is the edge data (points to node From).
        Edge *ResidualEdge
}

// =============================================================================
// Residual Graph
// =============================================================================

// ResidualGraph is the core data structure for network flow algorithms.
//
// It maintains both forward and backward edges, supporting efficient:
//   - Edge lookup by (from, to) pair: O(1)
//   - Neighbor iteration in deterministic order: O(degree)
//   - Incoming edge lookup for reverse traversal: O(1)
//
// # Edge Storage
//
// Edges are stored in two complementary structures:
//   - Edges: map for O(1) lookup by (from, to)
//   - EdgesList: slice for deterministic iteration order
//
// Both structures point to the same ResidualEdge objects.
//
// # Determinism
//
// Network flow algorithms can find different valid solutions depending on
// the order of edge traversal. To ensure deterministic results:
//   - Use GetNeighborsList() for iteration (not GetNeighbors())
//   - Use GetSortedNodes() for node iteration
//   - Use GetIncomingEdgesList() for reverse traversal
//
// # Thread Safety
//
// ResidualGraph is NOT thread-safe for concurrent writes. However,
// GetSortedNodes() is safe for concurrent reads due to internal locking.
// For full concurrent operations:
//   - Clone the graph for each goroutine
//   - Use SafeResidualGraph for shared read access
//
// # Example
//
//        g := NewResidualGraph()
//        g.AddNode(1)
//        g.AddNode(2)
//        g.AddNode(3)
//        g.AddEdgeWithReverse(1, 2, 10, 1.0)  // capacity=10, cost=1.0
//        g.AddEdgeWithReverse(2, 3, 5, 2.0)   // capacity=5, cost=2.0
//
//        // Find flow along path [1, 2, 3]
//        path := []int64{1, 2, 3}
//        minCap := FindMinCapacityOnPath(g, path)  // returns 5
//        AugmentPath(g, path, minCap)              // push 5 units
type ResidualGraph struct {
        // Nodes contains all node IDs in the graph.
        // The bool value is always true (used as a set).
        Nodes map[int64]bool

        // Edges provides O(1) edge lookup by (from, to) pair.
        // Edges[from][to] returns the ResidualEdge or nil.
        Edges map[int64]map[int64]*ResidualEdge

        // EdgesList provides deterministic edge iteration.
        // EdgesList[from] is a slice of edges sorted by insertion order.
        // This ensures algorithms produce the same results on every run.
        EdgesList map[int64][]*ResidualEdge

        // ReverseEdges enables efficient reverse graph traversal.
        // ReverseEdges[to][from] points to the edge from 'from' to 'to'.
        ReverseEdges map[int64]map[int64]*ResidualEdge

        // sortedNodesMu protects sortedNodes cache for concurrent access.
        sortedNodesMu sync.Mutex

        // sortedNodes caches the sorted list of node IDs.
        // Invalidated when nodes are added.
        sortedNodes      []int64
        sortedNodesDirty bool
}

// NewResidualGraph creates a new empty residual graph.
//
// The graph is ready to use immediately. Add nodes with AddNode()
// and edges with AddEdgeWithReverse().
func NewResidualGraph() *ResidualGraph <span class="cov8" title="1">{
        return &amp;ResidualGraph{
                Nodes:            make(map[int64]bool),
                Edges:            make(map[int64]map[int64]*ResidualEdge),
                EdgesList:        make(map[int64][]*ResidualEdge),
                ReverseEdges:     make(map[int64]map[int64]*ResidualEdge),
                sortedNodesDirty: true,
        }
}</span>

// =============================================================================
// Graph Modification
// =============================================================================

// Clear removes all nodes and edges from the graph.
//
// The graph can be reused after clearing. This is more efficient than
// creating a new graph when using pooling.
func (rg *ResidualGraph) Clear() <span class="cov8" title="1">{
        clear(rg.Nodes)
        for k := range rg.Edges </span><span class="cov8" title="1">{
                clear(rg.Edges[k])
                delete(rg.Edges, k)
        }</span>
        <span class="cov8" title="1">for k := range rg.EdgesList </span><span class="cov8" title="1">{
                rg.EdgesList[k] = rg.EdgesList[k][:0]
                delete(rg.EdgesList, k)
        }</span>
        <span class="cov8" title="1">for k := range rg.ReverseEdges </span><span class="cov8" title="1">{
                clear(rg.ReverseEdges[k])
                delete(rg.ReverseEdges, k)
        }</span>

        <span class="cov8" title="1">rg.sortedNodesMu.Lock()
        rg.sortedNodes = rg.sortedNodes[:0]
        rg.sortedNodesDirty = true
        rg.sortedNodesMu.Unlock()</span>
}

// AddNode adds a node to the graph.
//
// If the node already exists, this is a no-op.
// Nodes are added implicitly when adding edges, but explicit addition
// is useful for isolated nodes or pre-allocation.
func (rg *ResidualGraph) AddNode(id int64) <span class="cov8" title="1">{
        if !rg.Nodes[id] </span><span class="cov8" title="1">{
                rg.Nodes[id] = true
                rg.markSortedNodesDirty()
        }</span>
}

// ensureNode adds a node if it doesn't exist (internal helper).
func (rg *ResidualGraph) ensureNode(id int64) <span class="cov8" title="1">{
        if !rg.Nodes[id] </span><span class="cov8" title="1">{
                rg.Nodes[id] = true
                rg.markSortedNodesDirty()
        }</span>
}

// markSortedNodesDirty marks the sorted nodes cache as dirty.
// Thread-safe helper method.
func (rg *ResidualGraph) markSortedNodesDirty() <span class="cov8" title="1">{
        rg.sortedNodesMu.Lock()
        rg.sortedNodesDirty = true
        rg.sortedNodesMu.Unlock()
}</span>

// AddEdge adds a forward edge to the graph.
//
// If an edge already exists between the same nodes:
//   - If the existing edge is a reverse edge, it's converted to a forward edge
//   - Otherwise, the capacity is accumulated
//
// For most use cases, prefer AddEdgeWithReverse() which handles both directions.
//
// Parameters:
//   - from: Source node ID
//   - to: Destination node ID
//   - capacity: Maximum flow capacity
//   - cost: Cost per unit of flow
func (rg *ResidualGraph) AddEdge(from, to int64, capacity, cost float64) <span class="cov8" title="1">{
        rg.ensureNode(from)
        rg.ensureNode(to)

        if rg.Edges[from] == nil </span><span class="cov8" title="1">{
                rg.Edges[from] = make(map[int64]*ResidualEdge)
        }</span>

        <span class="cov8" title="1">if existing := rg.Edges[from][to]; existing != nil </span><span class="cov8" title="1">{
                if existing.IsReverse </span><span class="cov8" title="1">{
                        // Convert reverse edge to forward edge
                        // This happens when the reverse edge was created first
                        existing.OriginalCapacity = capacity
                        existing.Capacity = capacity
                        existing.Cost = cost
                        existing.IsReverse = false
                        return
                }</span>
                // Accumulate capacity for parallel edges
                <span class="cov8" title="1">existing.Capacity += capacity
                existing.OriginalCapacity += capacity
                return</span>
        }

        // Create new forward edge
        <span class="cov8" title="1">edge := &amp;ResidualEdge{
                To:               to,
                Capacity:         capacity,
                Cost:             cost,
                Flow:             0,
                OriginalCapacity: capacity,
                IsReverse:        false,
                Index:            len(rg.EdgesList[from]),
        }

        rg.Edges[from][to] = edge
        rg.EdgesList[from] = append(rg.EdgesList[from], edge)
        rg.addReverseIndex(from, to, edge)</span>
}

// AddReverseEdge adds a backward edge for flow cancellation.
//
// Reverse edges have:
//   - Initial capacity of 0 (increases as flow is pushed)
//   - Negative cost (pushing flow backward refunds the cost)
//
// This is typically called internally by AddEdgeWithReverse().
func (rg *ResidualGraph) AddReverseEdge(from, to int64, cost float64) <span class="cov8" title="1">{
        rg.ensureNode(from)
        rg.ensureNode(to)

        if rg.Edges[from] == nil </span><span class="cov8" title="1">{
                rg.Edges[from] = make(map[int64]*ResidualEdge)
        }</span>

        // Don't overwrite existing edge
        <span class="cov8" title="1">if existing := rg.Edges[from][to]; existing != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">edge := &amp;ResidualEdge{
                To:               to,
                Capacity:         0,
                Cost:             -cost, // Negative cost for refund
                Flow:             0,
                OriginalCapacity: 0,
                IsReverse:        true,
                Index:            len(rg.EdgesList[from]),
        }

        rg.Edges[from][to] = edge
        rg.EdgesList[from] = append(rg.EdgesList[from], edge)
        rg.addReverseIndex(from, to, edge)</span>
}

// addReverseIndex adds an entry to the reverse edge index (internal helper).
func (rg *ResidualGraph) addReverseIndex(from, to int64, edge *ResidualEdge) <span class="cov8" title="1">{
        if rg.ReverseEdges[to] == nil </span><span class="cov8" title="1">{
                rg.ReverseEdges[to] = make(map[int64]*ResidualEdge)
        }</span>
        <span class="cov8" title="1">rg.ReverseEdges[to][from] = edge</span>
}

// AddEdgeWithReverse adds both forward and backward edges.
//
// This is the recommended method for adding edges to a flow network.
// It creates:
//   - Forward edge (from → to) with the specified capacity and cost
//   - Backward edge (to → from) with 0 capacity and negative cost
//
// Parameters:
//   - from: Source node ID
//   - to: Destination node ID
//   - capacity: Maximum flow capacity
//   - cost: Cost per unit of flow
//
// Example:
//
//        g.AddEdgeWithReverse(1, 2, 10, 1.5)
//        // Creates edge 1→2 with capacity=10, cost=1.5
//        // Creates edge 2→1 with capacity=0, cost=-1.5
func (rg *ResidualGraph) AddEdgeWithReverse(from, to int64, capacity, cost float64) <span class="cov8" title="1">{
        rg.AddEdge(from, to, capacity, cost)
        rg.AddReverseEdge(to, from, cost)
}</span>

// =============================================================================
// Edge Access
// =============================================================================

// GetEdge returns the edge from 'from' to 'to', or nil if not found.
//
// Time complexity: O(1)
func (rg *ResidualGraph) GetEdge(from, to int64) *ResidualEdge <span class="cov8" title="1">{
        if rg.Edges[from] == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return rg.Edges[from][to]</span>
}

// GetNeighbors returns all outgoing edges from a node as a map.
//
// WARNING: Iterating over the returned map is non-deterministic.
// Use GetNeighborsList() for deterministic iteration.
//
// Time complexity: O(1)
func (rg *ResidualGraph) GetNeighbors(node int64) map[int64]*ResidualEdge <span class="cov8" title="1">{
        return rg.Edges[node]
}</span>

// GetNeighborsList returns all outgoing edges from a node as a slice.
//
// The slice is in insertion order, providing deterministic iteration.
// This should be used in algorithms to ensure reproducible results.
//
// Time complexity: O(1)
func (rg *ResidualGraph) GetNeighborsList(node int64) []*ResidualEdge <span class="cov8" title="1">{
        return rg.EdgesList[node]
}</span>

// GetIncomingEdges returns all incoming edges to a node as a map.
//
// WARNING: Iterating over the returned map is non-deterministic.
// Use GetIncomingEdgesList() for deterministic iteration.
//
// Time complexity: O(1)
func (rg *ResidualGraph) GetIncomingEdges(to int64) map[int64]*ResidualEdge <span class="cov0" title="0">{
        return rg.ReverseEdges[to]
}</span>

// GetIncomingEdgesList returns all incoming edges to a node in deterministic order.
//
// The returned slice is sorted by source node ID for reproducibility.
//
// Time complexity: O(in-degree × log(in-degree)) for sorting
func (rg *ResidualGraph) GetIncomingEdgesList(to int64) []IncomingEdge <span class="cov8" title="1">{
        incoming := rg.ReverseEdges[to]
        if incoming == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">result := make([]IncomingEdge, 0, len(incoming))
        for from, edge := range incoming </span><span class="cov8" title="1">{
                result = append(result, IncomingEdge{From: from, Edge: edge})
        }</span>

        // Sort by source node ID for determinism
        <span class="cov8" title="1">sort.Slice(result, func(i, j int) bool </span><span class="cov8" title="1">{
                return result[i].From &lt; result[j].From
        }</span>)

        <span class="cov8" title="1">return result</span>
}

// GetEdgesFrom returns all edges originating from a node.
// Equivalent to GetNeighborsList().
func (rg *ResidualGraph) GetEdgesFrom(from int64) []*ResidualEdge <span class="cov0" title="0">{
        return rg.EdgesList[from]
}</span>

// =============================================================================
// Node Access
// =============================================================================

// GetNodes returns all node IDs in deterministic (sorted) order.
//
// This is equivalent to GetSortedNodes() and should be used for
// deterministic iteration over nodes.
func (rg *ResidualGraph) GetNodes() []int64 <span class="cov8" title="1">{
        return rg.GetSortedNodes()
}</span>

// GetSortedNodes returns node IDs sorted in ascending order.
//
// The result is cached for efficiency. The cache is invalidated when
// nodes are added. This method is safe for concurrent use.
//
// Time complexity: O(1) if cached, O(n log n) otherwise
func (rg *ResidualGraph) GetSortedNodes() []int64 <span class="cov8" title="1">{
        rg.sortedNodesMu.Lock()
        defer rg.sortedNodesMu.Unlock()

        if rg.sortedNodesDirty || len(rg.sortedNodes) != len(rg.Nodes) </span><span class="cov8" title="1">{
                rg.sortedNodes = make([]int64, 0, len(rg.Nodes))
                for node := range rg.Nodes </span><span class="cov8" title="1">{
                        rg.sortedNodes = append(rg.sortedNodes, node)
                }</span>
                <span class="cov8" title="1">sort.Slice(rg.sortedNodes, func(i, j int) bool </span><span class="cov8" title="1">{
                        return rg.sortedNodes[i] &lt; rg.sortedNodes[j]
                }</span>)
                <span class="cov8" title="1">rg.sortedNodesDirty = false</span>
        }

        <span class="cov8" title="1">return rg.sortedNodes</span>
}

// NodeCount returns the number of nodes in the graph.
func (rg *ResidualGraph) NodeCount() int <span class="cov8" title="1">{
        return len(rg.Nodes)
}</span>

// EdgeCount returns the total number of edges (including reverse edges).
func (rg *ResidualGraph) EdgeCount() int <span class="cov8" title="1">{
        count := 0
        for _, edges := range rg.EdgesList </span><span class="cov8" title="1">{
                count += len(edges)
        }</span>
        <span class="cov8" title="1">return count</span>
}

// =============================================================================
// Flow Operations
// =============================================================================

// UpdateFlow pushes flow along an edge and updates the residual graph.
//
// This operation:
//   - Decreases the forward edge capacity by 'flow'
//   - Increases the forward edge flow by 'flow'
//   - Increases the backward edge capacity by 'flow'
//
// The backward edge is created if it doesn't exist.
//
// Parameters:
//   - from: Source node of the edge
//   - to: Destination node of the edge
//   - flow: Amount of flow to push (must be positive)
func (rg *ResidualGraph) UpdateFlow(from, to int64, flow float64) <span class="cov8" title="1">{
        // Update forward edge
        if edge := rg.GetEdge(from, to); edge != nil </span><span class="cov8" title="1">{
                edge.Flow += flow
                edge.Capacity -= flow
        }</span>

        // Update or create backward edge
        <span class="cov8" title="1">if backEdge := rg.GetEdge(to, from); backEdge != nil </span><span class="cov8" title="1">{
                backEdge.Capacity += flow
        }</span> else<span class="cov8" title="1"> {
                // Create backward edge if it doesn't exist
                if rg.Edges[to] == nil </span><span class="cov8" title="1">{
                        rg.Edges[to] = make(map[int64]*ResidualEdge)
                }</span>
                <span class="cov8" title="1">forwardEdge := rg.GetEdge(from, to)
                cost := 0.0
                if forwardEdge != nil </span><span class="cov8" title="1">{
                        cost = -forwardEdge.Cost
                }</span>
                <span class="cov8" title="1">newEdge := &amp;ResidualEdge{
                        To:               from,
                        Capacity:         flow,
                        Cost:             cost,
                        Flow:             0,
                        OriginalCapacity: 0,
                        IsReverse:        true,
                        Index:            len(rg.EdgesList[to]),
                }
                rg.Edges[to][from] = newEdge
                rg.EdgesList[to] = append(rg.EdgesList[to], newEdge)
                rg.addReverseIndex(to, from, newEdge)</span>
        }
}

// GetFlowOnEdge returns the current flow on an edge.
//
// Returns 0 if the edge doesn't exist.
func (rg *ResidualGraph) GetFlowOnEdge(from, to int64) float64 <span class="cov8" title="1">{
        if edge := rg.GetEdge(from, to); edge != nil </span><span class="cov8" title="1">{
                return edge.Flow
        }</span>
        <span class="cov8" title="1">return 0</span>
}

// GetTotalFlow computes the total flow leaving the source node.
//
// This is the standard way to determine the flow value after running
// a max-flow algorithm.
func (rg *ResidualGraph) GetTotalFlow(source int64) float64 <span class="cov8" title="1">{
        totalFlow := 0.0
        for _, edge := range rg.EdgesList[source] </span><span class="cov8" title="1">{
                if !edge.IsReverse &amp;&amp; edge.Flow &gt; 0 </span><span class="cov8" title="1">{
                        totalFlow += edge.Flow
                }</span>
        }
        <span class="cov8" title="1">return totalFlow</span>
}

// GetTotalCost computes the total cost of all flow in the graph.
//
// Only forward edges with positive flow contribute to the cost.
// The result is deterministic due to sorted node iteration.
func (rg *ResidualGraph) GetTotalCost() float64 <span class="cov8" title="1">{
        totalCost := 0.0
        nodes := rg.GetSortedNodes()
        for _, from := range nodes </span><span class="cov8" title="1">{
                for _, edge := range rg.EdgesList[from] </span><span class="cov8" title="1">{
                        if !edge.IsReverse &amp;&amp; edge.Flow &gt; 0 </span><span class="cov8" title="1">{
                                totalCost += edge.Flow * edge.Cost
                        }</span>
                }
        }
        <span class="cov8" title="1">return totalCost</span>
}

// =============================================================================
// Graph Operations
// =============================================================================

// Clone creates a deep copy of the graph.
//
// The cloned graph is completely independent and can be modified
// without affecting the original.
//
// Use CloneToPooled() for better performance when using pooling.
func (rg *ResidualGraph) Clone() *ResidualGraph <span class="cov8" title="1">{
        clone := NewResidualGraph()

        for node := range rg.Nodes </span><span class="cov8" title="1">{
                clone.Nodes[node] = true
        }</span>

        <span class="cov8" title="1">for from, edges := range rg.EdgesList </span><span class="cov8" title="1">{
                clone.Edges[from] = make(map[int64]*ResidualEdge, len(edges))
                clone.EdgesList[from] = make([]*ResidualEdge, len(edges))

                for i, edge := range edges </span><span class="cov8" title="1">{
                        clonedEdge := &amp;ResidualEdge{
                                To:               edge.To,
                                Capacity:         edge.Capacity,
                                Cost:             edge.Cost,
                                Flow:             edge.Flow,
                                OriginalCapacity: edge.OriginalCapacity,
                                IsReverse:        edge.IsReverse,
                                Index:            edge.Index,
                        }
                        clone.Edges[from][edge.To] = clonedEdge
                        clone.EdgesList[from][i] = clonedEdge
                        clone.addReverseIndex(from, edge.To, clonedEdge)
                }</span>
        }

        <span class="cov8" title="1">clone.sortedNodesDirty = true
        return clone</span>
}

// CloneToPooled creates a deep copy using a graph from the pool.
//
// This is more efficient than Clone() when the pool has available graphs.
// The caller is responsible for returning the cloned graph to the pool
// when done.
//
// Example:
//
//        pool := graph.GetPool()
//        cloned := g.CloneToPooled(pool)
//        defer pool.ReleaseGraph(cloned)
//        // ... use cloned ...
func (rg *ResidualGraph) CloneToPooled(pool *GraphPool) *ResidualGraph <span class="cov8" title="1">{
        clone := pool.AcquireGraph()

        for node := range rg.Nodes </span><span class="cov8" title="1">{
                clone.Nodes[node] = true
        }</span>

        <span class="cov8" title="1">for from, edges := range rg.EdgesList </span><span class="cov8" title="1">{
                clone.Edges[from] = make(map[int64]*ResidualEdge, len(edges))
                clone.EdgesList[from] = make([]*ResidualEdge, 0, len(edges))

                for _, edge := range edges </span><span class="cov8" title="1">{
                        clonedEdge := &amp;ResidualEdge{
                                To:               edge.To,
                                Capacity:         edge.Capacity,
                                Cost:             edge.Cost,
                                Flow:             edge.Flow,
                                OriginalCapacity: edge.OriginalCapacity,
                                IsReverse:        edge.IsReverse,
                                Index:            len(clone.EdgesList[from]),
                        }
                        clone.Edges[from][edge.To] = clonedEdge
                        clone.EdgesList[from] = append(clone.EdgesList[from], clonedEdge)
                        clone.addReverseIndex(from, edge.To, clonedEdge)
                }</span>
        }

        <span class="cov8" title="1">clone.sortedNodesDirty = true
        return clone</span>
}

// Reset clears all flow and restores original capacities.
//
// This allows rerunning algorithms on the same graph structure
// without recreating it.
func (rg *ResidualGraph) Reset() <span class="cov8" title="1">{
        for _, edges := range rg.EdgesList </span><span class="cov8" title="1">{
                for _, edge := range edges </span><span class="cov8" title="1">{
                        if edge.IsReverse </span><span class="cov8" title="1">{
                                edge.Capacity = 0
                        }</span> else<span class="cov8" title="1"> {
                                edge.Capacity = edge.OriginalCapacity
                        }</span>
                        <span class="cov8" title="1">edge.Flow = 0</span>
                }
        }
}

// GetAllEdges returns all forward (non-reverse) edges in deterministic order.
//
// Useful for exporting graph structure or computing statistics.
func (rg *ResidualGraph) GetAllEdges() []*ResidualEdge <span class="cov8" title="1">{
        var result []*ResidualEdge
        nodes := rg.GetSortedNodes()
        for _, from := range nodes </span><span class="cov8" title="1">{
                for _, edge := range rg.EdgesList[from] </span><span class="cov8" title="1">{
                        if !edge.IsReverse </span><span class="cov8" title="1">{
                                result = append(result, edge)
                        }</span>
                }
        }
        <span class="cov8" title="1">return result</span>
}

// =============================================================================
// Thread-Safe Wrapper
// =============================================================================

// SafeResidualGraph provides thread-safe access to a ResidualGraph.
//
// Use this when the graph needs to be accessed from multiple goroutines.
// Write operations use an exclusive lock, read operations use a shared lock.
//
// For compute-intensive algorithms, it's usually better to clone the graph
// and work on the clone without locking.
//
// # Example
//
//        safe := NewSafeResidualGraph()
//        safe.WithWriteLock(func(g *ResidualGraph) {
//            g.AddEdgeWithReverse(1, 2, 10, 0)
//        })
//
//        var maxFlow float64
//        safe.WithReadLock(func(g *ResidualGraph) {
//            maxFlow = g.GetTotalFlow(1)
//        })
type SafeResidualGraph struct {
        mu    sync.RWMutex
        graph *ResidualGraph
}

// NewSafeResidualGraph creates a new thread-safe graph wrapper.
func NewSafeResidualGraph() *SafeResidualGraph <span class="cov8" title="1">{
        return &amp;SafeResidualGraph{
                graph: NewResidualGraph(),
        }
}</span>

// WithReadLock executes a function with read lock held.
//
// Multiple goroutines can hold read locks simultaneously.
// The function must not modify the graph.
func (sg *SafeResidualGraph) WithReadLock(fn func(*ResidualGraph)) <span class="cov8" title="1">{
        sg.mu.RLock()
        defer sg.mu.RUnlock()
        fn(sg.graph)
}</span>

// WithWriteLock executes a function with exclusive write lock held.
//
// Only one goroutine can hold the write lock at a time.
func (sg *SafeResidualGraph) WithWriteLock(fn func(*ResidualGraph)) <span class="cov8" title="1">{
        sg.mu.Lock()
        defer sg.mu.Unlock()
        fn(sg.graph)
}</span>

// CloneUnsafe returns a deep copy for local work.
//
// The returned graph is independent and can be used without locking.
// This is the recommended pattern for running algorithms concurrently.
func (sg *SafeResidualGraph) CloneUnsafe() *ResidualGraph <span class="cov8" title="1">{
        sg.mu.RLock()
        defer sg.mu.RUnlock()
        return sg.graph.Clone()
}</span>

// ClonePooled returns a deep copy from the pool.
//
// More efficient than CloneUnsafe() when using pooling.
// The caller must return the graph to the pool when done.
func (sg *SafeResidualGraph) ClonePooled(pool *GraphPool) *ResidualGraph <span class="cov8" title="1">{
        sg.mu.RLock()
        defer sg.mu.RUnlock()
        return sg.graph.CloneToPooled(pool)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Package service provides the gRPC service implementation for the solver microservice.
//
// The SolverService handles network flow optimization requests, supporting multiple
// algorithms including Ford-Fulkerson, Edmonds-Karp, Dinic, Push-Relabel, and
// Min-Cost Max-Flow variants.
//
// # Thread Safety
//
// The service is designed for concurrent use. Each request operates on its own
// copy of the graph, and all shared state is protected by appropriate synchronization.
//
// # Resource Management
//
// The service uses object pooling for graphs and related data structures to minimize
// GC pressure under high load. Resources are automatically released after each request.
//
// # Graceful Shutdown
//
// The service supports graceful shutdown via the Shutdown() method, which waits for
// all in-flight requests to complete before returning.
package service

import (
        "context"
        "fmt"
        "runtime"
        "sync"
        "sync/atomic"
        "time"

        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/trace"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"

        commonv1 "logistics/gen/go/logistics/common/v1"
        optimizationv1 "logistics/gen/go/logistics/optimization/v1"
        pkgerrors "logistics/pkg/apperror"
        "logistics/pkg/cache"
        "logistics/pkg/domain"
        "logistics/pkg/logger"
        "logistics/pkg/metrics"
        "logistics/pkg/telemetry"
        "logistics/services/solver-svc/internal/algorithms"
        "logistics/services/solver-svc/internal/converter"
        "logistics/services/solver-svc/internal/graph"
)

// =============================================================================
// Constants and Limits
// =============================================================================

const (
        // MaxGraphNodes is the maximum number of nodes allowed in a graph.
        MaxGraphNodes = 1_000_000

        // MaxGraphEdges is the maximum number of edges allowed in a graph.
        MaxGraphEdges = 10_000_000

        // MinEpsilon is the minimum allowed epsilon value for floating-point comparisons.
        MinEpsilon = 1e-15

        // MaxEpsilon is the maximum allowed epsilon value.
        MaxEpsilon = 1e-3

        // MinTimeoutSeconds is the minimum allowed timeout in seconds.
        MinTimeoutSeconds = 0.1

        // MaxTimeoutSeconds is the maximum allowed timeout (1 hour).
        MaxTimeoutSeconds = 3600.0

        // MinIterations is the minimum iteration limit when specified.
        MinIterations = 10

        // CacheOperationTimeout is the timeout for cache operations.
        CacheOperationTimeout = 5 * time.Second

        // StreamProgressInterval is the minimum interval between progress updates.
        StreamProgressInterval = 200 * time.Millisecond

        // ContextCheckInterval is how often to check for context cancellation in loops.
        ContextCheckInterval = 10
)

// =============================================================================
// Configuration
// =============================================================================

// ServiceConfig holds the configuration for the SolverService.
type ServiceConfig struct {
        // MaxConcurrentSolves limits the number of simultaneous solve operations.
        // Requests beyond this limit will wait or timeout.
        MaxConcurrentSolves int

        // DefaultTimeout is applied when no timeout is specified in the request.
        DefaultTimeout time.Duration

        // MemStatsInterval controls how often memory statistics are refreshed.
        // More frequent updates have higher overhead but provide more accurate data.
        MemStatsInterval time.Duration

        // ShutdownTimeout is the maximum time to wait for in-flight requests during shutdown.
        ShutdownTimeout time.Duration

        // EnableMemoryTracking enables per-request memory usage tracking.
        // This adds some overhead but provides useful metrics.
        EnableMemoryTracking bool
}

// DefaultServiceConfig returns a ServiceConfig with sensible defaults.
func DefaultServiceConfig() *ServiceConfig <span class="cov8" title="1">{
        return &amp;ServiceConfig{
                MaxConcurrentSolves:  runtime.NumCPU() * 2,
                DefaultTimeout:       30 * time.Second,
                MemStatsInterval:     time.Second,
                ShutdownTimeout:      30 * time.Second,
                EnableMemoryTracking: true,
        }
}</span>

// =============================================================================
// Statistics
// =============================================================================

// serviceStats holds atomic counters for service metrics.
type serviceStats struct {
        requestsTotal   atomic.Int64
        requestsActive  atomic.Int64
        requestsSuccess atomic.Int64
        requestsFailed  atomic.Int64
        cacheHits       atomic.Int64
        cacheMisses     atomic.Int64
}

// Stats is a snapshot of service statistics.
type Stats struct {
        RequestsTotal   int64
        RequestsActive  int64
        RequestsSuccess int64
        RequestsFailed  int64
        CacheHits       int64
        CacheMisses     int64
}

// =============================================================================
// Memory Stats Cache
// =============================================================================

// memStatsCache provides cached access to runtime memory statistics.
type memStatsCache struct {
        mu       sync.RWMutex
        stats    runtime.MemStats
        lastRead time.Time
        interval time.Duration
}

// newMemStatsCache creates a new memory stats cache with the specified refresh interval.
func newMemStatsCache(interval time.Duration) *memStatsCache <span class="cov8" title="1">{
        return &amp;memStatsCache{
                interval: interval,
        }
}</span>

// get returns the current memory allocation, using cached value if fresh enough.
func (m *memStatsCache) get() uint64 <span class="cov8" title="1">{
        m.mu.RLock()
        if time.Since(m.lastRead) &lt; m.interval </span><span class="cov8" title="1">{
                alloc := m.stats.Alloc
                m.mu.RUnlock()
                return alloc
        }</span>
        <span class="cov8" title="1">m.mu.RUnlock()

        return m.refresh()</span>
}

// refresh forces a memory stats read and returns the current allocation.
func (m *memStatsCache) refresh() uint64 <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        // Double-check after acquiring write lock
        if time.Since(m.lastRead) &lt; m.interval </span><span class="cov8" title="1">{
                return m.stats.Alloc
        }</span>

        <span class="cov8" title="1">runtime.ReadMemStats(&amp;m.stats)
        m.lastRead = time.Now()
        return m.stats.Alloc</span>
}

// =============================================================================
// SolverService
// =============================================================================

// SolverService implements the gRPC SolverService for network flow optimization.
//
// The service is safe for concurrent use from multiple goroutines.
type SolverService struct {
        optimizationv1.UnimplementedSolverServiceServer

        version     string
        metrics     *metrics.Metrics
        solverCache *cache.SolverCache
        config      *ServiceConfig

        graphPool  *graph.GraphPool
        solverPool *algorithms.SolverPool

        stats         serviceStats
        memStatsCache *memStatsCache

        // Shutdown coordination
        shutdownCh   chan struct{}
        shutdownOnce sync.Once
        wg           sync.WaitGroup
}

// NewSolverService creates a new SolverService with default configuration.
func NewSolverService(version string, solverCache *cache.SolverCache) *SolverService <span class="cov8" title="1">{
        return NewSolverServiceWithConfig(version, solverCache, DefaultServiceConfig())
}</span>

// NewSolverServiceWithConfig creates a new SolverService with custom configuration.
func NewSolverServiceWithConfig(version string, solverCache *cache.SolverCache, config *ServiceConfig) *SolverService <span class="cov8" title="1">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultServiceConfig()
        }</span>

        <span class="cov8" title="1">return &amp;SolverService{
                version:       version,
                metrics:       metrics.Get(),
                solverCache:   solverCache,
                config:        config,
                graphPool:     graph.GetPool(),
                solverPool:    algorithms.NewSolverPool(config.MaxConcurrentSolves),
                memStatsCache: newMemStatsCache(config.MemStatsInterval),
                shutdownCh:    make(chan struct{}),
        }</span>
}

// =============================================================================
// Main Solve Method
// =============================================================================

// Solve handles a synchronous flow optimization request.
//
// The method:
//  1. Checks cache for existing result
//  2. Validates the request
//  3. Acquires a solver slot (with backpressure)
//  4. Runs the requested algorithm
//  5. Caches the result asynchronously
//  6. Returns the solution
//
// Thread-safe: can be called concurrently from multiple goroutines.
func (s *SolverService) Solve(ctx context.Context, req *optimizationv1.SolveRequest) (*optimizationv1.SolveResponse, error) <span class="cov8" title="1">{
        // Track request lifecycle
        if err := s.trackRequest(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer s.untrackRequest()

        // Start tracing span
        ctx, span := telemetry.StartSpan(ctx, "SolverService.Solve",
                trace.WithAttributes(
                        attribute.String("algorithm", req.Algorithm.String()),
                ),
        )
        defer span.End()

        // Check cache first
        if cached, found := s.checkCache(ctx, req, span); found </span><span class="cov8" title="1">{
                return cached, nil
        }</span>

        // Validate request
        <span class="cov8" title="1">if err := s.validateSolveRequest(req); err != nil </span><span class="cov8" title="1">{
                s.stats.requestsFailed.Add(1)
                telemetry.SetError(ctx, err)
                return nil, err
        }</span>

        // Build options and create context with timeout
        <span class="cov8" title="1">opts := s.buildSolverOptions(req.Options)
        ctx, cancel := s.createTimeoutContext(ctx, opts)
        defer cancel()

        // Execute solve operation
        return s.executeSolve(ctx, req, opts, span)</span>
}

// trackRequest registers a new request and checks shutdown status.
func (s *SolverService) trackRequest() error <span class="cov8" title="1">{
        select </span>{
        case &lt;-s.shutdownCh:<span class="cov0" title="0">
                return status.Error(codes.Unavailable, "service is shutting down")</span>
        default:<span class="cov8" title="1"></span>
        }

        <span class="cov8" title="1">s.wg.Add(1)
        s.stats.requestsTotal.Add(1)
        s.stats.requestsActive.Add(1)
        return nil</span>
}

// untrackRequest decrements the active request counter.
func (s *SolverService) untrackRequest() <span class="cov8" title="1">{
        s.stats.requestsActive.Add(-1)
        s.wg.Done()
}</span>

// checkCache attempts to retrieve a cached result.
func (s *SolverService) checkCache(ctx context.Context, req *optimizationv1.SolveRequest, span trace.Span) (*optimizationv1.SolveResponse, bool) <span class="cov8" title="1">{
        if s.solverCache == nil </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        <span class="cov8" title="1">cached, found, err := s.solverCache.Get(ctx, req.Graph, req.Algorithm)
        if err != nil || !found </span><span class="cov8" title="1">{
                s.stats.cacheMisses.Add(1)
                span.SetAttributes(attribute.Bool("cache_hit", false))
                return nil, false
        }</span>

        <span class="cov8" title="1">s.stats.cacheHits.Add(1)
        span.SetAttributes(attribute.Bool("cache_hit", true))
        telemetry.AddEvent(ctx, "cache_hit",
                attribute.Float64("max_flow", cached.MaxFlow),
        )

        return &amp;optimizationv1.SolveResponse{
                Success: true,
                Result:  cached.ToFlowResult(),
                Metrics: &amp;optimizationv1.SolveMetrics{
                        ComputationTimeMs: 0,
                },
        }, true</span>
}

// createTimeoutContext creates a context with the appropriate timeout.
func (s *SolverService) createTimeoutContext(ctx context.Context, opts *algorithms.SolverOptions) (context.Context, context.CancelFunc) <span class="cov8" title="1">{
        timeout := opts.Timeout
        if timeout == 0 </span><span class="cov0" title="0">{
                timeout = s.config.DefaultTimeout
        }</span>
        <span class="cov8" title="1">return context.WithTimeout(ctx, timeout)</span>
}

// executeSolve runs the actual solve operation.
func (s *SolverService) executeSolve(ctx context.Context, req *optimizationv1.SolveRequest, opts *algorithms.SolverOptions, span trace.Span) (*optimizationv1.SolveResponse, error) <span class="cov8" title="1">{
        start := time.Now()

        // Track memory before
        var memBefore uint64
        if s.config.EnableMemoryTracking </span><span class="cov8" title="1">{
                memBefore = s.memStatsCache.refresh()
        }</span>

        // Acquire solver slot
        <span class="cov8" title="1">if err := s.solverPool.Acquire(ctx); err != nil </span><span class="cov0" title="0">{
                s.stats.requestsFailed.Add(1)
                if ctx.Err() == context.DeadlineExceeded </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.DeadlineExceeded, "timeout waiting for solver slot")
                }</span>
                <span class="cov0" title="0">return nil, status.Error(codes.ResourceExhausted, "too many concurrent requests")</span>
        }
        <span class="cov8" title="1">defer s.solverPool.Release()

        // Convert and solve
        rg := converter.ToResidualGraph(req.Graph)
        result := algorithms.Solve(ctx, rg, req.Graph.SourceId, req.Graph.SinkId, req.Algorithm, opts)

        elapsed := time.Since(start)

        // Calculate memory used
        var memUsed int64
        if s.config.EnableMemoryTracking </span><span class="cov8" title="1">{
                memAfter := s.memStatsCache.refresh()
                if memAfter &gt; memBefore </span><span class="cov0" title="0">{
                        memUsed = int64(memAfter - memBefore)
                }</span>
        }

        // Handle errors
        <span class="cov8" title="1">if result.Error != nil </span><span class="cov8" title="1">{
                return s.handleSolveError(ctx, result, elapsed)
        }</span>

        // Build successful response
        <span class="cov8" title="1">return s.buildSuccessResponse(ctx, req, rg, result, opts, elapsed, memUsed, span)</span>
}

// handleSolveError processes a failed solve result.
func (s *SolverService) handleSolveError(ctx context.Context, result *algorithms.SolverResult, elapsed time.Duration) (*optimizationv1.SolveResponse, error) <span class="cov8" title="1">{
        s.stats.requestsFailed.Add(1)
        telemetry.SetError(ctx, result.Error)

        if result.Status == commonv1.FlowStatus_FLOW_STATUS_ERROR </span><span class="cov8" title="1">{
                return nil, status.Error(codes.DeadlineExceeded, "computation timeout")
        }</span>

        <span class="cov0" title="0">return &amp;optimizationv1.SolveResponse{
                Success:      false,
                ErrorMessage: result.Error.Error(),
                Metrics: &amp;optimizationv1.SolveMetrics{
                        ComputationTimeMs: float64(elapsed.Milliseconds()),
                },
        }, nil</span>
}

// buildSuccessResponse constructs the response for a successful solve.
func (s *SolverService) buildSuccessResponse(
        ctx context.Context,
        req *optimizationv1.SolveRequest,
        rg *graph.ResidualGraph,
        result *algorithms.SolverResult,
        opts *algorithms.SolverOptions,
        elapsed time.Duration,
        memUsed int64,
        span trace.Span,
) (*optimizationv1.SolveResponse, error) <span class="cov8" title="1">{
        s.stats.requestsSuccess.Add(1)

        flowResult := &amp;commonv1.FlowResult{
                MaxFlow:           result.MaxFlow,
                TotalCost:         result.TotalCost,
                Edges:             converter.ToFlowEdges(rg),
                Status:            result.Status,
                Iterations:        int32(result.Iterations),
                ComputationTimeMs: float64(elapsed.Milliseconds()),
        }

        if opts.ReturnPaths &amp;&amp; len(result.Paths) &gt; 0 </span><span class="cov8" title="1">{
                flowResult.Paths = converter.ToPaths(result.Paths, rg)
        }</span>

        // Cache result asynchronously
        <span class="cov8" title="1">s.cacheResultAsync(req.Graph, req.Algorithm, flowResult)

        // Record metrics
        if s.metrics != nil </span><span class="cov8" title="1">{
                s.metrics.RecordSolveOperation(
                        req.Algorithm.String(),
                        true,
                        elapsed,
                        result.MaxFlow,
                )
        }</span>

        <span class="cov8" title="1">span.SetAttributes(
                attribute.Float64("max_flow", result.MaxFlow),
                attribute.Int("iterations", result.Iterations),
        )

        return &amp;optimizationv1.SolveResponse{
                Success:     true,
                Result:      flowResult,
                SolvedGraph: converter.UpdateGraphWithFlow(req.Graph, rg),
                Metrics: &amp;optimizationv1.SolveMetrics{
                        ComputationTimeMs:    float64(elapsed.Milliseconds()),
                        Iterations:           int32(result.Iterations),
                        AugmentingPathsFound: int32(len(result.Paths)),
                        MemoryUsedBytes:      memUsed,
                },
        }, nil</span>
}

// cacheResultAsync asynchronously caches the solve result.
// The goroutine is properly tracked for graceful shutdown.
func (s *SolverService) cacheResultAsync(g *commonv1.Graph, algorithm commonv1.Algorithm, result *commonv1.FlowResult) <span class="cov8" title="1">{
        if s.solverCache == nil </span><span class="cov8" title="1">{
                return
        }</span>

        // Check shutdown before spawning goroutine
        <span class="cov8" title="1">select </span>{
        case &lt;-s.shutdownCh:<span class="cov0" title="0">
                return</span>
        default:<span class="cov8" title="1"></span>
        }

        // Track this goroutine in WaitGroup
        <span class="cov8" title="1">s.wg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer s.wg.Done()

                ctx, cancel := context.WithTimeout(context.Background(), CacheOperationTimeout)
                defer cancel()

                // Check shutdown again inside goroutine
                select </span>{
                case &lt;-s.shutdownCh:<span class="cov0" title="0">
                        return</span>
                default:<span class="cov8" title="1"></span>
                }

                <span class="cov8" title="1">response := &amp;optimizationv1.SolveResponse{Result: result}
                if err := s.solverCache.SetFromResponse(ctx, g, algorithm, response, 0); err != nil </span><span class="cov8" title="1">{
                        logger.Log.Warn("Failed to cache solve result", "error", err)
                }</span>
        }()
}

// =============================================================================
// Streaming Solve
// =============================================================================

// SolveStream handles a streaming flow optimization request with progress updates.
//
// Progress updates are sent periodically as the algorithm runs, allowing clients
// to monitor long-running computations and display real-time status.
func (s *SolverService) SolveStream(req *optimizationv1.SolveRequestForBigGraphs, stream optimizationv1.SolverService_SolveStreamServer) error <span class="cov8" title="1">{
        // Track request lifecycle
        if err := s.trackRequest(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer s.untrackRequest()

        ctx := stream.Context()
        ctx, span := telemetry.StartSpan(ctx, "SolverService.SolveStream",
                trace.WithAttributes(
                        attribute.String("algorithm", req.Algorithm.String()),
                        attribute.Int("nodes", len(req.Graph.Nodes)),
                        attribute.Int("edges", len(req.Graph.Edges)),
                ),
        )
        defer span.End()

        // Validate request
        if err := s.validateStreamRequest(req); err != nil </span><span class="cov0" title="0">{
                s.stats.requestsFailed.Add(1)
                telemetry.SetError(ctx, err)
                return err
        }</span>

        // Build options and create context
        <span class="cov8" title="1">opts := s.buildSolverOptions(req.Options)
        ctx, cancel := s.createTimeoutContext(ctx, opts)
        defer cancel()

        // Acquire solver slot
        if err := s.solverPool.Acquire(ctx); err != nil </span><span class="cov8" title="1">{
                s.stats.requestsFailed.Add(1)
                if ctx.Err() != nil </span><span class="cov8" title="1">{
                        return ctx.Err()
                }</span>
                <span class="cov0" title="0">return status.Error(codes.ResourceExhausted, "too many concurrent requests")</span>
        }
        <span class="cov8" title="1">defer s.solverPool.Release()

        // Execute streaming solve
        return s.executeStreamSolve(ctx, req, opts, stream)</span>
}

// executeStreamSolve runs the streaming solve operation.
func (s *SolverService) executeStreamSolve(
        ctx context.Context,
        req *optimizationv1.SolveRequestForBigGraphs,
        opts *algorithms.SolverOptions,
        stream optimizationv1.SolverService_SolveStreamServer,
) error <span class="cov8" title="1">{
        start := time.Now()
        progress := newProgressTracker(stream, start, s.memStatsCache)

        // Check context before starting
        if ctx.Err() != nil </span><span class="cov0" title="0">{
                s.stats.requestsFailed.Add(1)
                return ctx.Err()
        }</span>

        // Send initial progress
        <span class="cov8" title="1">if err := progress.sendStatus("starting", 0, 0); err != nil </span><span class="cov8" title="1">{
                s.stats.requestsFailed.Add(1)
                return err
        }</span>

        <span class="cov8" title="1">rg := converter.ToResidualGraph(req.Graph)
        source := req.Graph.SourceId
        sink := req.Graph.SinkId

        // Run algorithm with progress callback
        var err error
        switch req.Algorithm </span>{
        case commonv1.Algorithm_ALGORITHM_DINIC:<span class="cov8" title="1">
                err = s.streamDinic(ctx, rg, source, sink, opts, progress)</span>
        case commonv1.Algorithm_ALGORITHM_PUSH_RELABEL:<span class="cov8" title="1">
                err = s.streamPushRelabel(ctx, rg, source, sink, opts, progress)</span>
        case commonv1.Algorithm_ALGORITHM_MIN_COST:<span class="cov8" title="1">
                err = s.streamMinCostFlow(ctx, rg, source, sink, opts, progress)</span>
        default:<span class="cov8" title="1">
                err = s.streamEdmondsKarp(ctx, rg, source, sink, opts, progress)</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                s.stats.requestsFailed.Add(1)
                // Return context errors directly (Canceled or DeadlineExceeded)
                // This allows callers to distinguish between cancellation and timeout
                return err
        }</span>

        <span class="cov8" title="1">s.stats.requestsSuccess.Add(1)

        // Send final progress
        maxFlow := rg.GetTotalFlow(source)
        telemetry.AddEvent(ctx, "stream_completed", attribute.Float64("max_flow", maxFlow))

        return progress.sendCompleted(maxFlow)</span>
}

// =============================================================================
// Progress Tracker
// =============================================================================

// progressTracker manages progress updates for streaming operations.
type progressTracker struct {
        stream        optimizationv1.SolverService_SolveStreamServer
        start         time.Time
        lastSendTime  time.Time
        memStatsCache *memStatsCache
}

// newProgressTracker creates a new progress tracker.
func newProgressTracker(stream optimizationv1.SolverService_SolveStreamServer, start time.Time, memCache *memStatsCache) *progressTracker <span class="cov8" title="1">{
        return &amp;progressTracker{
                stream:        stream,
                start:         start,
                lastSendTime:  start,
                memStatsCache: memCache,
        }
}</span>

// sendProgress sends a progress update if enough time has passed.
func (p *progressTracker) sendProgress(iteration int, currentFlow float64, path []int64, pathFlow float64) error <span class="cov8" title="1">{
        if time.Since(p.lastSendTime) &lt; StreamProgressInterval &amp;&amp; iteration &gt; 1 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return p.sendProgressForced(iteration, currentFlow, "running", path, pathFlow)</span>
}

// sendProgressWithCost sends a progress update including cost information.
func (p *progressTracker) sendProgressWithCost(iteration int, currentFlow, currentCost float64, path []int64, pathFlow float64) error <span class="cov8" title="1">{
        if time.Since(p.lastSendTime) &lt; StreamProgressInterval &amp;&amp; iteration &gt; 1 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">status := fmt.Sprintf("running (cost: %.2f)", currentCost)
        return p.sendProgressForced(iteration, currentFlow, status, path, pathFlow)</span>
}

// sendProgressForced sends a progress update regardless of throttling.
func (p *progressTracker) sendProgressForced(iteration int, currentFlow float64, statusMsg string, path []int64, pathFlow float64) error <span class="cov8" title="1">{
        progress := &amp;optimizationv1.SolveProgress{
                Iteration:         int32(iteration),
                CurrentFlow:       currentFlow,
                Status:            statusMsg,
                ComputationTimeMs: float64(time.Since(p.start).Milliseconds()),
                MemoryUsedBytes:   int64(p.memStatsCache.get()),
        }

        if len(path) &gt; 0 </span><span class="cov8" title="1">{
                progress.LastPath = &amp;commonv1.Path{
                        NodeIds: path,
                        Flow:    pathFlow,
                }
        }</span>

        <span class="cov8" title="1">if err := p.stream.Send(progress); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">p.lastSendTime = time.Now()
        return nil</span>
}

// sendStatus sends a status-only progress update.
func (p *progressTracker) sendStatus(statusMsg string, iteration int, currentFlow float64) error <span class="cov8" title="1">{
        return p.stream.Send(&amp;optimizationv1.SolveProgress{
                Iteration:         int32(iteration),
                CurrentFlow:       currentFlow,
                Status:            statusMsg,
                ProgressPercent:   0,
                ComputationTimeMs: float64(time.Since(p.start).Milliseconds()),
                MemoryUsedBytes:   int64(p.memStatsCache.get()),
        })
}</span>

// sendCompleted sends the final completion progress.
func (p *progressTracker) sendCompleted(maxFlow float64) error <span class="cov8" title="1">{
        return p.stream.Send(&amp;optimizationv1.SolveProgress{
                CurrentFlow:       maxFlow,
                ProgressPercent:   100.0,
                Status:            "completed",
                ComputationTimeMs: float64(time.Since(p.start).Milliseconds()),
                MemoryUsedBytes:   int64(p.memStatsCache.get()),
        })
}</span>

// =============================================================================
// Streaming Algorithm Implementations
// =============================================================================

// streamEdmondsKarp runs Edmonds-Karp with progress updates.
func (s *SolverService) streamEdmondsKarp(
        ctx context.Context,
        rg *graph.ResidualGraph,
        source, sink int64,
        opts *algorithms.SolverOptions,
        progress *progressTracker,
) error <span class="cov8" title="1">{
        maxFlow := 0.0
        iteration := 0

        for </span><span class="cov8" title="1">{
                // Check context periodically
                if iteration%ContextCheckInterval == 0 </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return ctx.Err()</span>
                        default:<span class="cov8" title="1"></span>
                        }
                }

                // Check iteration limit
                <span class="cov8" title="1">if opts.MaxIterations &gt; 0 &amp;&amp; iteration &gt;= opts.MaxIterations </span><span class="cov0" title="0">{
                        break</span>
                }

                // Find augmenting path
                <span class="cov8" title="1">bfsResult := graph.BFSDeterministic(rg, source, sink)
                if !bfsResult.Found </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">path := domain.ReconstructPath(bfsResult.Parent, source, sink)
                if len(path) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">pathFlow := graph.FindMinCapacityOnPath(rg, path)
                if pathFlow &lt;= opts.Epsilon </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">graph.AugmentPath(rg, path, pathFlow)
                maxFlow += pathFlow
                iteration++

                // Send progress
                if err := progress.sendProgress(iteration, maxFlow, path, pathFlow); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// streamDinic runs Dinic's algorithm with progress updates.
func (s *SolverService) streamDinic(
        ctx context.Context,
        rg *graph.ResidualGraph,
        source, sink int64,
        opts *algorithms.SolverOptions,
        progress *progressTracker,
) error <span class="cov8" title="1">{
        maxFlow := 0.0
        iteration := 0

        for </span><span class="cov8" title="1">{
                // Check context
                if iteration%ContextCheckInterval == 0 </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return ctx.Err()</span>
                        default:<span class="cov8" title="1"></span>
                        }
                }

                // Check iteration limit
                <span class="cov8" title="1">if opts.MaxIterations &gt; 0 &amp;&amp; iteration &gt;= opts.MaxIterations </span><span class="cov0" title="0">{
                        break</span>
                }

                // Build level graph
                <span class="cov8" title="1">level := graph.BFSLevel(rg, source)
                if _, exists := level[sink]; !exists </span><span class="cov8" title="1">{
                        break</span>
                }

                // Find blocking flow
                <span class="cov8" title="1">currentArc := make(map[int64]int)
                phaseFlow := 0.0

                for </span><span class="cov8" title="1">{
                        flow, path := s.dinicDFSIterative(rg, source, sink, level, currentArc, opts.Epsilon)
                        if flow &lt;= opts.Epsilon </span><span class="cov8" title="1">{
                                break</span>
                        }

                        <span class="cov8" title="1">maxFlow += flow
                        phaseFlow += flow
                        iteration++

                        // Send progress
                        if err := progress.sendProgress(iteration, maxFlow, path, flow); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Check context after each path
                        <span class="cov8" title="1">select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return ctx.Err()</span>
                        default:<span class="cov8" title="1"></span>
                        }
                }

                <span class="cov8" title="1">if phaseFlow &lt;= opts.Epsilon </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// dinicDFSIterative performs iterative DFS for Dinic's algorithm.
func (s *SolverService) dinicDFSIterative(
        rg *graph.ResidualGraph,
        source, sink int64,
        level map[int64]int,
        currentArc map[int64]int,
        epsilon float64,
) (float64, []int64) <span class="cov8" title="1">{
        path := make([]int64, 0, 64)
        minCap := make([]float64, 0, 64)

        path = append(path, source)
        minCap = append(minCap, graph.Infinity)

        for len(path) &gt; 0 </span><span class="cov8" title="1">{
                u := path[len(path)-1]

                if u == sink </span><span class="cov8" title="1">{
                        bottleneck := minCap[len(minCap)-1]

                        // Augment flow
                        for i := 0; i &lt; len(path)-1; i++ </span><span class="cov8" title="1">{
                                rg.UpdateFlow(path[i], path[i+1], bottleneck)
                        }</span>

                        <span class="cov8" title="1">result := make([]int64, len(path))
                        copy(result, path)
                        return bottleneck, result</span>
                }

                <span class="cov8" title="1">edges := rg.GetNeighborsList(u)
                startIdx := currentArc[u]

                advanced := false
                for i := startIdx; i &lt; len(edges); i++ </span><span class="cov8" title="1">{
                        edge := edges[i]
                        v := edge.To

                        if level[v] != level[u]+1 || edge.Capacity &lt;= epsilon </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">currentArc[u] = i

                        newMinCap := minCap[len(minCap)-1]
                        if edge.Capacity &lt; newMinCap </span><span class="cov8" title="1">{
                                newMinCap = edge.Capacity
                        }</span>

                        <span class="cov8" title="1">path = append(path, v)
                        minCap = append(minCap, newMinCap)

                        advanced = true
                        break</span>
                }

                <span class="cov8" title="1">if !advanced </span><span class="cov8" title="1">{
                        currentArc[u] = len(edges)
                        delete(level, u)
                        path = path[:len(path)-1]
                        minCap = minCap[:len(minCap)-1]
                }</span>
        }

        <span class="cov8" title="1">return 0, nil</span>
}

// streamPushRelabel runs Push-Relabel with periodic progress updates.
func (s *SolverService) streamPushRelabel(
        ctx context.Context,
        rg *graph.ResidualGraph,
        source, sink int64,
        opts *algorithms.SolverOptions,
        progress *progressTracker,
) error <span class="cov8" title="1">{
        // Run algorithm in goroutine with periodic progress updates
        resultCh := make(chan *algorithms.PushRelabelResult, 1)

        go func() </span><span class="cov8" title="1">{
                result := algorithms.PushRelabelWithContext(ctx, rg, source, sink, opts)
                resultCh &lt;- result
        }</span>()

        <span class="cov8" title="1">progressTicker := time.NewTicker(StreamProgressInterval)
        defer progressTicker.Stop()

        iteration := 0
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>

                case result := &lt;-resultCh:<span class="cov8" title="1">
                        if result.Canceled </span><span class="cov0" title="0">{
                                return ctx.Err()
                        }</span>
                        <span class="cov8" title="1">return nil</span>

                case &lt;-progressTicker.C:<span class="cov0" title="0">
                        iteration++
                        currentFlow := rg.GetTotalFlow(source)
                        if err := progress.sendStatus("running (push-relabel)", iteration, currentFlow); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
}

// streamMinCostFlow runs Min-Cost Flow with progress updates.
func (s *SolverService) streamMinCostFlow(
        ctx context.Context,
        rg *graph.ResidualGraph,
        source, sink int64,
        opts *algorithms.SolverOptions,
        progress *progressTracker,
) error <span class="cov8" title="1">{
        // First, find max flow to determine required flow
        cloned := rg.Clone()
        ekResult := algorithms.EdmondsKarpWithContext(ctx, cloned, source, sink, opts)
        if ekResult.Canceled </span><span class="cov0" title="0">{
                return ctx.Err()
        }</span>
        <span class="cov8" title="1">requiredFlow := ekResult.MaxFlow

        // Initialize potentials
        nodes := rg.GetSortedNodes()
        potentials := make(map[int64]float64, len(nodes))
        for _, node := range nodes </span><span class="cov8" title="1">{
                potentials[node] = 0
        }</span>

        <span class="cov8" title="1">initResult := algorithms.BellmanFordWithContext(ctx, rg, source)
        if initResult.Canceled </span><span class="cov0" title="0">{
                return ctx.Err()
        }</span>

        <span class="cov8" title="1">if !initResult.HasNegativeCycle </span><span class="cov8" title="1">{
                for _, node := range nodes </span><span class="cov8" title="1">{
                        if initResult.Distances[node] &lt; graph.Infinity-graph.Epsilon </span><span class="cov8" title="1">{
                                potentials[node] = initResult.Distances[node]
                        }</span>
                }
        }

        <span class="cov8" title="1">totalFlow := 0.0
        totalCost := 0.0
        iteration := 0
        firstIteration := true

        for totalFlow &lt; requiredFlow-opts.Epsilon </span><span class="cov8" title="1">{
                // Check context
                if iteration%ContextCheckInterval == 0 </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return ctx.Err()</span>
                        default:<span class="cov8" title="1"></span>
                        }
                }

                // Check iteration limit
                <span class="cov8" title="1">if opts.MaxIterations &gt; 0 &amp;&amp; iteration &gt;= opts.MaxIterations </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">var distances map[int64]float64
                var parent map[int64]int64
                var shouldUpdatePotentials bool

                if firstIteration </span><span class="cov8" title="1">{
                        distances = initResult.Distances
                        parent = initResult.Parent
                        shouldUpdatePotentials = false
                        firstIteration = false
                }</span> else<span class="cov0" title="0"> {
                        dijkstraResult := algorithms.DijkstraWithPotentialsContext(ctx, rg, source, potentials)
                        if dijkstraResult.Canceled </span><span class="cov0" title="0">{
                                return ctx.Err()
                        }</span>
                        <span class="cov0" title="0">distances = dijkstraResult.Distances
                        parent = dijkstraResult.Parent
                        shouldUpdatePotentials = true</span>
                }

                <span class="cov8" title="1">if distances[sink] &gt;= graph.Infinity-graph.Epsilon </span><span class="cov0" title="0">{
                        break</span>
                }

                // Update potentials
                <span class="cov8" title="1">if shouldUpdatePotentials </span><span class="cov0" title="0">{
                        for _, node := range nodes </span><span class="cov0" title="0">{
                                if distances[node] &lt; graph.Infinity-graph.Epsilon </span><span class="cov0" title="0">{
                                        potentials[node] += distances[node]
                                }</span>
                        }
                }

                <span class="cov8" title="1">path := graph.ReconstructPath(parent, source, sink)
                if len(path) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">pathFlow := requiredFlow - totalFlow
                pathFlow = min(pathFlow, graph.FindMinCapacityOnPath(rg, path))
                if pathFlow &lt;= opts.Epsilon </span><span class="cov0" title="0">{
                        break</span>
                }

                // Compute path cost
                <span class="cov8" title="1">pathCost := 0.0
                for i := 0; i &lt; len(path)-1; i++ </span><span class="cov8" title="1">{
                        edge := rg.GetEdge(path[i], path[i+1])
                        if edge != nil </span><span class="cov8" title="1">{
                                pathCost += edge.Cost * pathFlow
                        }</span>
                }

                <span class="cov8" title="1">graph.AugmentPath(rg, path, pathFlow)

                totalFlow += pathFlow
                totalCost += pathCost
                iteration++

                // Send progress with cost
                if err := progress.sendProgressWithCost(iteration, totalFlow, totalCost, path, pathFlow); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// =============================================================================
// Algorithm Information
// =============================================================================

// GetAlgorithms returns metadata about all available algorithms.
func (s *SolverService) GetAlgorithms(ctx context.Context, _ *emptypb.Empty) (*optimizationv1.GetAlgorithmsResponse, error) <span class="cov8" title="1">{
        ctx, span := telemetry.StartSpan(ctx, "SolverService.GetAlgorithms")
        defer span.End()

        infos := algorithms.GetAllAlgorithms()
        protoInfos := make([]*optimizationv1.AlgorithmInfo, 0, len(infos))

        for _, info := range infos </span><span class="cov8" title="1">{
                protoInfos = append(protoInfos, &amp;optimizationv1.AlgorithmInfo{
                        Algorithm:             info.Algorithm,
                        Name:                  info.Name,
                        Description:           info.Description,
                        TimeComplexity:        info.TimeComplexity,
                        SpaceComplexity:       info.SpaceComplexity,
                        SupportsMinCost:       info.SupportsMinCost,
                        SupportsNegativeCosts: info.SupportsNegativeCosts,
                        BestFor:               info.BestFor,
                })
        }</span>

        <span class="cov8" title="1">span.SetAttributes(attribute.Int("algorithms_count", len(protoInfos)))

        return &amp;optimizationv1.GetAlgorithmsResponse{
                Algorithms: protoInfos,
        }, nil</span>
}

// =============================================================================
// Health and Statistics
// =============================================================================

// GetStats returns current service statistics.
func (s *SolverService) GetStats() Stats <span class="cov8" title="1">{
        return Stats{
                RequestsTotal:   s.stats.requestsTotal.Load(),
                RequestsActive:  s.stats.requestsActive.Load(),
                RequestsSuccess: s.stats.requestsSuccess.Load(),
                RequestsFailed:  s.stats.requestsFailed.Load(),
                CacheHits:       s.stats.cacheHits.Load(),
                CacheMisses:     s.stats.cacheMisses.Load(),
        }
}</span>

// IsHealthy returns true if the service is operational.
func (s *SolverService) IsHealthy() bool <span class="cov0" title="0">{
        select </span>{
        case &lt;-s.shutdownCh:<span class="cov0" title="0">
                return false</span>
        default:<span class="cov0" title="0">
                return true</span>
        }
}

// IsReady returns true if the service can accept new requests.
// Returns false if at 90% capacity or shutting down.
func (s *SolverService) IsReady() bool <span class="cov0" title="0">{
        if !s.IsHealthy() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">active := s.stats.requestsActive.Load()
        maxConcurrent := int64(s.config.MaxConcurrentSolves)

        return active &lt; (maxConcurrent * 9 / 10)</span>
}

// =============================================================================
// Shutdown
// =============================================================================

// Shutdown gracefully stops the service, waiting for in-flight requests.
//
// The method:
//  1. Closes the shutdown channel to prevent new requests
//  2. Waits for all in-flight requests to complete
//  3. Returns when all requests are done or context is cancelled
//
// Thread-safe: can be called from any goroutine, but only the first call has effect.
func (s *SolverService) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        var err error

        s.shutdownOnce.Do(func() </span><span class="cov0" title="0">{
                close(s.shutdownCh)

                done := make(chan struct{})
                go func() </span><span class="cov0" title="0">{
                        s.wg.Wait()
                        close(done)
                }</span>()

                <span class="cov0" title="0">select </span>{
                case &lt;-done:<span class="cov0" title="0">
                        logger.Log.Info("All requests completed gracefully")</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        err = ctx.Err()
                        logger.Log.Warn("Shutdown timeout, some requests may be interrupted",
                                "active_requests", s.stats.requestsActive.Load(),
                        )</span>
                }
        })

        <span class="cov0" title="0">return err</span>
}

// =============================================================================
// Validation
// =============================================================================

// validateSolveRequest validates a synchronous solve request.
func (s *SolverService) validateSolveRequest(req *optimizationv1.SolveRequest) error <span class="cov8" title="1">{
        return s.validateGraph(req.Graph)
}</span>

// validateStreamRequest validates a streaming solve request.
func (s *SolverService) validateStreamRequest(req *optimizationv1.SolveRequestForBigGraphs) error <span class="cov8" title="1">{
        return s.validateGraph(req.Graph)
}</span>

// validateGraph performs comprehensive graph validation.
func (s *SolverService) validateGraph(g *commonv1.Graph) error <span class="cov8" title="1">{
        if g == nil </span><span class="cov8" title="1">{
                return pkgerrors.ErrNilGraph
        }</span>

        <span class="cov8" title="1">if len(g.Nodes) == 0 </span><span class="cov8" title="1">{
                return pkgerrors.ErrEmptyGraph
        }</span>

        <span class="cov8" title="1">if len(g.Nodes) &gt; MaxGraphNodes </span><span class="cov0" title="0">{
                return status.Errorf(codes.InvalidArgument,
                        "graph has too many nodes: %d &gt; %d", len(g.Nodes), MaxGraphNodes)
        }</span>

        <span class="cov8" title="1">if len(g.Edges) &gt; MaxGraphEdges </span><span class="cov0" title="0">{
                return status.Errorf(codes.InvalidArgument,
                        "graph has too many edges: %d &gt; %d", len(g.Edges), MaxGraphEdges)
        }</span>

        // Build node set
        <span class="cov8" title="1">nodeExists := make(map[int64]bool, len(g.Nodes))
        for _, node := range g.Nodes </span><span class="cov8" title="1">{
                nodeExists[node.Id] = true
        }</span>

        <span class="cov8" title="1">if !nodeExists[g.SourceId] </span><span class="cov8" title="1">{
                return pkgerrors.ErrInvalidSource
        }</span>

        <span class="cov8" title="1">if !nodeExists[g.SinkId] </span><span class="cov8" title="1">{
                return pkgerrors.ErrInvalidSink
        }</span>

        <span class="cov8" title="1">if g.SourceId == g.SinkId </span><span class="cov8" title="1">{
                return pkgerrors.ErrSourceEqualsSink
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// =============================================================================
// Options Building
// =============================================================================

// buildSolverOptions creates algorithm options from request options.
func (s *SolverService) buildSolverOptions(opts *optimizationv1.SolveOptions) *algorithms.SolverOptions <span class="cov8" title="1">{
        result := algorithms.DefaultSolverOptions()

        if opts == nil </span><span class="cov8" title="1">{
                return result
        }</span>

        // Epsilon with bounds validation
        <span class="cov8" title="1">if opts.Epsilon &gt; 0 </span><span class="cov8" title="1">{
                epsilon := opts.Epsilon
                if epsilon &lt; MinEpsilon </span><span class="cov8" title="1">{
                        epsilon = MinEpsilon
                }</span> else<span class="cov8" title="1"> if epsilon &gt; MaxEpsilon </span><span class="cov8" title="1">{
                        epsilon = MaxEpsilon
                }</span>
                <span class="cov8" title="1">result.Epsilon = epsilon</span>
        }

        // MaxIterations with minimum
        <span class="cov8" title="1">if opts.MaxIterations &gt; 0 </span><span class="cov8" title="1">{
                maxIter := int(opts.MaxIterations)
                if maxIter &lt; MinIterations </span><span class="cov8" title="1">{
                        maxIter = MinIterations
                }</span>
                <span class="cov8" title="1">result.MaxIterations = maxIter</span>
        }

        // Timeout with bounds validation
        <span class="cov8" title="1">if opts.TimeoutSeconds &gt; 0 </span><span class="cov8" title="1">{
                timeout := opts.TimeoutSeconds
                if timeout &lt; MinTimeoutSeconds </span><span class="cov8" title="1">{
                        timeout = MinTimeoutSeconds
                }</span> else<span class="cov8" title="1"> if timeout &gt; MaxTimeoutSeconds </span><span class="cov8" title="1">{
                        timeout = MaxTimeoutSeconds
                }</span>
                <span class="cov8" title="1">result.Timeout = time.Duration(timeout * float64(time.Second))</span>
        }

        <span class="cov8" title="1">result.ReturnPaths = opts.ReturnPaths

        return result</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
